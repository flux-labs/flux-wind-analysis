// threejs.org/license
'use strict';var THREE={REVISION:"77"};"function"===typeof define&&define.amd?define("three",THREE):"undefined"!==typeof exports&&"undefined"!==typeof module&&(module.exports=THREE);void 0===Number.EPSILON&&(Number.EPSILON=Math.pow(2,-52));void 0===Math.sign&&(Math.sign=function(a){return 0>a?-1:0<a?1:+a});void 0===Function.prototype.name&&Object.defineProperty(Function.prototype,"name",{get:function(){return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]}});
void 0===Object.assign&&function(){Object.assign=function(a){if(void 0===a||null===a)throw new TypeError("Cannot convert undefined or null to object");for(var b=Object(a),c=1;c<arguments.length;c++){var d=arguments[c];if(void 0!==d&&null!==d)for(var e in d)Object.prototype.hasOwnProperty.call(d,e)&&(b[e]=d[e])}return b}}();
Object.assign(THREE,{MOUSE:{LEFT:0,MIDDLE:1,RIGHT:2},CullFaceNone:0,CullFaceBack:1,CullFaceFront:2,CullFaceFrontBack:3,FrontFaceDirectionCW:0,FrontFaceDirectionCCW:1,BasicShadowMap:0,PCFShadowMap:1,PCFSoftShadowMap:2,FrontSide:0,BackSide:1,DoubleSide:2,FlatShading:1,SmoothShading:2,NoColors:0,FaceColors:1,VertexColors:2,NoBlending:0,NormalBlending:1,AdditiveBlending:2,SubtractiveBlending:3,MultiplyBlending:4,CustomBlending:5,AddEquation:100,SubtractEquation:101,ReverseSubtractEquation:102,MinEquation:103,
MaxEquation:104,ZeroFactor:200,OneFactor:201,SrcColorFactor:202,OneMinusSrcColorFactor:203,SrcAlphaFactor:204,OneMinusSrcAlphaFactor:205,DstAlphaFactor:206,OneMinusDstAlphaFactor:207,DstColorFactor:208,OneMinusDstColorFactor:209,SrcAlphaSaturateFactor:210,NeverDepth:0,AlwaysDepth:1,LessDepth:2,LessEqualDepth:3,EqualDepth:4,GreaterEqualDepth:5,GreaterDepth:6,NotEqualDepth:7,MultiplyOperation:0,MixOperation:1,AddOperation:2,NoToneMapping:0,LinearToneMapping:1,ReinhardToneMapping:2,Uncharted2ToneMapping:3,
CineonToneMapping:4,UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,SphericalReflectionMapping:305,CubeUVReflectionMapping:306,CubeUVRefractionMapping:307,RepeatWrapping:1E3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002,NearestFilter:1003,NearestMipMapNearestFilter:1004,NearestMipMapLinearFilter:1005,LinearFilter:1006,LinearMipMapNearestFilter:1007,LinearMipMapLinearFilter:1008,UnsignedByteType:1009,
ByteType:1010,ShortType:1011,UnsignedShortType:1012,IntType:1013,UnsignedIntType:1014,FloatType:1015,HalfFloatType:1025,UnsignedShort4444Type:1016,UnsignedShort5551Type:1017,UnsignedShort565Type:1018,AlphaFormat:1019,RGBFormat:1020,RGBAFormat:1021,LuminanceFormat:1022,LuminanceAlphaFormat:1023,RGBEFormat:THREE.RGBAFormat,DepthFormat:1026,RGB_S3TC_DXT1_Format:2001,RGBA_S3TC_DXT1_Format:2002,RGBA_S3TC_DXT3_Format:2003,RGBA_S3TC_DXT5_Format:2004,RGB_PVRTC_4BPPV1_Format:2100,RGB_PVRTC_2BPPV1_Format:2101,
RGBA_PVRTC_4BPPV1_Format:2102,RGBA_PVRTC_2BPPV1_Format:2103,RGB_ETC1_Format:2151,LoopOnce:2200,LoopRepeat:2201,LoopPingPong:2202,InterpolateDiscrete:2300,InterpolateLinear:2301,InterpolateSmooth:2302,ZeroCurvatureEnding:2400,ZeroSlopeEnding:2401,WrapAroundEnding:2402,TrianglesDrawMode:0,TriangleStripDrawMode:1,TriangleFanDrawMode:2,LinearEncoding:3E3,sRGBEncoding:3001,GammaEncoding:3007,RGBEEncoding:3002,LogLuvEncoding:3003,RGBM7Encoding:3004,RGBM16Encoding:3005,RGBDEncoding:3006,BasicDepthPacking:3200,
RGBADepthPacking:3201});THREE.Color=function(a,b,c){return void 0===b&&void 0===c?this.set(a):this.setRGB(a,b,c)};
THREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setScalar:function(a){this.b=this.g=this.r=a},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(){function a(a,c,d){0>d&&(d+=1);1<d&&(d-=1);return d<1/6?a+6*(c-a)*
d:.5>d?c:d<2/3?a+6*(c-a)*(2/3-d):a}return function(b,c,d){b=THREE.Math.euclideanModulo(b,1);c=THREE.Math.clamp(c,0,1);d=THREE.Math.clamp(d,0,1);0===c?this.r=this.g=this.b=d:(c=.5>=d?d*(1+c):d+c-d*c,d=2*d-c,this.r=a(d,c,b+1/3),this.g=a(d,c,b),this.b=a(d,c,b-1/3));return this}}(),setStyle:function(a){function b(b){void 0!==b&&1>parseFloat(b)&&console.warn("THREE.Color: Alpha component of "+a+" will be ignored.")}var c;if(c=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)){var d=c[2];switch(c[1]){case "rgb":case "rgba":if(c=
/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(255,parseInt(c[1],10))/255,this.g=Math.min(255,parseInt(c[2],10))/255,this.b=Math.min(255,parseInt(c[3],10))/255,b(c[5]),this;if(c=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d))return this.r=Math.min(100,parseInt(c[1],10))/100,this.g=Math.min(100,parseInt(c[2],10))/100,this.b=Math.min(100,parseInt(c[3],10))/100,b(c[5]),this;break;case "hsl":case "hsla":if(c=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)){var d=
parseFloat(c[1])/360,e=parseInt(c[2],10)/100,f=parseInt(c[3],10)/100;b(c[5]);return this.setHSL(d,e,f)}}}else if(c=/^\#([A-Fa-f0-9]+)$/.exec(a)){c=c[1];d=c.length;if(3===d)return this.r=parseInt(c.charAt(0)+c.charAt(0),16)/255,this.g=parseInt(c.charAt(1)+c.charAt(1),16)/255,this.b=parseInt(c.charAt(2)+c.charAt(2),16)/255,this;if(6===d)return this.r=parseInt(c.charAt(0)+c.charAt(1),16)/255,this.g=parseInt(c.charAt(2)+c.charAt(3),16)/255,this.b=parseInt(c.charAt(4)+c.charAt(5),16)/255,this}a&&0<a.length&&
(c=THREE.ColorKeywords[a],void 0!==c?this.setHex(c):console.warn("THREE.Color: Unknown color "+a));return this},clone:function(){return new this.constructor(this.r,this.g,this.b)},copy:function(a){this.r=a.r;this.g=a.g;this.b=a.b;return this},copyGammaToLinear:function(a,b){void 0===b&&(b=2);this.r=Math.pow(a.r,b);this.g=Math.pow(a.g,b);this.b=Math.pow(a.b,b);return this},copyLinearToGamma:function(a,b){void 0===b&&(b=2);var c=0<b?1/b:1;this.r=Math.pow(a.r,c);this.g=Math.pow(a.g,c);this.b=Math.pow(a.b,
c);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){a=a||{h:0,s:0,l:0};var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=
(f+e)/2;if(f===e)f=g=0;else{var k=e-f,f=.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(a,b,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=
a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a,b){void 0===b&&(b=0);this.r=a[b];this.g=a[b+1];this.b=a[b+2];return this},toArray:function(a,
b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.r;a[b+1]=this.g;a[b+2]=this.b;return a}};
THREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,
darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,
grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,
lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,
palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,
tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};
THREE.Quaternion.prototype={constructor:THREE.Quaternion,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get w(){return this._w},set w(a){this._w=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,this._y,this._z,this._w)},
copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2),k=a.order;"XYZ"===k?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"YXZ"===
k?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):"ZXY"===k?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"ZYX"===k?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):"YZX"===k?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):"XZY"===k&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e+f*g*h);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,
b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6],b=b[10],l=c+f+b;0<l?(c=.5/Math.sqrt(l+1),this._w=.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=
.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;return this.normalize()}}(),inverse:function(){return this.conjugate().normalize()},conjugate:function(){this._x*=
-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},
multiply:function(a,b){return void 0!==b?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},premultiply:function(a){return this.multiplyQuaternions(a,this)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=a._w,g=b._x,h=b._y,k=b._z,l=b._w;this._x=c*l+f*g+d*k-e*h;this._y=d*l+f*h+e*g-c*k;this._z=e*l+f*k+c*h-d*g;this._w=f*l-c*g-d*h-e*k;this.onChangeCallback();
return this},slerp:function(a,b){if(0===b)return this;if(1===b)return this.copy(a);var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.sqrt(1-g*g);if(.001>Math.abs(h))return this._w=.5*(f+this._w),this._x=.5*(c+this._x),this._y=.5*(d+this._y),this._z=.5*(e+this._z),this;var k=Math.atan2(h,g),g=Math.sin((1-b)*k)/h,h=Math.sin(b*
k)/h;this._w=f*g+this._w*h;this._x=c*g+this._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this.onChangeCallback();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a,b){void 0===b&&(b=0);this._x=a[b];this._y=a[b+1];this._z=a[b+2];this._w=a[b+3];this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;a[b+3]=this._w;return a},onChange:function(a){this.onChangeCallback=
a;return this},onChangeCallback:function(){}};
Object.assign(THREE.Quaternion,{slerp:function(a,b,c,d){return c.copy(a).slerp(b,d)},slerpFlat:function(a,b,c,d,e,f,g){var h=c[d+0],k=c[d+1],l=c[d+2];c=c[d+3];d=e[f+0];var n=e[f+1],p=e[f+2];e=e[f+3];if(c!==e||h!==d||k!==n||l!==p){f=1-g;var m=h*d+k*n+l*p+c*e,q=0<=m?1:-1,r=1-m*m;r>Number.EPSILON&&(r=Math.sqrt(r),m=Math.atan2(r,m*q),f=Math.sin(f*m)/r,g=Math.sin(g*m)/r);q*=g;h=h*f+d*q;k=k*f+n*q;l=l*f+p*q;c=c*f+e*q;f===1-g&&(g=1/Math.sqrt(h*h+k*k+l*l+c*c),h*=g,k*=g,l*=g,c*=g)}a[b]=h;a[b+1]=k;a[b+2]=l;
a[b+3]=c}});THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};
THREE.Vector2.prototype={constructor:THREE.Vector2,get width(){return this.x},set width(a){this.x=a},get height(){return this.y},set height(a){this.y=a},set:function(a,b){this.x=a;this.y=b;return this},setScalar:function(a){this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y)},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},
addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},subScalar:function(a){this.x-=a;this.y-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){isFinite(a)?(this.x*=a,
this.y*=a):this.y=this.x=0;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));return this},clampScalar:function(){var a,b;return function(c,d){void 0===
a&&(a=new THREE.Vector2,b=new THREE.Vector2);a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.multiplyScalar(Math.max(a,Math.min(b,c))/c)},floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);
this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)},normalize:function(){return this.divideScalar(this.length())},angle:function(){var a=Math.atan2(this.y,this.x);0>a&&(a+=2*Math.PI);return a},
distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x;a=this.y-a.y;return b*b+a*a},setLength:function(a){return this.multiplyScalar(a/this.length())},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];return this},
toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;return a},fromAttribute:function(a,b,c){void 0===c&&(c=0);b=b*a.itemSize+c;this.x=a.array[b];this.y=a.array[b+1];return this},rotateAround:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=this.x-a.x,f=this.y-a.y;this.x=e*c-f*d+a.x;this.y=e*d+f*c+a.y;return this}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};
THREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setScalar:function(a){this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;
case 2:return this.z;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,
b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},
multiply:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){isFinite(a)?(this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a;return function(b){!1===b instanceof THREE.Euler&&
console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");void 0===a&&(a=new THREE.Quaternion);return this.applyQuaternion(a.setFromEuler(b))}}(),applyAxisAngle:function(){var a;return function(b,c){void 0===a&&(a=new THREE.Quaternion);return this.applyQuaternion(a.setFromAxisAngle(b,c))}}(),applyMatrix3:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},
applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=
a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,l=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-l*-f;this.y=k*a+b*-f+l*-e-h*-g;this.z=l*a+b*-g+h*-f-k*-e;return this},project:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.multiplyMatrices(b.projectionMatrix,a.getInverse(b.matrixWorld));return this.applyProjection(a)}}(),unproject:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.multiplyMatrices(b.matrixWorld,a.getInverse(b.projectionMatrix));return this.applyProjection(a)}}(),
transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;return this.normalize()},divide:function(a){this.x/=a.x;this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=
Math.max(this.z,a.z);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3,b=new THREE.Vector3);a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),clampLength:function(a,b){var c=this.length();return this.multiplyScalar(Math.max(a,Math.min(b,c))/c)},floor:function(){this.x=Math.floor(this.x);this.y=
Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=-this.x;this.y=
-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){return this.multiplyScalar(a/this.length())},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=
(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},cross:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;
this.z=c*g-d*f;return this},projectOnVector:function(){var a,b;return function(c){void 0===a&&(a=new THREE.Vector3);a.copy(c).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/
Math.sqrt(this.lengthSq()*a.lengthSq());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},setFromSpherical:function(a){var b=Math.sin(a.phi)*a.radius;this.x=b*Math.sin(a.theta);this.y=Math.cos(a.phi)*a.radius;this.z=b*Math.cos(a.theta);return this},setFromMatrixPosition:function(a){return this.setFromMatrixColumn(a,3)},setFromMatrixScale:function(a){var b=
this.setFromMatrixColumn(a,0).length(),c=this.setFromMatrixColumn(a,1).length();a=this.setFromMatrixColumn(a,2).length();this.x=b;this.y=c;this.z=a;return this},setFromMatrixColumn:function(a,b){if("number"===typeof a){console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");var c=a;a=b;b=c}return this.fromArray(a.elements,4*b)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+
2];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;return a},fromAttribute:function(a,b,c){void 0===c&&(c=0);b=b*a.itemSize+c;this.x=a.array[b];this.y=a.array[b+1];this.z=a.array[b+2];return this}};THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setScalar:function(a){this.w=this.z=this.y=this.x=a;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error("index is out of range: "+
a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},clone:function(){return new this.constructor(this.x,this.y,this.z,this.w)},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);
this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},addScaledVector:function(a,b){this.x+=a.x*b;this.y+=a.y*b;this.z+=a.z*b;this.w+=a.w*b;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=
a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subScalar:function(a){this.x-=a;this.y-=a;this.z-=a;this.w-=a;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){isFinite(a)?(this.x*=a,this.y*=a,this.z*=a,this.w*=a):this.w=this.z=this.y=this.x=0;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=
a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){return this.multiplyScalar(1/a)},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},setAxisAngleFromRotationMatrix:function(a){var b,c,d;a=a.elements;var e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],k=a[9];c=a[2];b=a[6];var l=a[10];if(.01>Math.abs(d-g)&&.01>Math.abs(f-c)&&.01>
Math.abs(k-b)){if(.1>Math.abs(d+g)&&.1>Math.abs(f+c)&&.1>Math.abs(k+b)&&.1>Math.abs(e+h+l-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;l=(l+1)/2;d=(d+g)/4;f=(f+c)/4;k=(k+b)/4;e>h&&e>l?.01>e?(b=0,d=c=.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>l?.01>h?(b=.707106781,c=0,d=.707106781):(c=Math.sqrt(h),b=d/c,d=k/c):.01>l?(c=b=.707106781,d=0):(d=Math.sqrt(l),b=f/d,c=k/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-k)*(b-k)+(f-c)*(f-c)+(g-d)*(g-d));.001>Math.abs(a)&&(a=1);this.x=(b-k)/
a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+l-1)/2);return this},min:function(a){this.x=Math.min(this.x,a.x);this.y=Math.min(this.y,a.y);this.z=Math.min(this.z,a.z);this.w=Math.min(this.w,a.w);return this},max:function(a){this.x=Math.max(this.x,a.x);this.y=Math.max(this.y,a.y);this.z=Math.max(this.z,a.z);this.w=Math.max(this.w,a.w);return this},clamp:function(a,b){this.x=Math.max(a.x,Math.min(b.x,this.x));this.y=Math.max(a.y,Math.min(b.y,this.y));this.z=Math.max(a.z,Math.min(b.z,this.z));
this.w=Math.max(a.w,Math.min(b.w,this.w));return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector4,b=new THREE.Vector4);a.set(c,c,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this},round:function(){this.x=
Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*
a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){return this.multiplyScalar(a/this.length())},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-
this.z)*b;this.w+=(a.w-this.w)*b;return this},lerpVectors:function(a,b,c){return this.subVectors(b,a).multiplyScalar(c).add(a)},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a,b){void 0===b&&(b=0);this.x=a[b];this.y=a[b+1];this.z=a[b+2];this.w=a[b+3];return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this.x;a[b+1]=this.y;a[b+2]=this.z;a[b+3]=this.w;return a},fromAttribute:function(a,b,c){void 0===c&&(c=0);b=b*a.itemSize+
c;this.x=a.array[b];this.y=a.array[b+1];this.z=a.array[b+2];this.w=a.array[b+3];return this}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");THREE.Euler.DefaultOrder="XYZ";
THREE.Euler.prototype={constructor:THREE.Euler,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get order(){return this._order},set order(a){this._order=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this.onChangeCallback();return this},clone:function(){return new this.constructor(this._x,
this._y,this._z,this._order)},copy:function(a){this._x=a._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b,c){var d=THREE.Math.clamp,e=a.elements;a=e[0];var f=e[4],g=e[8],h=e[1],k=e[5],l=e[9],n=e[2],p=e[6],e=e[10];b=b||this._order;"XYZ"===b?(this._y=Math.asin(d(g,-1,1)),.99999>Math.abs(g)?(this._x=Math.atan2(-l,e),this._z=Math.atan2(-f,a)):(this._x=Math.atan2(p,k),this._z=0)):"YXZ"===b?(this._x=Math.asin(-d(l,-1,1)),.99999>Math.abs(l)?
(this._y=Math.atan2(g,e),this._z=Math.atan2(h,k)):(this._y=Math.atan2(-n,a),this._z=0)):"ZXY"===b?(this._x=Math.asin(d(p,-1,1)),.99999>Math.abs(p)?(this._y=Math.atan2(-n,e),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,a))):"ZYX"===b?(this._y=Math.asin(-d(n,-1,1)),.99999>Math.abs(n)?(this._x=Math.atan2(p,e),this._z=Math.atan2(h,a)):(this._x=0,this._z=Math.atan2(-f,k))):"YZX"===b?(this._z=Math.asin(d(h,-1,1)),.99999>Math.abs(h)?(this._x=Math.atan2(-l,k),this._y=Math.atan2(-n,a)):(this._x=
0,this._y=Math.atan2(g,e))):"XZY"===b?(this._z=Math.asin(-d(f,-1,1)),.99999>Math.abs(f)?(this._x=Math.atan2(p,k),this._y=Math.atan2(g,a)):(this._x=Math.atan2(-l,e),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+b);this._order=b;if(!1!==c)this.onChangeCallback();return this},setFromQuaternion:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Matrix4);a.makeRotationFromQuaternion(b);return this.setFromRotationMatrix(a,c,d)}}(),setFromVector3:function(a,
b){return this.set(a.x,a.y,a.z,b||this._order)},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);return this.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(a,b){void 0===a&&(a=[]);void 0===b&&(b=0);a[b]=this._x;a[b+1]=this._y;a[b+2]=this._z;
a[b+3]=this._order;return a},toVector3:function(a){return a?a.set(this._x,this._y,this._z):new THREE.Vector3(this._x,this._y,this._z)},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){}};THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};
THREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},
at:function(a,b){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);
this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};
THREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);
return this},makeEmpty:function(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);
this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>
this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&
a.max.equals(this.max)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};
THREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromArray:function(a){for(var b=Infinity,c=Infinity,d=Infinity,e=-Infinity,f=-Infinity,g=-Infinity,h=0,k=a.length;h<k;h+=3){var l=a[h],n=a[h+1],p=a[h+2];l<b&&(b=l);n<c&&(c=n);p<d&&(d=p);l>e&&(e=l);n>f&&(f=n);p>g&&(g=p)}this.min.set(b,c,d);this.max.set(e,f,g)},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=
new THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);this.makeEmpty();b.traverse(function(b){var e=b.geometry;if(void 0!==e)if(e instanceof THREE.Geometry)for(var f=e.vertices,e=0,g=f.length;e<g;e++)a.copy(f[e]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a);else if(e instanceof THREE.BufferGeometry&&void 0!==
e.attributes.position)for(f=e.attributes.position.array,e=0,g=f.length;e<g;e+=3)a.fromArray(f,e),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},isEmpty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},
center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||a.z<
this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},intersectsBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||a.max.z<
this.min.z||a.min.z>this.max.z?!1:!0},intersectsSphere:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);this.clampPoint(b.center,a);return a.distanceToSquared(b.center)<=b.radius*b.radius}}(),intersectsPlane:function(a){var b,c;0<a.normal.x?(b=a.normal.x*this.min.x,c=a.normal.x*this.max.x):(b=a.normal.x*this.max.x,c=a.normal.x*this.min.x);0<a.normal.y?(b+=a.normal.y*this.min.y,c+=a.normal.y*this.max.y):(b+=a.normal.y*this.max.y,c+=a.normal.y*this.min.y);0<a.normal.z?(b+=a.normal.z*
this.min.z,c+=a.normal.z*this.max.z):(b+=a.normal.z*this.max.z,c+=a.normal.z*this.min.z);return b<=a.constant&&c>=a.constant},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=new THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=.5*this.size(a).length();return b}}(),
intersect:function(a){this.min.max(a.min);this.max.min(a.max);this.isEmpty()&&this.makeEmpty();return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){if(this.isEmpty())return this;a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);
a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&
a.max.equals(this.max)}};THREE.Matrix3=function(){this.elements=new Float32Array([1,0,0,0,1,0,0,0,1]);0<arguments.length&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")};
THREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,k){var l=this.elements;l[0]=a;l[1]=d;l[2]=g;l[3]=b;l[4]=e;l[5]=h;l[6]=c;l[7]=f;l[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},clone:function(){return(new this.constructor).fromArray(this.elements)},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},setFromMatrix4:function(a){a=a.elements;this.set(a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]);
return this},applyToVector3Array:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Vector3);void 0===c&&(c=0);void 0===d&&(d=b.length);for(var e=0;e<d;e+=3,c+=3)a.fromArray(b,c),a.applyMatrix3(this),a.toArray(b,c);return b}}(),applyToBuffer:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Vector3);void 0===c&&(c=0);void 0===d&&(d=b.length/b.itemSize);for(var e=0;e<d;e++,c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix3(this),b.setXYZ(a.x,a.y,a.z);return b}}(),
multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){a instanceof THREE.Matrix4&&console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");var c=a.elements,d=this.elements,e=c[0],f=c[1],g=c[2],h=c[3],k=c[4],l=c[5],n=c[6],p=c[7],
c=c[8],m=c*k-l*p,q=l*n-c*h,r=p*h-k*n,s=e*m+f*q+g*r;if(0===s){if(b)throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");return this.identity()}s=1/s;d[0]=m*s;d[1]=(g*p-c*f)*s;d[2]=(l*f-g*k)*s;d[3]=q*s;d[4]=(c*e-g*n)*s;d[5]=(g*h-l*e)*s;d[6]=r*s;d[7]=(f*n-p*e)*s;d[8]=(k*e-f*h)*s;return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=
b[7];b[7]=a;return this},flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");return this.toArray(a,b)},getNormalMatrix:function(a){return this.setFromMatrix4(a).getInverse(this).transpose()},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(a,b){void 0===
a&&(a=[]);void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a}};THREE.Matrix4=function(){this.elements=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);0<arguments.length&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")};
THREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,k,l,n,p,m,q,r,s){var u=this.elements;u[0]=a;u[4]=b;u[8]=c;u[12]=d;u[1]=e;u[5]=f;u[9]=g;u[13]=h;u[2]=k;u[6]=l;u[10]=n;u[14]=p;u[3]=m;u[7]=q;u[11]=r;u[15]=s;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},clone:function(){return(new THREE.Matrix4).fromArray(this.elements)},copy:function(a){this.elements.set(a.elements);return this},copyPosition:function(a){var b=this.elements;a=a.elements;
b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractBasis:function(a,b,c){a.setFromMatrixColumn(this,0);b.setFromMatrixColumn(this,1);c.setFromMatrixColumn(this,2);return this},makeBasis:function(a,b,c){this.set(a.x,b.x,c.x,0,a.y,b.y,c.y,0,a.z,b.z,c.z,0,0,0,0,1);return this},extractRotation:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);var c=this.elements,d=b.elements,e=1/a.setFromMatrixColumn(b,0).length(),f=1/a.setFromMatrixColumn(b,1).length();b=1/a.setFromMatrixColumn(b,
2).length();c[0]=d[0]*e;c[1]=d[1]*e;c[2]=d[2]*e;c[4]=d[4]*f;c[5]=d[5]*f;c[6]=d[6]*f;c[8]=d[8]*b;c[9]=d[9]*b;c[10]=d[10]*b;return this}}(),makeRotationFromEuler:function(a){!1===a instanceof THREE.Euler&&console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if("XYZ"===a.order){a=f*h;var k=f*e,l=c*h,n=c*e;b[0]=g*h;b[4]=
-g*e;b[8]=d;b[1]=k+l*d;b[5]=a-n*d;b[9]=-c*g;b[2]=n-a*d;b[6]=l+k*d;b[10]=f*g}else"YXZ"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a+n*c,b[4]=l*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-l,b[6]=n+a*c,b[10]=f*g):"ZXY"===a.order?(a=g*h,k=g*e,l=d*h,n=d*e,b[0]=a-n*c,b[4]=-f*e,b[8]=l+k*c,b[1]=k+l*c,b[5]=f*h,b[9]=n-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):"ZYX"===a.order?(a=f*h,k=f*e,l=c*h,n=c*e,b[0]=g*h,b[4]=l*d-k,b[8]=a*d+n,b[1]=g*e,b[5]=n*d+a,b[9]=k*d-l,b[2]=-d,b[6]=c*g,b[10]=f*g):"YZX"===a.order?(a=f*g,k=f*
d,l=c*g,n=c*d,b[0]=g*h,b[4]=n-a*e,b[8]=l*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+l,b[10]=a-n*e):"XZY"===a.order&&(a=f*g,k=f*d,l=c*g,n=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+n,b[5]=f*h,b[9]=k*e-l,b[2]=l*e-k,b[6]=c*h,b[10]=n*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,k=e+e;a=c*g;var l=c*h,c=c*k,n=d*h,d=d*k,e=e*k,g=f*g,h=f*h,f=f*k;b[0]=1-(n+e);b[4]=l-f;b[8]=c+h;b[1]=l+
f;b[5]=1-(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+n);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a,b,c;return function(d,e,f){void 0===a&&(a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3);var g=this.elements;c.subVectors(d,e).normalize();0===c.lengthSq()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.lengthSq()&&(c.z+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;
g[6]=b.z;g[10]=c.z;return this}}(),multiply:function(a,b){return void 0!==b?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},premultiply:function(a){return this.multiplyMatrices(a,this)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],k=c[12],l=c[1],n=c[5],p=c[9],m=c[13],q=c[2],r=c[6],s=c[10],u=c[14],x=c[3],v=c[7],C=c[11],c=c[15],
w=d[0],D=d[4],A=d[8],y=d[12],B=d[1],G=d[5],z=d[9],H=d[13],M=d[2],O=d[6],N=d[10],E=d[14],K=d[3],I=d[7],L=d[11],d=d[15];e[0]=f*w+g*B+h*M+k*K;e[4]=f*D+g*G+h*O+k*I;e[8]=f*A+g*z+h*N+k*L;e[12]=f*y+g*H+h*E+k*d;e[1]=l*w+n*B+p*M+m*K;e[5]=l*D+n*G+p*O+m*I;e[9]=l*A+n*z+p*N+m*L;e[13]=l*y+n*H+p*E+m*d;e[2]=q*w+r*B+s*M+u*K;e[6]=q*D+r*G+s*O+u*I;e[10]=q*A+r*z+s*N+u*L;e[14]=q*y+r*H+s*E+u*d;e[3]=x*w+v*B+C*M+c*K;e[7]=x*D+v*G+C*O+c*I;e[11]=x*A+v*z+C*N+c*L;e[15]=x*y+v*H+C*E+c*d;return this},multiplyToArray:function(a,b,
c){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},applyToVector3Array:function(){var a;return function(b,c,d){void 0===a&&
(a=new THREE.Vector3);void 0===c&&(c=0);void 0===d&&(d=b.length);for(var e=0;e<d;e+=3,c+=3)a.fromArray(b,c),a.applyMatrix4(this),a.toArray(b,c);return b}}(),applyToBuffer:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Vector3);void 0===c&&(c=0);void 0===d&&(d=b.length/b.itemSize);for(var e=0;e<d;e++,c++)a.x=b.getX(c),a.y=b.getY(c),a.z=b.getZ(c),a.applyMatrix4(this),b.setXYZ(a.x,a.y,a.z);return b}}(),determinant:function(){var a=this.elements,b=a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=
a[5],h=a[9],k=a[13],l=a[2],n=a[6],p=a[10],m=a[14];return a[3]*(+e*h*n-d*k*n-e*g*p+c*k*p+d*g*m-c*h*m)+a[7]*(+b*h*m-b*k*p+e*f*p-d*f*m+d*k*l-e*h*l)+a[11]*(+b*k*n-b*g*m-e*f*n+c*f*m+e*g*l-c*k*l)+a[15]*(-d*g*l-b*h*n+b*g*p+d*f*n-c*f*p+c*h*l)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArrayOffset:function(a,b){console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");
return this.toArray(a,b)},getPosition:function(){var a;return function(){void 0===a&&(a=new THREE.Vector3);console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");return a.setFromMatrixColumn(this,3)}}(),setPosition:function(a){var b=this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[1],g=d[2],h=d[3],k=d[4],l=d[5],n=d[6],p=d[7],m=d[8],q=d[9],r=d[10],s=d[11],u=d[12],
x=d[13],v=d[14],d=d[15],C=q*v*p-x*r*p+x*n*s-l*v*s-q*n*d+l*r*d,w=u*r*p-m*v*p-u*n*s+k*v*s+m*n*d-k*r*d,D=m*x*p-u*q*p+u*l*s-k*x*s-m*l*d+k*q*d,A=u*q*n-m*x*n-u*l*r+k*x*r+m*l*v-k*q*v,y=e*C+f*w+g*D+h*A;if(0===y){if(b)throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");return this.identity()}y=1/y;c[0]=C*y;c[1]=(x*r*h-q*v*h-x*g*s+f*v*s+q*g*d-f*r*d)*y;c[2]=(l*v*h-x*n*h+x*g*p-f*v*p-l*g*d+f*n*d)*y;c[3]=
(q*n*h-l*r*h-q*g*p+f*r*p+l*g*s-f*n*s)*y;c[4]=w*y;c[5]=(m*v*h-u*r*h+u*g*s-e*v*s-m*g*d+e*r*d)*y;c[6]=(u*n*h-k*v*h-u*g*p+e*v*p+k*g*d-e*n*d)*y;c[7]=(k*r*h-m*n*h+m*g*p-e*r*p-k*g*s+e*n*s)*y;c[8]=D*y;c[9]=(u*q*h-m*x*h-u*f*s+e*x*s+m*f*d-e*q*d)*y;c[10]=(k*x*h-u*l*h+u*f*p-e*x*p-k*f*d+e*l*d)*y;c[11]=(m*l*h-k*q*h-m*f*p+e*q*p+k*f*s-e*l*s)*y;c[12]=A*y;c[13]=(m*x*g-u*q*g+u*f*r-e*x*r-m*f*v+e*q*v)*y;c[14]=(u*l*g-k*x*g-u*f*n+e*x*n+k*f*v-e*l*v)*y;c[15]=(k*q*g-m*l*g+m*f*n-e*q*n-k*f*r+e*l*r)*y;return this},scale:function(a){var b=
this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10]))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(1,0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);
return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,k=e*f,l=e*g;this.set(k*f+c,k*g-d*h,k*h+d*g,0,k*g+d*h,l*g+c,l*h-d*f,0,k*h-d*g,l*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,0,0,0,0,b,0,0,0,0,c,
0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a,b;return function(c,d,e){void 0===a&&(a=new THREE.Vector3,b=new THREE.Matrix4);var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);c=1/g;var f=1/h,l=1/k;b.elements[0]*=c;b.elements[1]*=c;
b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=l;b.elements[9]*=l;b.elements[10]*=l;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){a=c*Math.tan(THREE.Math.DEG2RAD*a*.5);var e=
-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=1/(b-a),k=1/(c-d),l=1/(f-e);g[0]=2*h;g[4]=0;g[8]=0;g[12]=-((b+a)*h);g[1]=0;g[5]=2*k;g[9]=0;g[13]=-((c+d)*k);g[2]=0;g[6]=0;g[10]=-2*l;g[14]=-((f+e)*l);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},equals:function(a){var b=this.elements;a=a.elements;for(var c=0;16>c;c++)if(b[c]!==a[c])return!1;return!0},fromArray:function(a){this.elements.set(a);return this},toArray:function(a,b){void 0===a&&(a=[]);
void 0===b&&(b=0);var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};
THREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},lookAt:function(a){this.direction.copy(a).sub(this.origin).normalize();return this},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,
a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);var d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(a){return Math.sqrt(this.distanceSqToPoint(a))},distanceSqToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceToSquared(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);
return a.distanceToSquared(b)}}(),distanceSqToSegment:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g){a.copy(d).add(e).multiplyScalar(.5);b.copy(e).sub(d).normalize();c.copy(this.origin).sub(a);var h=.5*d.distanceTo(e),k=-this.direction.dot(b),l=c.dot(this.direction),n=-c.dot(b),p=c.lengthSq(),m=Math.abs(1-k*k),q;0<m?(d=k*n-l,e=k*l-n,q=h*m,0<=d?e>=-q?e<=q?(h=1/m,d*=h,e*=h,k=d*(d+k*e+2*l)+e*(k*d+e+2*n)+p):(e=h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*
n)+p):(e=-h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*n)+p):e<=-q?(d=Math.max(0,-(-k*h+l)),e=0<d?-h:Math.min(Math.max(-h,-n),h),k=-d*d+e*(e+2*n)+p):e<=q?(d=0,e=Math.min(Math.max(-h,-n),h),k=e*(e+2*n)+p):(d=Math.max(0,-(k*h+l)),e=0<d?h:Math.min(Math.max(-h,-n),h),k=-d*d+e*(e+2*n)+p)):(e=0<k?-h:h,d=Math.max(0,-(k*e+l)),k=-d*d+e*(e+2*n)+p);f&&f.copy(this.direction).multiplyScalar(d).add(this.origin);g&&g.copy(b).multiplyScalar(e).add(a);return k}}(),intersectSphere:function(){var a=new THREE.Vector3;return function(b,
c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d,f=b.radius*b.radius;if(e>f)return null;f=Math.sqrt(f-e);e=d-f;d+=f;return 0>e&&0>d?null:0>e?this.at(d,c):this.at(e,c)}}(),intersectsSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0===b)return 0===a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=
this.distanceToPlane(a);return null===c?null:this.at(c,b)},intersectsPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=a.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==
d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==c)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectsBox:function(){var a=new THREE.Vector3;return function(b){return null!==this.intersectBox(b,a)}}(),intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);
if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)}};
THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};
THREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},
empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},intersectsBox:function(a){return a.intersectsSphere(this)},intersectsPlane:function(a){return Math.abs(this.center.dot(a.normal)-a.constant)<=this.radius},clampPoint:function(a,b){var c=
this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);return a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&
a.radius===this.radius}};THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};
THREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],l=c[7],n=c[8],p=c[9],m=c[10],q=c[11],r=c[12],s=c[13],u=c[14],
c=c[15];b[0].setComponents(f-a,l-g,q-n,c-r).normalize();b[1].setComponents(f+a,l+g,q+n,c+r).normalize();b[2].setComponents(f+d,l+h,q+p,c+s).normalize();b[3].setComponents(f-d,l-h,q-p,c-s).normalize();b[4].setComponents(f-e,l-k,q-m,c-u).normalize();b[5].setComponents(f+e,l+k,q+m,c+u).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),
intersectsSprite:function(){var a=new THREE.Sphere;return function(b){a.center.set(0,0,0);a.radius=.7071067811865476;a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?
c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};
THREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,
c);return this}}(),clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,
b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,b){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0===f){if(0===this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),intersectsLine:function(a){var b=
this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectsBox:function(a){return a.intersectsPlane(this)},intersectsSphere:function(a){return a.intersectsPlane(this)},coplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Matrix3;return function(c,d){var e=this.coplanarPoint(a).applyMatrix4(c),f=d||b.getNormalMatrix(c),f=this.normal.applyMatrix3(f).normalize();
this.constant=-e.dot(f);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&a.constant===this.constant}};THREE.Spherical=function(a,b,c){this.radius=void 0!==a?a:1;this.phi=void 0!==b?b:0;this.theta=void 0!==c?c:0;return this};
THREE.Spherical.prototype={constructor:THREE.Spherical,set:function(a,b,c){this.radius=a;this.phi=b;this.theta=c;return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.radius.copy(a.radius);this.phi.copy(a.phi);this.theta.copy(a.theta);return this},makeSafe:function(){this.phi=Math.max(1E-6,Math.min(Math.PI-1E-6,this.phi));return this},setFromVector3:function(a){this.radius=a.length();0===this.radius?this.phi=this.theta=0:(this.theta=Math.atan2(a.x,a.z),this.phi=
Math.acos(THREE.Math.clamp(a.y/this.radius,-1,1)));return this}};
THREE.Math={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){var a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8===e||13===e||18===e||23===e?b[e]="-":14===e?b[e]="4":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19===e?d&3|8:d]);return b.join("")}}(),clamp:function(a,b,c){return Math.max(b,Math.min(c,a))},euclideanModulo:function(a,b){return(a%b+b)%b},mapLinear:function(a,b,c,
d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");return Math.random()},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*
(.5-Math.random())},degToRad:function(a){return a*THREE.Math.DEG2RAD},radToDeg:function(a){return a*THREE.Math.RAD2DEG},isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a},nearestPowerOfTwo:function(a){return Math.pow(2,Math.round(Math.log(a)/Math.LN2))},nextPowerOfTwo:function(a){a--;a|=a>>1;a|=a>>2;a|=a>>4;a|=a>>8;a|=a>>16;a++;return a}};
THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=.5*(c-a);d=.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,k,l,n,p,m;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:f+
2;l=this.points[c[0]];n=this.points[c[1]];p=this.points[c[2]];m=this.points[c[3]];h=g*g;k=g*h;d.x=b(l.x,n.x,p.x,m.x,g,h,k);d.y=b(l.y,n.y,p.y,m.y,g,h,k);d.z=b(l.z,n.z,p.z,m.z,g,h,k);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],k=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=
a/c,d=this.getPoint(b),g.copy(d),k+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!==e&&(h[b]=k,e=b);h[h.length]=k;return{chunks:h,total:k}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],k=new THREE.Vector3,m=this.getLength();h.push(k.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=m.chunks[b]-m.chunks[b-1];g=Math.ceil(a*c/m.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+1/g*c*(f-e),d=this.getPoint(d),
h.push(k.copy(d).clone());h.push(k.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();
THREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var l=d*k-e*e;h=h||new THREE.Vector3;if(0===l)return h.set(-2,-1,-1);l=1/l;k=(k*f-e*g)*l;d=(d*g-e*f)*l;return h.set(1-k-d,d,k)}}();
THREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();
THREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,
this.b);return.5*a.cross(b).length()}}(),midpoint:function(a){return(a||new THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},
closestPointToPoint:function(){var a,b,c,d;return function(e,f){void 0===a&&(a=new THREE.Plane,b=[new THREE.Line3,new THREE.Line3,new THREE.Line3],c=new THREE.Vector3,d=new THREE.Vector3);var g=f||new THREE.Vector3,h=Infinity;a.setFromCoplanarPoints(this.a,this.b,this.c);a.projectPoint(e,c);if(!0===this.containsPoint(c))g.copy(c);else{b[0].set(this.a,this.b);b[1].set(this.b,this.c);b[2].set(this.c,this.a);for(var k=0;k<b.length;k++){b[k].closestPointToPoint(c,!0,d);var l=c.distanceToSquared(d);l<
h&&(h=l,g.copy(d))}}return g}}(),equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)}};THREE.Interpolant=function(a,b,c,d){this.parameterPositions=a;this._cachedIndex=0;this.resultBuffer=void 0!==d?d:new b.constructor(c);this.sampleValues=b;this.valueSize=c};
THREE.Interpolant.prototype={constructor:THREE.Interpolant,evaluate:function(a){var b=this.parameterPositions,c=this._cachedIndex,d=b[c],e=b[c-1];a:{b:{c:{d:if(!(a<d)){for(var f=c+2;;){if(void 0===d){if(a<e)break d;this._cachedIndex=c=b.length;return this.afterEnd_(c-1,a,e)}if(c===f)break;e=d;d=b[++c];if(a<d)break b}d=b.length;break c}if(a>=e)break a;else{f=b[1];a<f&&(c=2,e=f);for(f=c-2;;){if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(c===f)break;d=e;e=b[--c-1];if(a>=e)break b}d=
c;c=0}}for(;c<d;)e=c+d>>>1,a<b[e]?d=e:c=e+1;d=b[c];e=b[c-1];if(void 0===e)return this._cachedIndex=0,this.beforeStart_(0,a,d);if(void 0===d)return this._cachedIndex=c=b.length,this.afterEnd_(c-1,e,a)}this._cachedIndex=c;this.intervalChanged_(c,e,d)}return this.interpolate_(c,e,a,d)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(a){var b=this.resultBuffer,c=this.sampleValues,d=this.valueSize;a*=d;for(var e=0;e!==d;++e)b[e]=
c[a+e];return b},interpolate_:function(a,b,c,d){throw Error("call to abstract method");},intervalChanged_:function(a,b,c){}};Object.assign(THREE.Interpolant.prototype,{beforeStart_:THREE.Interpolant.prototype.copySampleValue_,afterEnd_:THREE.Interpolant.prototype.copySampleValue_});THREE.CubicInterpolant=function(a,b,c,d){THREE.Interpolant.call(this,a,b,c,d);this._offsetNext=this._weightNext=this._offsetPrev=this._weightPrev=-0};
THREE.CubicInterpolant.prototype=Object.assign(Object.create(THREE.Interpolant.prototype),{constructor:THREE.CubicInterpolant,DefaultSettings_:{endingStart:THREE.ZeroCurvatureEnding,endingEnd:THREE.ZeroCurvatureEnding},intervalChanged_:function(a,b,c){var d=this.parameterPositions,e=a-2,f=a+1,g=d[e],h=d[f];if(void 0===g)switch(this.getSettings_().endingStart){case THREE.ZeroSlopeEnding:e=a;g=2*b-c;break;case THREE.WrapAroundEnding:e=d.length-2;g=b+d[e]-d[e+1];break;default:e=a,g=c}if(void 0===h)switch(this.getSettings_().endingEnd){case THREE.ZeroSlopeEnding:f=
a;h=2*c-b;break;case THREE.WrapAroundEnding:f=1;h=c+d[1]-d[0];break;default:f=a-1,h=b}a=.5*(c-b);d=this.valueSize;this._weightPrev=a/(b-g);this._weightNext=a/(h-c);this._offsetPrev=e*d;this._offsetNext=f*d},interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g,k=this._offsetPrev,l=this._offsetNext,n=this._weightPrev,p=this._weightNext,m=(c-b)/(d-b);c=m*m;d=c*m;b=-n*d+2*n*c-n*m;n=(1+n)*d+(-1.5-2*n)*c+(-.5+n)*m+1;m=(-1-p)*d+(1.5+p)*c+.5*m;p=p*d-p*
c;for(c=0;c!==g;++c)e[c]=b*f[k+c]+n*f[h+c]+m*f[a+c]+p*f[l+c];return e}});THREE.DiscreteInterpolant=function(a,b,c,d){THREE.Interpolant.call(this,a,b,c,d)};THREE.DiscreteInterpolant.prototype=Object.assign(Object.create(THREE.Interpolant.prototype),{constructor:THREE.DiscreteInterpolant,interpolate_:function(a,b,c,d){return this.copySampleValue_(a-1)}});THREE.LinearInterpolant=function(a,b,c,d){THREE.Interpolant.call(this,a,b,c,d)};
THREE.LinearInterpolant.prototype=Object.assign(Object.create(THREE.Interpolant.prototype),{constructor:THREE.LinearInterpolant,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;var h=a-g;b=(c-b)/(d-b);c=1-b;for(d=0;d!==g;++d)e[d]=f[h+d]*c+f[a+d]*b;return e}});THREE.QuaternionLinearInterpolant=function(a,b,c,d){THREE.Interpolant.call(this,a,b,c,d)};
THREE.QuaternionLinearInterpolant.prototype=Object.assign(Object.create(THREE.Interpolant.prototype),{constructor:THREE.QuaternionLinearInterpolant,interpolate_:function(a,b,c,d){var e=this.resultBuffer,f=this.sampleValues,g=this.valueSize;a*=g;b=(c-b)/(d-b);for(c=a+g;a!==c;a+=4)THREE.Quaternion.slerpFlat(e,0,f,a-g,f,a,b);return e}});THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};
THREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=(performance||Date).now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=(performance||Date).now(),a=(b-this.oldTime)/1E3;this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};
Object.assign(THREE.EventDispatcher.prototype,{addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(a){if(void 0!==
this._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;for(var c=[],d=0,e=b.length,d=0;d<e;d++)c[d]=b[d];for(d=0;d<e;d++)c[d].call(this,a)}}}});THREE.Layers=function(){this.mask=1};THREE.Layers.prototype={constructor:THREE.Layers,set:function(a){this.mask=1<<a},enable:function(a){this.mask|=1<<a},toggle:function(a){this.mask^=1<<a},disable:function(a){this.mask&=~(1<<a)},test:function(a){return 0!==(this.mask&a.mask)}};
(function(a){function b(a,b){return a.distance-b.distance}function c(a,b,f,g){if(!1!==a.visible&&(a.raycast(b,f),!0===g)){a=a.children;g=0;for(var h=a.length;g<h;g++)c(a[g],b,f,!0)}}a.Raycaster=function(b,c,f,g){this.ray=new a.Ray(b,c);this.near=f||0;this.far=g||Infinity;this.params={Mesh:{},Line:{},LOD:{},Points:{threshold:1},Sprite:{}};Object.defineProperties(this.params,{PointCloud:{get:function(){console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");return this.Points}}})};
a.Raycaster.prototype={constructor:a.Raycaster,linePrecision:1,set:function(a,b){this.ray.set(a,b)},setFromCamera:function(b,c){c instanceof a.PerspectiveCamera?(this.ray.origin.setFromMatrixPosition(c.matrixWorld),this.ray.direction.set(b.x,b.y,.5).unproject(c).sub(this.ray.origin).normalize()):c instanceof a.OrthographicCamera?(this.ray.origin.set(b.x,b.y,-1).unproject(c),this.ray.direction.set(0,0,-1).transformDirection(c.matrixWorld)):console.error("THREE.Raycaster: Unsupported camera type.")},
intersectObject:function(a,e){var f=[];c(a,this,f,e);f.sort(b);return f},intersectObjects:function(a,e){var f=[];if(!1===Array.isArray(a))return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),f;for(var g=0,h=a.length;g<h;g++)c(a[g],this,f,e);f.sort(b);return f}}})(THREE);
THREE.Object3D=function(){Object.defineProperty(this,"id",{value:THREE.Object3DIdCount++});this.uuid=THREE.Math.generateUUID();this.name="";this.type="Object3D";this.parent=null;this.children=[];this.up=THREE.Object3D.DefaultUp.clone();var a=new THREE.Vector3,b=new THREE.Euler,c=new THREE.Quaternion,d=new THREE.Vector3(1,1,1);b.onChange(function(){c.setFromEuler(b,!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});Object.defineProperties(this,{position:{enumerable:!0,value:a},rotation:{enumerable:!0,
value:b},quaternion:{enumerable:!0,value:c},scale:{enumerable:!0,value:d},modelViewMatrix:{value:new THREE.Matrix4},normalMatrix:{value:new THREE.Matrix3}});this.matrix=new THREE.Matrix4;this.matrixWorld=new THREE.Matrix4;this.matrixAutoUpdate=THREE.Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=!1;this.layers=new THREE.Layers;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0;this.renderOrder=0;this.userData={}};
THREE.Object3D.DefaultUp=new THREE.Vector3(0,1,0);THREE.Object3D.DefaultMatrixAutoUpdate=!0;
Object.assign(THREE.Object3D.prototype,THREE.EventDispatcher.prototype,{applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=
new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);
this.position.add(a.multiplyScalar(c));return this}}(),translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),
lookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",a),this;a instanceof THREE.Object3D?(null!==a.parent&&a.parent.remove(a),a.parent=this,a.dispatchEvent({type:"added"}),this.children.push(a)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",
a);return this},remove:function(a){if(1<arguments.length)for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);b=this.children.indexOf(a);-1!==b&&(a.parent=null,a.dispatchEvent({type:"removed"}),this.children.splice(b,1))},getObjectById:function(a){return this.getObjectByProperty("id",a)},getObjectByName:function(a){return this.getObjectByProperty("name",a)},getObjectByProperty:function(a,b){if(this[a]===b)return this;for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c].getObjectByProperty(a,
b);if(void 0!==e)return e}},getWorldPosition:function(a){a=a||new THREE.Vector3;this.updateMatrixWorld(!0);return a.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){c=c||new THREE.Quaternion;this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,c,b);return c}}(),getWorldRotation:function(){var a=new THREE.Quaternion;return function(b){b=b||new THREE.Euler;this.getWorldQuaternion(a);return b.setFromQuaternion(a,
this.rotation.order,!1)}}(),getWorldScale:function(){var a=new THREE.Vector3,b=new THREE.Quaternion;return function(c){c=c||new THREE.Vector3;this.updateMatrixWorld(!0);this.matrixWorld.decompose(a,b,c);return c}}(),getWorldDirection:function(){var a=new THREE.Quaternion;return function(b){b=b||new THREE.Vector3;this.getWorldQuaternion(a);return b.set(0,0,1).applyQuaternion(a)}}(),raycast:function(){},traverse:function(a){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverse(a)},traverseVisible:function(a){if(!1!==
this.visible){a(this);for(var b=this.children,c=0,d=b.length;c<d;c++)b[c].traverseVisible(a)}},traverseAncestors:function(a){var b=this.parent;null!==b&&(a(b),b.traverseAncestors(a))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,
this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},toJSON:function(a){function b(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var c=void 0===a||""===a,d={};c&&(a={geometries:{},materials:{},textures:{},images:{}},d.metadata={version:4.4,type:"Object",generator:"Object3D.toJSON"});var e={};e.uuid=this.uuid;e.type=this.type;""!==this.name&&(e.name=this.name);"{}"!==JSON.stringify(this.userData)&&
(e.userData=this.userData);!0===this.castShadow&&(e.castShadow=!0);!0===this.receiveShadow&&(e.receiveShadow=!0);!1===this.visible&&(e.visible=!1);e.matrix=this.matrix.toArray();void 0!==this.geometry&&(void 0===a.geometries[this.geometry.uuid]&&(a.geometries[this.geometry.uuid]=this.geometry.toJSON(a)),e.geometry=this.geometry.uuid);void 0!==this.material&&(void 0===a.materials[this.material.uuid]&&(a.materials[this.material.uuid]=this.material.toJSON(a)),e.material=this.material.uuid);if(0<this.children.length){e.children=
[];for(var f=0;f<this.children.length;f++)e.children.push(this.children[f].toJSON(a).object)}if(c){var c=b(a.geometries),f=b(a.materials),g=b(a.textures);a=b(a.images);0<c.length&&(d.geometries=c);0<f.length&&(d.materials=f);0<g.length&&(d.textures=g);0<a.length&&(d.images=a)}d.object=e;return d},clone:function(a){return(new this.constructor).copy(this,a)},copy:function(a,b){void 0===b&&(b=!0);this.name=a.name;this.up.copy(a.up);this.position.copy(a.position);this.quaternion.copy(a.quaternion);this.scale.copy(a.scale);
this.matrix.copy(a.matrix);this.matrixWorld.copy(a.matrixWorld);this.matrixAutoUpdate=a.matrixAutoUpdate;this.matrixWorldNeedsUpdate=a.matrixWorldNeedsUpdate;this.visible=a.visible;this.castShadow=a.castShadow;this.receiveShadow=a.receiveShadow;this.frustumCulled=a.frustumCulled;this.renderOrder=a.renderOrder;this.userData=JSON.parse(JSON.stringify(a.userData));if(!0===b)for(var c=0;c<a.children.length;c++)this.add(a.children[c].clone());return this}});THREE.Object3DIdCount=0;
THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=Array.isArray(d)?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=Array.isArray(e)?e:[];this.materialIndex=void 0!==f?f:0};
THREE.Face3.prototype={constructor:THREE.Face3,clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.a=a.a;this.b=a.b;this.c=a.c;this.normal.copy(a.normal);this.color.copy(a.color);this.materialIndex=a.materialIndex;for(var b=0,c=a.vertexNormals.length;b<c;b++)this.vertexNormals[b]=a.vertexNormals[b].clone();b=0;for(c=a.vertexColors.length;b<c;b++)this.vertexColors[b]=a.vertexColors[b].clone();return this}};
THREE.BufferAttribute=function(a,b,c){this.uuid=THREE.Math.generateUUID();this.array=a;this.itemSize=b;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.version=0;this.normalized=!0===c};
THREE.BufferAttribute.prototype={constructor:THREE.BufferAttribute,get count(){return this.array.length/this.itemSize},set needsUpdate(a){!0===a&&this.version++},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=new a.array.constructor(a.array);this.itemSize=a.itemSize;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.itemSize;c*=b.itemSize;for(var d=0,e=this.itemSize;d<e;d++)this.array[a+d]=b.array[c+d];return this},copyArray:function(a){this.array.set(a);
return this},copyColorsArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",d),f=new THREE.Color);b[c++]=f.r;b[c++]=f.g;b[c++]=f.b}return this},copyIndicesArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];b[c++]=f.a;b[c++]=f.b;b[c++]=f.c}return this},copyVector2sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
d),f=new THREE.Vector2);b[c++]=f.x;b[c++]=f.y}return this},copyVector3sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",d),f=new THREE.Vector3);b[c++]=f.x;b[c++]=f.y;b[c++]=f.z}return this},copyVector4sArray:function(a){for(var b=this.array,c=0,d=0,e=a.length;d<e;d++){var f=a[d];void 0===f&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",d),f=new THREE.Vector4);
b[c++]=f.x;b[c++]=f.y;b[c++]=f.z;b[c++]=f.w}return this},set:function(a,b){void 0===b&&(b=0);this.array.set(a,b);return this},getX:function(a){return this.array[a*this.itemSize]},setX:function(a,b){this.array[a*this.itemSize]=b;return this},getY:function(a){return this.array[a*this.itemSize+1]},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},getZ:function(a){return this.array[a*this.itemSize+2]},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},getW:function(a){return this.array[a*
this.itemSize+3]},setW:function(a,b){this.array[a*this.itemSize+3]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a+0]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this},clone:function(){return(new this.constructor).copy(this)}};
THREE.Int8Attribute=function(a,b){return new THREE.BufferAttribute(new Int8Array(a),b)};THREE.Uint8Attribute=function(a,b){return new THREE.BufferAttribute(new Uint8Array(a),b)};THREE.Uint8ClampedAttribute=function(a,b){return new THREE.BufferAttribute(new Uint8ClampedArray(a),b)};THREE.Int16Attribute=function(a,b){return new THREE.BufferAttribute(new Int16Array(a),b)};THREE.Uint16Attribute=function(a,b){return new THREE.BufferAttribute(new Uint16Array(a),b)};
THREE.Int32Attribute=function(a,b){return new THREE.BufferAttribute(new Int32Array(a),b)};THREE.Uint32Attribute=function(a,b){return new THREE.BufferAttribute(new Uint32Array(a),b)};THREE.Float32Attribute=function(a,b){return new THREE.BufferAttribute(new Float32Array(a),b)};THREE.Float64Attribute=function(a,b){return new THREE.BufferAttribute(new Float64Array(a),b)};
THREE.DynamicBufferAttribute=function(a,b){console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");return(new THREE.BufferAttribute(a,b)).setDynamic(!0)};THREE.InstancedBufferAttribute=function(a,b,c){THREE.BufferAttribute.call(this,a,b);this.meshPerAttribute=c||1};THREE.InstancedBufferAttribute.prototype=Object.create(THREE.BufferAttribute.prototype);THREE.InstancedBufferAttribute.prototype.constructor=THREE.InstancedBufferAttribute;
THREE.InstancedBufferAttribute.prototype.copy=function(a){THREE.BufferAttribute.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this};THREE.InterleavedBuffer=function(a,b){this.uuid=THREE.Math.generateUUID();this.array=a;this.stride=b;this.dynamic=!1;this.updateRange={offset:0,count:-1};this.version=0};
THREE.InterleavedBuffer.prototype={constructor:THREE.InterleavedBuffer,get length(){return this.array.length},get count(){return this.array.length/this.stride},set needsUpdate(a){!0===a&&this.version++},setDynamic:function(a){this.dynamic=a;return this},copy:function(a){this.array=new a.array.constructor(a.array);this.stride=a.stride;this.dynamic=a.dynamic;return this},copyAt:function(a,b,c){a*=this.stride;c*=b.stride;for(var d=0,e=this.stride;d<e;d++)this.array[a+d]=b.array[c+d];return this},set:function(a,
b){void 0===b&&(b=0);this.array.set(a,b);return this},clone:function(){return(new this.constructor).copy(this)}};THREE.InstancedInterleavedBuffer=function(a,b,c){THREE.InterleavedBuffer.call(this,a,b);this.meshPerAttribute=c||1};THREE.InstancedInterleavedBuffer.prototype=Object.create(THREE.InterleavedBuffer.prototype);THREE.InstancedInterleavedBuffer.prototype.constructor=THREE.InstancedInterleavedBuffer;
THREE.InstancedInterleavedBuffer.prototype.copy=function(a){THREE.InterleavedBuffer.prototype.copy.call(this,a);this.meshPerAttribute=a.meshPerAttribute;return this};THREE.InterleavedBufferAttribute=function(a,b,c){this.uuid=THREE.Math.generateUUID();this.data=a;this.itemSize=b;this.offset=c};
THREE.InterleavedBufferAttribute.prototype={constructor:THREE.InterleavedBufferAttribute,get length(){console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");return this.array.length},get count(){return this.data.count},setX:function(a,b){this.data.array[a*this.data.stride+this.offset]=b;return this},setY:function(a,b){this.data.array[a*this.data.stride+this.offset+1]=b;return this},setZ:function(a,b){this.data.array[a*this.data.stride+this.offset+2]=b;return this},
setW:function(a,b){this.data.array[a*this.data.stride+this.offset+3]=b;return this},getX:function(a){return this.data.array[a*this.data.stride+this.offset]},getY:function(a){return this.data.array[a*this.data.stride+this.offset+1]},getZ:function(a){return this.data.array[a*this.data.stride+this.offset+2]},getW:function(a){return this.data.array[a*this.data.stride+this.offset+3]},setXY:function(a,b,c){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;return this},setXYZ:function(a,
b,c,d){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a=a*this.data.stride+this.offset;this.data.array[a+0]=b;this.data.array[a+1]=c;this.data.array[a+2]=d;this.data.array[a+3]=e;return this}};
THREE.Geometry=function(){Object.defineProperty(this,"id",{value:THREE.GeometryIdCount++});this.uuid=THREE.Math.generateUUID();this.name="";this.type="Geometry";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.uvsNeedUpdate=this.elementsNeedUpdate=
this.verticesNeedUpdate=!1};
Object.assign(THREE.Geometry.prototype,THREE.EventDispatcher.prototype,{applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();
this.normalsNeedUpdate=this.verticesNeedUpdate=!0;return this},rotateX:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a;return function(b,
c,d){void 0===a&&(a=new THREE.Matrix4);a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Matrix4);a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a;return function(b){void 0===a&&(a=new THREE.Object3D);a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),fromBufferGeometry:function(a){function b(a,b,d,e){var f=void 0!==g?[n[a].clone(),n[b].clone(),n[d].clone()]:[],q=void 0!==h?[c.colors[a].clone(),
c.colors[b].clone(),c.colors[d].clone()]:[];e=new THREE.Face3(a,b,d,f,q,e);c.faces.push(e);void 0!==k&&c.faceVertexUvs[0].push([p[a].clone(),p[b].clone(),p[d].clone()]);void 0!==l&&c.faceVertexUvs[1].push([m[a].clone(),m[b].clone(),m[d].clone()])}var c=this,d=null!==a.index?a.index.array:void 0,e=a.attributes,f=e.position.array,g=void 0!==e.normal?e.normal.array:void 0,h=void 0!==e.color?e.color.array:void 0,k=void 0!==e.uv?e.uv.array:void 0,l=void 0!==e.uv2?e.uv2.array:void 0;void 0!==l&&(this.faceVertexUvs[1]=
[]);for(var n=[],p=[],m=[],q=e=0;e<f.length;e+=3,q+=2)c.vertices.push(new THREE.Vector3(f[e],f[e+1],f[e+2])),void 0!==g&&n.push(new THREE.Vector3(g[e],g[e+1],g[e+2])),void 0!==h&&c.colors.push(new THREE.Color(h[e],h[e+1],h[e+2])),void 0!==k&&p.push(new THREE.Vector2(k[q],k[q+1])),void 0!==l&&m.push(new THREE.Vector2(l[q],l[q+1]));if(void 0!==d)if(f=a.groups,0<f.length)for(e=0;e<f.length;e++)for(var r=f[e],s=r.start,u=r.count,q=s,s=s+u;q<s;q+=3)b(d[q],d[q+1],d[q+2],r.materialIndex);else for(e=0;e<
d.length;e+=3)b(d[e],d[e+1],d[e+2]);else for(e=0;e<f.length/3;e+=3)b(e,e+1,e+2);this.computeFaceNormals();null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());return this},center:function(){this.computeBoundingBox();var a=this.boundingBox.center().negate();this.translate(a.x,a.y,a.z);return a},normalize:function(){this.computeBoundingSphere();var a=this.boundingSphere.center,b=this.boundingSphere.radius,b=0===b?1:1/
b,c=new THREE.Matrix4;c.set(b,0,0,-b*a.x,0,b,0,-b*a.y,0,0,b,-b*a.z,0,0,0,1);this.applyMatrix(c);return this},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();e.normal.copy(a)}},computeVertexNormals:function(a){void 0===a&&(a=!0);var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<
c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,k=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),k.subVectors(e,f),h.cross(k),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else for(a=0,b=this.faces.length;a<b;a++)c=this.faces[a],d[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal);b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=
this.faces[a],e=c.vertexNormals,3===e.length?(e[0].copy(d[c.a]),e[1].copy(d[c.b]),e[2].copy(d[c.c])):(e[0]=d[c.a].clone(),e[1]=d[c.b].clone(),e[2]=d[c.c].clone());0<this.faces.length&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++)for(e=this.faces[c],e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||(e.__originalVertexNormals=[]),a=0,b=e.vertexNormals.length;a<
b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone();var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;var g=this.morphNormals[a].vertexNormals,h,k;c=0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,k={a:new THREE.Vector3,
b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(k)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(e.normal),k.a.copy(e.vertexNormals[0]),k.b.copy(e.vertexNormals[1]),k.c.copy(e.vertexNormals[2])}c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],e.normal=e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){console.warn("THREE.Geometry: .computeTangents() has been removed.")},
computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);this.boundingSphere.setFromPoints(this.vertices)},merge:function(a,b,c){if(!1===a instanceof THREE.Geometry)console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
a);else{var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,l=this.faceVertexUvs[0];a=a.faceVertexUvs[0];void 0===c&&(c=0);void 0!==b&&(d=(new THREE.Matrix3).getNormalMatrix(b));for(var n=0,p=g.length;n<p;n++){var m=g[n].clone();void 0!==b&&m.applyMatrix4(b);f.push(m)}n=0;for(p=k.length;n<p;n++){var g=k[n],q,r=g.vertexNormals,s=g.vertexColors,m=new THREE.Face3(g.a+e,g.b+e,g.c+e);m.normal.copy(g.normal);void 0!==d&&m.normal.applyMatrix3(d).normalize();b=0;for(f=r.length;b<
f;b++)q=r[b].clone(),void 0!==d&&q.applyMatrix3(d).normalize(),m.vertexNormals.push(q);m.color.copy(g.color);b=0;for(f=s.length;b<f;b++)q=s[b],m.vertexColors.push(q.clone());m.materialIndex=g.materialIndex+c;h.push(m)}n=0;for(p=a.length;n<p;n++)if(c=a[n],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(c[b].clone());l.push(d)}}},mergeMesh:function(a){!1===a instanceof THREE.Mesh?console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",a):(a.matrixAutoUpdate&&a.updateMatrix(),
this.merge(a.geometry,a.matrix))},mergeVertices:function(){var a={},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+"_"+Math.round(d.y*e)+"_"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++)for(e=this.faces[f],e.a=c[e.a],e.b=c[e.b],e.c=c[e.c],e=[e.a,e.b,e.c],d=0;3>d;d++)if(e[d]===e[(d+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(e=a[f],this.faces.splice(e,
1),c=0,g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,1);f=this.vertices.length-b.length;this.vertices=b;return f},sortFacesByMaterialIndex:function(){for(var a=this.faces,b=a.length,c=0;c<b;c++)a[c]._id=c;a.sort(function(a,b){return a.materialIndex-b.materialIndex});var d=this.faceVertexUvs[0],e=this.faceVertexUvs[1],f,g;d&&d.length===b&&(f=[]);e&&e.length===b&&(g=[]);for(c=0;c<b;c++){var h=a[c]._id;f&&f.push(d[h]);g&&g.push(e[h])}f&&(this.faceVertexUvs[0]=f);g&&(this.faceVertexUvs[1]=
g)},toJSON:function(){function a(a,b,c){return c?a|1<<b:a&~(1<<b)}function b(a){var b=a.x.toString()+a.y.toString()+a.z.toString();if(void 0!==l[b])return l[b];l[b]=k.length/3;k.push(a.x,a.y,a.z);return l[b]}function c(a){var b=a.r.toString()+a.g.toString()+a.b.toString();if(void 0!==p[b])return p[b];p[b]=n.length;n.push(a.getHex());return p[b]}function d(a){var b=a.x.toString()+a.y.toString();if(void 0!==q[b])return q[b];q[b]=m.length/2;m.push(a.x,a.y);return q[b]}var e={metadata:{version:4.4,type:"Geometry",
generator:"Geometry.toJSON"}};e.uuid=this.uuid;e.type=this.type;""!==this.name&&(e.name=this.name);if(void 0!==this.parameters){var f=this.parameters,g;for(g in f)void 0!==f[g]&&(e[g]=f[g]);return e}f=[];for(g=0;g<this.vertices.length;g++){var h=this.vertices[g];f.push(h.x,h.y,h.z)}var h=[],k=[],l={},n=[],p={},m=[],q={};for(g=0;g<this.faces.length;g++){var r=this.faces[g],s=void 0!==this.faceVertexUvs[0][g],u=0<r.normal.length(),x=0<r.vertexNormals.length,v=1!==r.color.r||1!==r.color.g||1!==r.color.b,
C=0<r.vertexColors.length,w=0,w=a(w,0,0),w=a(w,1,!0),w=a(w,2,!1),w=a(w,3,s),w=a(w,4,u),w=a(w,5,x),w=a(w,6,v),w=a(w,7,C);h.push(w);h.push(r.a,r.b,r.c);h.push(r.materialIndex);s&&(s=this.faceVertexUvs[0][g],h.push(d(s[0]),d(s[1]),d(s[2])));u&&h.push(b(r.normal));x&&(u=r.vertexNormals,h.push(b(u[0]),b(u[1]),b(u[2])));v&&h.push(c(r.color));C&&(r=r.vertexColors,h.push(c(r[0]),c(r[1]),c(r[2])))}e.data={};e.data.vertices=f;e.data.normals=k;0<n.length&&(e.data.colors=n);0<m.length&&(e.data.uvs=[m]);e.data.faces=
h;return e},clone:function(){return(new THREE.Geometry).copy(this)},copy:function(a){this.vertices=[];this.faces=[];this.faceVertexUvs=[[]];for(var b=a.vertices,c=0,d=b.length;c<d;c++)this.vertices.push(b[c].clone());b=a.faces;c=0;for(d=b.length;c<d;c++)this.faces.push(b[c].clone());c=0;for(d=a.faceVertexUvs.length;c<d;c++){b=a.faceVertexUvs[c];void 0===this.faceVertexUvs[c]&&(this.faceVertexUvs[c]=[]);for(var e=0,f=b.length;e<f;e++){for(var g=b[e],h=[],k=0,l=g.length;k<l;k++)h.push(g[k].clone());
this.faceVertexUvs[c].push(h)}}return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});THREE.GeometryIdCount=0;
THREE.DirectGeometry=function(){Object.defineProperty(this,"id",{value:THREE.GeometryIdCount++});this.uuid=THREE.Math.generateUUID();this.name="";this.type="DirectGeometry";this.indices=[];this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];this.boundingSphere=this.boundingBox=null;this.groupsNeedUpdate=this.uvsNeedUpdate=this.colorsNeedUpdate=this.normalsNeedUpdate=this.verticesNeedUpdate=!1};
Object.assign(THREE.DirectGeometry.prototype,THREE.EventDispatcher.prototype,{computeBoundingBox:THREE.Geometry.prototype.computeBoundingBox,computeBoundingSphere:THREE.Geometry.prototype.computeBoundingSphere,computeFaceNormals:function(){console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")},computeVertexNormals:function(){console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")},computeGroups:function(a){var b,
c=[],d;a=a.faces;for(var e=0;e<a.length;e++){var f=a[e];f.materialIndex!==d&&(d=f.materialIndex,void 0!==b&&(b.count=3*e-b.start,c.push(b)),b={start:3*e,materialIndex:d})}void 0!==b&&(b.count=3*e-b.start,c.push(b));this.groups=c},fromGeometry:function(a){var b=a.faces,c=a.vertices,d=a.faceVertexUvs,e=d[0]&&0<d[0].length,f=d[1]&&0<d[1].length,g=a.morphTargets,h=g.length,k;if(0<h){k=[];for(var l=0;l<h;l++)k[l]=[];this.morphTargets.position=k}var n=a.morphNormals,p=n.length,m;if(0<p){m=[];for(l=0;l<
p;l++)m[l]=[];this.morphTargets.normal=m}for(var q=a.skinIndices,r=a.skinWeights,s=q.length===c.length,u=r.length===c.length,l=0;l<b.length;l++){var x=b[l];this.vertices.push(c[x.a],c[x.b],c[x.c]);var v=x.vertexNormals;3===v.length?this.normals.push(v[0],v[1],v[2]):(v=x.normal,this.normals.push(v,v,v));v=x.vertexColors;3===v.length?this.colors.push(v[0],v[1],v[2]):(v=x.color,this.colors.push(v,v,v));!0===e&&(v=d[0][l],void 0!==v?this.uvs.push(v[0],v[1],v[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
l),this.uvs.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2)));!0===f&&(v=d[1][l],void 0!==v?this.uvs2.push(v[0],v[1],v[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",l),this.uvs2.push(new THREE.Vector2,new THREE.Vector2,new THREE.Vector2)));for(v=0;v<h;v++){var C=g[v].vertices;k[v].push(C[x.a],C[x.b],C[x.c])}for(v=0;v<p;v++)C=n[v].vertexNormals[l],m[v].push(C.a,C.b,C.c);s&&this.skinIndices.push(q[x.a],q[x.b],q[x.c]);u&&this.skinWeights.push(r[x.a],r[x.b],
r[x.c])}this.computeGroups(a);this.verticesNeedUpdate=a.verticesNeedUpdate;this.normalsNeedUpdate=a.normalsNeedUpdate;this.colorsNeedUpdate=a.colorsNeedUpdate;this.uvsNeedUpdate=a.uvsNeedUpdate;this.groupsNeedUpdate=a.groupsNeedUpdate;return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});
THREE.BufferGeometry=function(){Object.defineProperty(this,"id",{value:THREE.GeometryIdCount++});this.uuid=THREE.Math.generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity}};
Object.assign(THREE.BufferGeometry.prototype,THREE.EventDispatcher.prototype,{getIndex:function(){return this.index},setIndex:function(a){this.index=a},addAttribute:function(a,b,c){if(!1===b instanceof THREE.BufferAttribute&&!1===b instanceof THREE.InterleavedBufferAttribute)console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.addAttribute(a,new THREE.BufferAttribute(b,c));else if("index"===a)console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
this.setIndex(b);else return this.attributes[a]=b,this},getAttribute:function(a){return this.attributes[a]},removeAttribute:function(a){delete this.attributes[a];return this},addGroup:function(a,b,c){this.groups.push({start:a,count:b,materialIndex:void 0!==c?c:0})},clearGroups:function(){this.groups=[]},setDrawRange:function(a,b){this.drawRange.start=a;this.drawRange.count=b},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToVector3Array(b.array),b.needsUpdate=!0);b=this.attributes.normal;
void 0!==b&&((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array),b.needsUpdate=!0);null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this},rotateX:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationX(b);this.applyMatrix(a);return this}}(),rotateY:function(){var a;return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationY(b);this.applyMatrix(a);return this}}(),rotateZ:function(){var a;
return function(b){void 0===a&&(a=new THREE.Matrix4);a.makeRotationZ(b);this.applyMatrix(a);return this}}(),translate:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Matrix4);a.makeTranslation(b,c,d);this.applyMatrix(a);return this}}(),scale:function(){var a;return function(b,c,d){void 0===a&&(a=new THREE.Matrix4);a.makeScale(b,c,d);this.applyMatrix(a);return this}}(),lookAt:function(){var a;return function(b){void 0===a&&(a=new THREE.Object3D);a.lookAt(b);a.updateMatrix();this.applyMatrix(a.matrix)}}(),
center:function(){this.computeBoundingBox();var a=this.boundingBox.center().negate();this.translate(a.x,a.y,a.z);return a},setFromObject:function(a){var b=a.geometry;if(a instanceof THREE.Points||a instanceof THREE.Line){a=new THREE.Float32Attribute(3*b.vertices.length,3);var c=new THREE.Float32Attribute(3*b.colors.length,3);this.addAttribute("position",a.copyVector3sArray(b.vertices));this.addAttribute("color",c.copyColorsArray(b.colors));b.lineDistances&&b.lineDistances.length===b.vertices.length&&
(a=new THREE.Float32Attribute(b.lineDistances.length,1),this.addAttribute("lineDistance",a.copyArray(b.lineDistances)));null!==b.boundingSphere&&(this.boundingSphere=b.boundingSphere.clone());null!==b.boundingBox&&(this.boundingBox=b.boundingBox.clone())}else a instanceof THREE.Mesh&&b instanceof THREE.Geometry&&this.fromGeometry(b);return this},updateFromObject:function(a){var b=a.geometry;if(a instanceof THREE.Mesh){var c=b.__directGeometry;if(void 0===c)return this.fromGeometry(b);c.verticesNeedUpdate=
b.verticesNeedUpdate;c.normalsNeedUpdate=b.normalsNeedUpdate;c.colorsNeedUpdate=b.colorsNeedUpdate;c.uvsNeedUpdate=b.uvsNeedUpdate;c.groupsNeedUpdate=b.groupsNeedUpdate;b.verticesNeedUpdate=!1;b.normalsNeedUpdate=!1;b.colorsNeedUpdate=!1;b.uvsNeedUpdate=!1;b.groupsNeedUpdate=!1;b=c}!0===b.verticesNeedUpdate&&(c=this.attributes.position,void 0!==c&&(c.copyVector3sArray(b.vertices),c.needsUpdate=!0),b.verticesNeedUpdate=!1);!0===b.normalsNeedUpdate&&(c=this.attributes.normal,void 0!==c&&(c.copyVector3sArray(b.normals),
c.needsUpdate=!0),b.normalsNeedUpdate=!1);!0===b.colorsNeedUpdate&&(c=this.attributes.color,void 0!==c&&(c.copyColorsArray(b.colors),c.needsUpdate=!0),b.colorsNeedUpdate=!1);b.uvsNeedUpdate&&(c=this.attributes.uv,void 0!==c&&(c.copyVector2sArray(b.uvs),c.needsUpdate=!0),b.uvsNeedUpdate=!1);b.lineDistancesNeedUpdate&&(c=this.attributes.lineDistance,void 0!==c&&(c.copyArray(b.lineDistances),c.needsUpdate=!0),b.lineDistancesNeedUpdate=!1);b.groupsNeedUpdate&&(b.computeGroups(a.geometry),this.groups=
b.groups,b.groupsNeedUpdate=!1);return this},fromGeometry:function(a){a.__directGeometry=(new THREE.DirectGeometry).fromGeometry(a);return this.fromDirectGeometry(a.__directGeometry)},fromDirectGeometry:function(a){var b=new Float32Array(3*a.vertices.length);this.addAttribute("position",(new THREE.BufferAttribute(b,3)).copyVector3sArray(a.vertices));0<a.normals.length&&(b=new Float32Array(3*a.normals.length),this.addAttribute("normal",(new THREE.BufferAttribute(b,3)).copyVector3sArray(a.normals)));
0<a.colors.length&&(b=new Float32Array(3*a.colors.length),this.addAttribute("color",(new THREE.BufferAttribute(b,3)).copyColorsArray(a.colors)));0<a.uvs.length&&(b=new Float32Array(2*a.uvs.length),this.addAttribute("uv",(new THREE.BufferAttribute(b,2)).copyVector2sArray(a.uvs)));0<a.uvs2.length&&(b=new Float32Array(2*a.uvs2.length),this.addAttribute("uv2",(new THREE.BufferAttribute(b,2)).copyVector2sArray(a.uvs2)));0<a.indices.length&&(b=new (65535<a.vertices.length?Uint32Array:Uint16Array)(3*a.indices.length),
this.setIndex((new THREE.BufferAttribute(b,1)).copyIndicesArray(a.indices)));this.groups=a.groups;for(var c in a.morphTargets){for(var b=[],d=a.morphTargets[c],e=0,f=d.length;e<f;e++){var g=d[e],h=new THREE.Float32Attribute(3*g.length,3);b.push(h.copyVector3sArray(g))}this.morphAttributes[c]=b}0<a.skinIndices.length&&(c=new THREE.Float32Attribute(4*a.skinIndices.length,4),this.addAttribute("skinIndex",c.copyVector4sArray(a.skinIndices)));0<a.skinWeights.length&&(c=new THREE.Float32Attribute(4*a.skinWeights.length,
4),this.addAttribute("skinWeight",c.copyVector4sArray(a.skinWeights)));null!==a.boundingSphere&&(this.boundingSphere=a.boundingSphere.clone());null!==a.boundingBox&&(this.boundingBox=a.boundingBox.clone());return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;void 0!==a?this.boundingBox.setFromArray(a):this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&
console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){var a=new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){var d=this.boundingSphere.center;a.setFromArray(c);a.center(d);for(var e=0,f=0,g=c.length;f<g;f+=3)b.fromArray(c,f),e=Math.max(e,d.distanceToSquared(b));
this.boundingSphere.radius=Math.sqrt(e);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}}(),computeFaceNormals:function(){},computeVertexNormals:function(){var a=this.index,b=this.attributes,c=this.groups;if(b.position){var d=b.position.array;if(void 0===b.normal)this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(d.length),3));else for(var e=b.normal.array,
f=0,g=e.length;f<g;f++)e[f]=0;var e=b.normal.array,h,k,l,n=new THREE.Vector3,p=new THREE.Vector3,m=new THREE.Vector3,q=new THREE.Vector3,r=new THREE.Vector3;if(a){a=a.array;0===c.length&&this.addGroup(0,a.length);for(var s=0,u=c.length;s<u;++s)for(f=c[s],g=f.start,h=f.count,f=g,g+=h;f<g;f+=3)h=3*a[f+0],k=3*a[f+1],l=3*a[f+2],n.fromArray(d,h),p.fromArray(d,k),m.fromArray(d,l),q.subVectors(m,p),r.subVectors(n,p),q.cross(r),e[h]+=q.x,e[h+1]+=q.y,e[h+2]+=q.z,e[k]+=q.x,e[k+1]+=q.y,e[k+2]+=q.z,e[l]+=q.x,
e[l+1]+=q.y,e[l+2]+=q.z}else for(f=0,g=d.length;f<g;f+=9)n.fromArray(d,f),p.fromArray(d,f+3),m.fromArray(d,f+6),q.subVectors(m,p),r.subVectors(n,p),q.cross(r),e[f]=q.x,e[f+1]=q.y,e[f+2]=q.z,e[f+3]=q.x,e[f+4]=q.y,e[f+5]=q.z,e[f+6]=q.x,e[f+7]=q.y,e[f+8]=q.z;this.normalizeNormals();b.normal.needsUpdate=!0}},merge:function(a,b){if(!1===a instanceof THREE.BufferGeometry)console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",a);else{void 0===b&&(b=0);var c=this.attributes,
d;for(d in c)if(void 0!==a.attributes[d])for(var e=c[d].array,f=a.attributes[d],g=f.array,h=0,f=f.itemSize*b;h<g.length;h++,f++)e[f]=g[h];return this}},normalizeNormals:function(){for(var a=this.attributes.normal.array,b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},toNonIndexed:function(){if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;var a=new THREE.BufferGeometry,
b=this.index.array,c=this.attributes,d;for(d in c){for(var e=c[d],f=e.array,e=e.itemSize,g=new f.constructor(b.length*e),h=0,k=0,l=0,n=b.length;l<n;l++)for(var h=b[l]*e,p=0;p<e;p++)g[k++]=f[h++];a.addAttribute(d,new THREE.BufferAttribute(g,e))}return a},toJSON:function(){var a={metadata:{version:4.4,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};a.uuid=this.uuid;a.type=this.type;""!==this.name&&(a.name=this.name);if(void 0!==this.parameters){var b=this.parameters,c;for(c in b)void 0!==
b[c]&&(a[c]=b[c]);return a}a.data={attributes:{}};var d=this.index;null!==d&&(b=Array.prototype.slice.call(d.array),a.data.index={type:d.array.constructor.name,array:b});d=this.attributes;for(c in d){var e=d[c],b=Array.prototype.slice.call(e.array);a.data.attributes[c]={itemSize:e.itemSize,type:e.array.constructor.name,array:b,normalized:e.normalized}}c=this.groups;0<c.length&&(a.data.groups=JSON.parse(JSON.stringify(c)));c=this.boundingSphere;null!==c&&(a.data.boundingSphere={center:c.center.toArray(),
radius:c.radius});return a},clone:function(){return(new THREE.BufferGeometry).copy(this)},copy:function(a){var b=a.index;null!==b&&this.setIndex(b.clone());var b=a.attributes,c;for(c in b)this.addAttribute(c,b[c].clone());a=a.groups;c=0;for(b=a.length;c<b;c++){var d=a[c];this.addGroup(d.start,d.count,d.materialIndex)}return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});THREE.BufferGeometry.MaxIndex=65535;
THREE.InstancedBufferGeometry=function(){THREE.BufferGeometry.call(this);this.type="InstancedBufferGeometry";this.maxInstancedCount=void 0};THREE.InstancedBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.InstancedBufferGeometry.prototype.constructor=THREE.InstancedBufferGeometry;THREE.InstancedBufferGeometry.prototype.addGroup=function(a,b,c){this.groups.push({start:a,count:b,instances:c})};
THREE.InstancedBufferGeometry.prototype.copy=function(a){var b=a.index;null!==b&&this.setIndex(b.clone());var b=a.attributes,c;for(c in b)this.addAttribute(c,b[c].clone());a=a.groups;c=0;for(b=a.length;c<b;c++){var d=a[c];this.addGroup(d.start,d.count,d.instances)}return this};THREE.Uniform=function(a,b){"string"===typeof a&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),a=b);this.value=a;this.dynamic=!1};
THREE.Uniform.prototype={constructor:THREE.Uniform,onUpdate:function(a){this.dynamic=!0;this.onUpdateCallback=a;return this}};THREE.AnimationAction=function(){throw Error("THREE.AnimationAction: Use mixer.clipAction for construction.");};
THREE.AnimationAction._new=function(a,b,c){this._mixer=a;this._clip=b;this._localRoot=c||null;a=b.tracks;b=a.length;c=Array(b);for(var d={endingStart:THREE.ZeroCurvatureEnding,endingEnd:THREE.ZeroCurvatureEnding},e=0;e!==b;++e){var f=a[e].createInterpolant(null);c[e]=f;f.settings=d}this._interpolantSettings=d;this._interpolants=c;this._propertyBindings=Array(b);this._weightInterpolant=this._timeScaleInterpolant=this._byClipCacheIndex=this._cacheIndex=null;this.loop=THREE.LoopRepeat;this._loopCount=
-1;this._startTime=null;this.time=0;this._effectiveWeight=this.weight=this._effectiveTimeScale=this.timeScale=1;this.repetitions=Infinity;this.paused=!1;this.enabled=!0;this.clampWhenFinished=!1;this.zeroSlopeAtEnd=this.zeroSlopeAtStart=!0};
THREE.AnimationAction._new.prototype={constructor:THREE.AnimationAction._new,play:function(){this._mixer._activateAction(this);return this},stop:function(){this._mixer._deactivateAction(this);return this.reset()},reset:function(){this.paused=!1;this.enabled=!0;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()},isRunning:function(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)},isScheduled:function(){return this._mixer._isActiveAction(this)},
startAt:function(a){this._startTime=a;return this},setLoop:function(a,b){this.loop=a;this.repetitions=b;return this},setEffectiveWeight:function(a){this.weight=a;this._effectiveWeight=this.enabled?a:0;return this.stopFading()},getEffectiveWeight:function(){return this._effectiveWeight},fadeIn:function(a){return this._scheduleFading(a,0,1)},fadeOut:function(a){return this._scheduleFading(a,1,0)},crossFadeFrom:function(a,b,c){a.fadeOut(b);this.fadeIn(b);if(c){c=this._clip.duration;var d=a._clip.duration,
e=c/d;a.warp(1,d/c,b);this.warp(e,1,b)}return this},crossFadeTo:function(a,b,c){return a.crossFadeFrom(this,b,c)},stopFading:function(){var a=this._weightInterpolant;null!==a&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},setEffectiveTimeScale:function(a){this.timeScale=a;this._effectiveTimeScale=this.paused?0:a;return this.stopWarping()},getEffectiveTimeScale:function(){return this._effectiveTimeScale},setDuration:function(a){this.timeScale=this._clip.duration/
a;return this.stopWarping()},syncWith:function(a){this.time=a.time;this.timeScale=a.timeScale;return this.stopWarping()},halt:function(a){return this.warp(this._effectiveTimeScale,0,a)},warp:function(a,b,c){var d=this._mixer,e=d.time,f=this._timeScaleInterpolant,g=this.timeScale;null===f&&(this._timeScaleInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;f=f.sampleValues;d[0]=e;d[1]=e+c;f[0]=a/g;f[1]=b/g;return this},stopWarping:function(){var a=this._timeScaleInterpolant;null!==a&&
(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(a));return this},getMixer:function(){return this._mixer},getClip:function(){return this._clip},getRoot:function(){return this._localRoot||this._mixer._root},_update:function(a,b,c,d){var e=this._startTime;if(null!==e){b=(a-e)*c;if(0>b||0===c)return;this._startTime=null;b*=c}b*=this._updateTimeScale(a);c=this._updateTime(b);a=this._updateWeight(a);if(0<a){b=this._interpolants;for(var e=this._propertyBindings,f=0,g=b.length;f!==
g;++f)b[f].evaluate(c),e[f].accumulate(d,a)}},_updateWeight:function(a){var b=0;if(this.enabled){var b=this.weight,c=this._weightInterpolant;if(null!==c){var d=c.evaluate(a)[0],b=b*d;a>c.parameterPositions[1]&&(this.stopFading(),0===d&&(this.enabled=!1))}}return this._effectiveWeight=b},_updateTimeScale:function(a){var b=0;if(!this.paused){var b=this.timeScale,c=this._timeScaleInterpolant;if(null!==c){var d=c.evaluate(a)[0],b=b*d;a>c.parameterPositions[1]&&(this.stopWarping(),0===b?this.paused=!0:
this.timeScale=b)}}return this._effectiveTimeScale=b},_updateTime:function(a){var b=this.time+a;if(0===a)return b;var c=this._clip.duration,d=this.loop,e=this._loopCount;if(d===THREE.LoopOnce)a:{if(-1===e&&(this.loopCount=0,this._setEndings(!0,!0,!1)),b>=c)b=c;else if(0>b)b=0;else break a;this.clampWhenFinished?this.paused=!0:this.enabled=!1;this._mixer.dispatchEvent({type:"finished",action:this,direction:0>a?-1:1})}else{d=d===THREE.LoopPingPong;-1===e&&(0<=a?(e=0,this._setEndings(!0,0===this.repetitions,
d)):this._setEndings(0===this.repetitions,!0,d));if(b>=c||0>b){var f=Math.floor(b/c),b=b-c*f,e=e+Math.abs(f),g=this.repetitions-e;0>g?(this.clampWhenFinished?this.paused=!0:this.enabled=!1,b=0<a?c:0,this._mixer.dispatchEvent({type:"finished",action:this,direction:0<a?1:-1})):(0===g?(a=0>a,this._setEndings(a,!a,d)):this._setEndings(!1,!1,d),this._loopCount=e,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:f}))}if(d&&1===(e&1))return this.time=b,c-b}return this.time=b},_setEndings:function(a,
b,c){var d=this._interpolantSettings;c?(d.endingStart=THREE.ZeroSlopeEnding,d.endingEnd=THREE.ZeroSlopeEnding):(d.endingStart=a?this.zeroSlopeAtStart?THREE.ZeroSlopeEnding:THREE.ZeroCurvatureEnding:THREE.WrapAroundEnding,d.endingEnd=b?this.zeroSlopeAtEnd?THREE.ZeroSlopeEnding:THREE.ZeroCurvatureEnding:THREE.WrapAroundEnding)},_scheduleFading:function(a,b,c){var d=this._mixer,e=d.time,f=this._weightInterpolant;null===f&&(this._weightInterpolant=f=d._lendControlInterpolant());d=f.parameterPositions;
f=f.sampleValues;d[0]=e;f[0]=b;d[1]=e+a;f[1]=c;return this}};THREE.AnimationClip=function(a,b,c){this.name=a;this.tracks=c;this.duration=void 0!==b?b:-1;this.uuid=THREE.Math.generateUUID();0>this.duration&&this.resetDuration();this.trim();this.optimize()};
THREE.AnimationClip.prototype={constructor:THREE.AnimationClip,resetDuration:function(){for(var a=0,b=0,c=this.tracks.length;b!==c;++b)var d=this.tracks[b],a=Math.max(a,d.times[d.times.length-1]);this.duration=a},trim:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].trim(0,this.duration);return this},optimize:function(){for(var a=0;a<this.tracks.length;a++)this.tracks[a].optimize();return this}};
Object.assign(THREE.AnimationClip,{parse:function(a){for(var b=[],c=a.tracks,d=1/(a.fps||1),e=0,f=c.length;e!==f;++e)b.push(THREE.KeyframeTrack.parse(c[e]).scale(d));return new THREE.AnimationClip(a.name,a.duration,b)},toJSON:function(a){var b=[],c=a.tracks;a={name:a.name,duration:a.duration,tracks:b};for(var d=0,e=c.length;d!==e;++d)b.push(THREE.KeyframeTrack.toJSON(c[d]));return a},CreateFromMorphTargetSequence:function(a,b,c,d){for(var e=b.length,f=[],g=0;g<e;g++){var h=[],k=[];h.push((g+e-1)%
e,g,(g+1)%e);k.push(0,1,0);var l=THREE.AnimationUtils.getKeyframeOrder(h),h=THREE.AnimationUtils.sortedArray(h,1,l),k=THREE.AnimationUtils.sortedArray(k,1,l);d||0!==h[0]||(h.push(e),k.push(k[0]));f.push((new THREE.NumberKeyframeTrack(".morphTargetInfluences["+b[g].name+"]",h,k)).scale(1/c))}return new THREE.AnimationClip(a,-1,f)},findByName:function(a,b){var c=a;Array.isArray(a)||(c=a.geometry&&a.geometry.animations||a.animations);for(var d=0;d<c.length;d++)if(c[d].name===b)return c[d];return null},
CreateClipsFromMorphTargetSequences:function(a,b,c){for(var d={},e=/^([\w-]*?)([\d]+)$/,f=0,g=a.length;f<g;f++){var h=a[f],k=h.name.match(e);if(k&&1<k.length){var l=k[1];(k=d[l])||(d[l]=k=[]);k.push(h)}}a=[];for(l in d)a.push(THREE.AnimationClip.CreateFromMorphTargetSequence(l,d[l],b,c));return a},parseAnimation:function(a,b,c){if(!a)return console.error("  no animation in JSONLoader data"),null;c=function(a,b,c,d,e){if(0!==c.length){var f=[],g=[];THREE.AnimationUtils.flattenJSON(c,f,g,d);0!==f.length&&
e.push(new a(b,f,g))}};var d=[],e=a.name||"default",f=a.length||-1,g=a.fps||30;a=a.hierarchy||[];for(var h=0;h<a.length;h++){var k=a[h].keys;if(k&&0!==k.length)if(k[0].morphTargets){for(var f={},l=0;l<k.length;l++)if(k[l].morphTargets)for(var n=0;n<k[l].morphTargets.length;n++)f[k[l].morphTargets[n]]=-1;for(var p in f){for(var m=[],q=[],n=0;n!==k[l].morphTargets.length;++n){var r=k[l];m.push(r.time);q.push(r.morphTarget===p?1:0)}d.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence["+p+"]",
m,q))}f=f.length*(g||1)}else l=".bones["+b[h].name+"]",c(THREE.VectorKeyframeTrack,l+".position",k,"pos",d),c(THREE.QuaternionKeyframeTrack,l+".quaternion",k,"rot",d),c(THREE.VectorKeyframeTrack,l+".scale",k,"scl",d)}return 0===d.length?null:new THREE.AnimationClip(e,f,d)}});THREE.AnimationMixer=function(a){this._root=a;this._initMemoryManager();this.time=this._accuIndex=0;this.timeScale=1};
Object.assign(THREE.AnimationMixer.prototype,THREE.EventDispatcher.prototype,{clipAction:function(a,b){var c=b||this._root,d=c.uuid,e="string"===typeof a?THREE.AnimationClip.findByName(c,a):a,c=null!==e?e.uuid:a,f=this._actionsByClip[c],g=null;if(void 0!==f){g=f.actionByRoot[d];if(void 0!==g)return g;g=f.knownActions[0];null===e&&(e=g._clip)}if(null===e)return null;e=new THREE.AnimationMixer._Action(this,e,b);this._bindAction(e,g);this._addInactiveAction(e,c,d);return e},existingAction:function(a,
b){var c=b||this._root,d=c.uuid,c="string"===typeof a?THREE.AnimationClip.findByName(c,a):a,c=this._actionsByClip[c?c.uuid:a];return void 0!==c?c.actionByRoot[d]||null:null},stopAllAction:function(){for(var a=this._actions,b=this._nActiveActions,c=this._bindings,d=this._nActiveBindings,e=this._nActiveBindings=this._nActiveActions=0;e!==b;++e)a[e].reset();for(e=0;e!==d;++e)c[e].useCount=0;return this},update:function(a){a*=this.timeScale;for(var b=this._actions,c=this._nActiveActions,d=this.time+=
a,e=Math.sign(a),f=this._accuIndex^=1,g=0;g!==c;++g){var h=b[g];h.enabled&&h._update(d,a,e,f)}a=this._bindings;b=this._nActiveBindings;for(g=0;g!==b;++g)a[g].apply(f);return this},getRoot:function(){return this._root},uncacheClip:function(a){var b=this._actions;a=a.uuid;var c=this._actionsByClip,d=c[a];if(void 0!==d){for(var d=d.knownActions,e=0,f=d.length;e!==f;++e){var g=d[e];this._deactivateAction(g);var h=g._cacheIndex,k=b[b.length-1];g._cacheIndex=null;g._byClipCacheIndex=null;k._cacheIndex=
h;b[h]=k;b.pop();this._removeInactiveBindingsForAction(g)}delete c[a]}},uncacheRoot:function(a){a=a.uuid;var b=this._actionsByClip,c;for(c in b){var d=b[c].actionByRoot[a];void 0!==d&&(this._deactivateAction(d),this._removeInactiveAction(d))}c=this._bindingsByRootAndName[a];if(void 0!==c)for(var e in c)a=c[e],a.restoreOriginalState(),this._removeInactiveBinding(a)},uncacheAction:function(a,b){var c=this.existingAction(a,b);null!==c&&(this._deactivateAction(c),this._removeInactiveAction(c))}});
THREE.AnimationMixer._Action=THREE.AnimationAction._new;
Object.assign(THREE.AnimationMixer.prototype,{_bindAction:function(a,b){var c=a._localRoot||this._root,d=a._clip.tracks,e=d.length,f=a._propertyBindings,g=a._interpolants,h=c.uuid,k=this._bindingsByRootAndName,l=k[h];void 0===l&&(l={},k[h]=l);for(k=0;k!==e;++k){var n=d[k],p=n.name,m=l[p];if(void 0===m){m=f[k];if(void 0!==m){null===m._cacheIndex&&(++m.referenceCount,this._addInactiveBinding(m,h,p));continue}m=new THREE.PropertyMixer(THREE.PropertyBinding.create(c,p,b&&b._propertyBindings[k].binding.parsedPath),
n.ValueTypeName,n.getValueSize());++m.referenceCount;this._addInactiveBinding(m,h,p)}f[k]=m;g[k].resultBuffer=m.buffer}},_activateAction:function(a){if(!this._isActiveAction(a)){if(null===a._cacheIndex){var b=(a._localRoot||this._root).uuid,c=a._clip.uuid,d=this._actionsByClip[c];this._bindAction(a,d&&d.knownActions[0]);this._addInactiveAction(a,c,b)}b=a._propertyBindings;c=0;for(d=b.length;c!==d;++c){var e=b[c];0===e.useCount++&&(this._lendBinding(e),e.saveOriginalState())}this._lendAction(a)}},
_deactivateAction:function(a){if(this._isActiveAction(a)){for(var b=a._propertyBindings,c=0,d=b.length;c!==d;++c){var e=b[c];0===--e.useCount&&(e.restoreOriginalState(),this._takeBackBinding(e))}this._takeBackAction(a)}},_initMemoryManager:function(){this._actions=[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;var a=this;this.stats={actions:{get total(){return a._actions.length},
get inUse(){return a._nActiveActions}},bindings:{get total(){return a._bindings.length},get inUse(){return a._nActiveBindings}},controlInterpolants:{get total(){return a._controlInterpolants.length},get inUse(){return a._nActiveControlInterpolants}}}},_isActiveAction:function(a){a=a._cacheIndex;return null!==a&&a<this._nActiveActions},_addInactiveAction:function(a,b,c){var d=this._actions,e=this._actionsByClip,f=e[b];void 0===f?(f={knownActions:[a],actionByRoot:{}},a._byClipCacheIndex=0,e[b]=f):(b=
f.knownActions,a._byClipCacheIndex=b.length,b.push(a));a._cacheIndex=d.length;d.push(a);f.actionByRoot[c]=a},_removeInactiveAction:function(a){var b=this._actions,c=b[b.length-1],d=a._cacheIndex;c._cacheIndex=d;b[d]=c;b.pop();a._cacheIndex=null;var c=a._clip.uuid,d=this._actionsByClip,e=d[c],f=e.knownActions,g=f[f.length-1],h=a._byClipCacheIndex;g._byClipCacheIndex=h;f[h]=g;f.pop();a._byClipCacheIndex=null;delete e.actionByRoot[(b._localRoot||this._root).uuid];0===f.length&&delete d[c];this._removeInactiveBindingsForAction(a)},
_removeInactiveBindingsForAction:function(a){a=a._propertyBindings;for(var b=0,c=a.length;b!==c;++b){var d=a[b];0===--d.referenceCount&&this._removeInactiveBinding(d)}},_lendAction:function(a){var b=this._actions,c=a._cacheIndex,d=this._nActiveActions++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackAction:function(a){var b=this._actions,c=a._cacheIndex,d=--this._nActiveActions,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_addInactiveBinding:function(a,b,c){var d=this._bindingsByRootAndName,
e=d[b],f=this._bindings;void 0===e&&(e={},d[b]=e);e[c]=a;a._cacheIndex=f.length;f.push(a)},_removeInactiveBinding:function(a){var b=this._bindings,c=a.binding,d=c.rootNode.uuid,c=c.path,e=this._bindingsByRootAndName,f=e[d],g=b[b.length-1];a=a._cacheIndex;g._cacheIndex=a;b[a]=g;b.pop();delete f[c];a:{for(var h in f)break a;delete e[d]}},_lendBinding:function(a){var b=this._bindings,c=a._cacheIndex,d=this._nActiveBindings++,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_takeBackBinding:function(a){var b=
this._bindings,c=a._cacheIndex,d=--this._nActiveBindings,e=b[d];a._cacheIndex=d;b[d]=a;e._cacheIndex=c;b[c]=e},_lendControlInterpolant:function(){var a=this._controlInterpolants,b=this._nActiveControlInterpolants++,c=a[b];void 0===c&&(c=new THREE.LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),c.__cacheIndex=b,a[b]=c);return c},_takeBackControlInterpolant:function(a){var b=this._controlInterpolants,c=a.__cacheIndex,d=--this._nActiveControlInterpolants,
e=b[d];a.__cacheIndex=d;b[d]=a;e.__cacheIndex=c;b[c]=e},_controlInterpolantsResultBuffer:new Float32Array(1)});
THREE.AnimationObjectGroup=function(a){this.uuid=THREE.Math.generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;var b={};this._indicesByUUID=b;for(var c=0,d=arguments.length;c!==d;++c)b[arguments[c].uuid]=c;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath={};var e=this;this.stats={objects:{get total(){return e._objects.length},get inUse(){return this.total-e.nCachedObjects_}},get bindingsPerObject(){return e._bindings.length}}};
THREE.AnimationObjectGroup.prototype={constructor:THREE.AnimationObjectGroup,add:function(a){for(var b=this._objects,c=b.length,d=this.nCachedObjects_,e=this._indicesByUUID,f=this._paths,g=this._parsedPaths,h=this._bindings,k=h.length,l=0,n=arguments.length;l!==n;++l){var p=arguments[l],m=p.uuid,q=e[m];if(void 0===q){q=c++;e[m]=q;b.push(p);for(var m=0,r=k;m!==r;++m)h[m].push(new THREE.PropertyBinding(p,f[m],g[m]))}else if(q<d){var s=b[q],u=--d,r=b[u];e[r.uuid]=q;b[q]=r;e[m]=u;b[u]=p;m=0;for(r=k;m!==
r;++m){var x=h[m],v=x[q];x[q]=x[u];void 0===v&&(v=new THREE.PropertyBinding(p,f[m],g[m]));x[u]=v}}else b[q]!==s&&console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")}this.nCachedObjects_=d},remove:function(a){for(var b=this._objects,c=this.nCachedObjects_,d=this._indicesByUUID,e=this._bindings,f=e.length,g=0,h=arguments.length;g!==h;++g){var k=arguments[g],l=k.uuid,n=d[l];if(void 0!==n&&n>=c){var p=c++,m=b[p];d[m.uuid]=
n;b[n]=m;d[l]=p;b[p]=k;k=0;for(l=f;k!==l;++k){var m=e[k],q=m[n];m[n]=m[p];m[p]=q}}}this.nCachedObjects_=c},uncache:function(a){for(var b=this._objects,c=b.length,d=this.nCachedObjects_,e=this._indicesByUUID,f=this._bindings,g=f.length,h=0,k=arguments.length;h!==k;++h){var l=arguments[h].uuid,n=e[l];if(void 0!==n)if(delete e[l],n<d){var l=--d,p=b[l],m=--c,q=b[m];e[p.uuid]=n;b[n]=p;e[q.uuid]=l;b[l]=q;b.pop();p=0;for(q=g;p!==q;++p){var r=f[p],s=r[m];r[n]=r[l];r[l]=s;r.pop()}}else for(m=--c,q=b[m],e[q.uuid]=
n,b[n]=q,b.pop(),p=0,q=g;p!==q;++p)r=f[p],r[n]=r[m],r.pop()}this.nCachedObjects_=d},subscribe_:function(a,b){var c=this._bindingsIndicesByPath,d=c[a],e=this._bindings;if(void 0!==d)return e[d];var f=this._paths,g=this._parsedPaths,h=this._objects,k=this.nCachedObjects_,l=Array(h.length),d=e.length;c[a]=d;f.push(a);g.push(b);e.push(l);c=k;for(d=h.length;c!==d;++c)l[c]=new THREE.PropertyBinding(h[c],a,b);return l},unsubscribe_:function(a){var b=this._bindingsIndicesByPath,c=b[a];if(void 0!==c){var d=
this._paths,e=this._parsedPaths,f=this._bindings,g=f.length-1,h=f[g];b[a[g]]=c;f[c]=h;f.pop();e[c]=e[g];e.pop();d[c]=d[g];d.pop()}}};
THREE.AnimationUtils={arraySlice:function(a,b,c){return THREE.AnimationUtils.isTypedArray(a)?new a.constructor(a.subarray(b,c)):a.slice(b,c)},convertArray:function(a,b,c){return!a||!c&&a.constructor===b?a:"number"===typeof b.BYTES_PER_ELEMENT?new b(a):Array.prototype.slice.call(a)},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){for(var b=a.length,c=Array(b),d=0;d!==b;++d)c[d]=d;c.sort(function(b,c){return a[b]-a[c]});return c},sortedArray:function(a,
b,c){for(var d=a.length,e=new a.constructor(d),f=0,g=0;g!==d;++f)for(var h=c[f]*b,k=0;k!==b;++k)e[g++]=a[h+k];return e},flattenJSON:function(a,b,c,d){for(var e=1,f=a[0];void 0!==f&&void 0===f[d];)f=a[e++];if(void 0!==f){var g=f[d];if(void 0!==g)if(Array.isArray(g)){do g=f[d],void 0!==g&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==f)}else if(void 0!==g.toArray){do g=f[d],void 0!==g&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f)}else{do g=f[d],void 0!==g&&(b.push(f.time),
c.push(g)),f=a[e++];while(void 0!==f)}}}};THREE.KeyframeTrack=function(a,b,c,d){if(void 0===a)throw Error("track name is undefined");if(void 0===b||0===b.length)throw Error("no keyframes in track named "+a);this.name=a;this.times=THREE.AnimationUtils.convertArray(b,this.TimeBufferType);this.values=THREE.AnimationUtils.convertArray(c,this.ValueBufferType);this.setInterpolation(d||this.DefaultInterpolation);this.validate();this.optimize()};
THREE.KeyframeTrack.prototype={constructor:THREE.KeyframeTrack,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:THREE.InterpolateLinear,InterpolantFactoryMethodDiscrete:function(a){return new THREE.DiscreteInterpolant(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodLinear:function(a){return new THREE.LinearInterpolant(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:function(a){return new THREE.CubicInterpolant(this.times,
this.values,this.getValueSize(),a)},setInterpolation:function(a){var b;switch(a){case THREE.InterpolateDiscrete:b=this.InterpolantFactoryMethodDiscrete;break;case THREE.InterpolateLinear:b=this.InterpolantFactoryMethodLinear;break;case THREE.InterpolateSmooth:b=this.InterpolantFactoryMethodSmooth}if(void 0===b){b="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(a!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);
else throw Error(b);console.warn(b)}else this.createInterpolant=b},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return THREE.InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return THREE.InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return THREE.InterpolateSmooth}},getValueSize:function(){return this.values.length/this.times.length},shift:function(a){if(0!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]+=a;return this},
scale:function(a){if(1!==a)for(var b=this.times,c=0,d=b.length;c!==d;++c)b[c]*=a;return this},trim:function(a,b){for(var c=this.times,d=c.length,e=0,f=d-1;e!==d&&c[e]<a;)++e;for(;-1!==f&&c[f]>b;)--f;++f;if(0!==e||f!==d)e>=f&&(f=Math.max(f,1),e=f-1),d=this.getValueSize(),this.times=THREE.AnimationUtils.arraySlice(c,e,f),this.values=THREE.AnimationUtils.arraySlice(this.values,e*d,f*d);return this},validate:function(){var a=!0,b=this.getValueSize();0!==b-Math.floor(b)&&(console.error("invalid value size in track",
this),a=!1);var c=this.times,b=this.values,d=c.length;0===d&&(console.error("track is empty",this),a=!1);for(var e=null,f=0;f!==d;f++){var g=c[f];if("number"===typeof g&&isNaN(g)){console.error("time is not a valid number",this,f,g);a=!1;break}if(null!==e&&e>g){console.error("out of order keys",this,f,g,e);a=!1;break}e=g}if(void 0!==b&&THREE.AnimationUtils.isTypedArray(b))for(f=0,c=b.length;f!==c;++f)if(d=b[f],isNaN(d)){console.error("value is not a valid number",this,f,d);a=!1;break}return a},optimize:function(){for(var a=
this.times,b=this.values,c=this.getValueSize(),d=1,e=1,f=a.length-1;e<=f;++e){var g=!1,h=a[e];if(h!==a[e+1]&&(1!==e||h!==h[0]))for(var k=e*c,l=k-c,n=k+c,h=0;h!==c;++h){var p=b[k+h];if(p!==b[l+h]||p!==b[n+h]){g=!0;break}}if(g){if(e!==d)for(a[d]=a[e],g=e*c,k=d*c,h=0;h!==c;++h)b[k+h]=b[g+h];++d}}d!==a.length&&(this.times=THREE.AnimationUtils.arraySlice(a,0,d),this.values=THREE.AnimationUtils.arraySlice(b,0,d*c));return this}};
Object.assign(THREE.KeyframeTrack,{parse:function(a){if(void 0===a.type)throw Error("track type undefined, can not parse");var b=THREE.KeyframeTrack._getTrackTypeForValueTypeName(a.type);if(void 0===a.times){var c=[],d=[];THREE.AnimationUtils.flattenJSON(a.keys,c,d,"value");a.times=c;a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,a.times,a.values,a.interpolation)},toJSON:function(a){var b=a.constructor;if(void 0!==b.toJSON)b=b.toJSON(a);else{var b={name:a.name,times:THREE.AnimationUtils.convertArray(a.times,
Array),values:THREE.AnimationUtils.convertArray(a.values,Array)},c=a.getInterpolation();c!==a.DefaultInterpolation&&(b.interpolation=c)}b.type=a.ValueTypeName;return b},_getTrackTypeForValueTypeName:function(a){switch(a.toLowerCase()){case "scalar":case "double":case "float":case "number":case "integer":return THREE.NumberKeyframeTrack;case "vector":case "vector2":case "vector3":case "vector4":return THREE.VectorKeyframeTrack;case "color":return THREE.ColorKeyframeTrack;case "quaternion":return THREE.QuaternionKeyframeTrack;
case "bool":case "boolean":return THREE.BooleanKeyframeTrack;case "string":return THREE.StringKeyframeTrack}throw Error("Unsupported typeName: "+a);}});THREE.PropertyBinding=function(a,b,c){this.path=b;this.parsedPath=c||THREE.PropertyBinding.parseTrackName(b);this.node=THREE.PropertyBinding.findNode(a,this.parsedPath.nodeName)||a;this.rootNode=a};
THREE.PropertyBinding.prototype={constructor:THREE.PropertyBinding,getValue:function(a,b){this.bind();this.getValue(a,b)},setValue:function(a,b){this.bind();this.setValue(a,b)},bind:function(){var a=this.node,b=this.parsedPath,c=b.objectName,d=b.propertyName,e=b.propertyIndex;a||(this.node=a=THREE.PropertyBinding.findNode(this.rootNode,b.nodeName)||this.rootNode);this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(a){if(c){var f=b.objectIndex;switch(c){case "materials":if(!a.material){console.error("  can not bind to material as node does not have a material",
this);return}if(!a.material.materials){console.error("  can not bind to material.materials as node.material does not have a materials array",this);return}a=a.material.materials;break;case "bones":if(!a.skeleton){console.error("  can not bind to bones as node does not have a skeleton",this);return}a=a.skeleton.bones;for(c=0;c<a.length;c++)if(a[c].name===f){f=c;break}break;default:if(void 0===a[c]){console.error("  can not bind to objectName of node, undefined",this);return}a=a[c]}if(void 0!==f){if(void 0===
a[f]){console.error("  trying to bind to objectIndex of objectName, but is undefined:",this,a);return}a=a[f]}}if(f=a[d]){b=this.Versioning.None;void 0!==a.needsUpdate?(b=this.Versioning.NeedsUpdate,this.targetObject=a):void 0!==a.matrixWorldNeedsUpdate&&(b=this.Versioning.MatrixWorldNeedsUpdate,this.targetObject=a);c=this.BindingType.Direct;if(void 0!==e){if("morphTargetInfluences"===d){if(!a.geometry){console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry",
this);return}if(!a.geometry.morphTargets){console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets",this);return}for(c=0;c<this.node.geometry.morphTargets.length;c++)if(a.geometry.morphTargets[c].name===e){e=c;break}}c=this.BindingType.ArrayElement;this.resolvedProperty=f;this.propertyIndex=e}else void 0!==f.fromArray&&void 0!==f.toArray?(c=this.BindingType.HasFromToArray,this.resolvedProperty=f):void 0!==f.length?(c=this.BindingType.EntireArray,this.resolvedProperty=
f):this.propertyName=d;this.getValue=this.GetterByBindingType[c];this.setValue=this.SetterByBindingTypeAndVersioning[c][b]}else console.error("  trying to update property for track: "+b.nodeName+"."+d+" but it wasn't found.",a)}else console.error("  trying to update node for track: "+this.path+" but it wasn't found.")},unbind:function(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}};
Object.assign(THREE.PropertyBinding.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},_getValue_unbound:THREE.PropertyBinding.prototype.getValue,_setValue_unbound:THREE.PropertyBinding.prototype.setValue,BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(a,b){a[b]=this.node[this.propertyName]},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)a[b++]=
c[d]},function(a,b){a[b]=this.resolvedProperty[this.propertyIndex]},function(a,b){this.resolvedProperty.toArray(a,b)}],SetterByBindingTypeAndVersioning:[[function(a,b){this.node[this.propertyName]=a[b]},function(a,b){this.node[this.propertyName]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.node[this.propertyName]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++]},function(a,b){for(var c=this.resolvedProperty,
d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.needsUpdate=!0},function(a,b){for(var c=this.resolvedProperty,d=0,e=c.length;d!==e;++d)c[d]=a[b++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty[this.propertyIndex]=a[b]},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty[this.propertyIndex]=a[b];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(a,b){this.resolvedProperty.fromArray(a,
b)},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.needsUpdate=!0},function(a,b){this.resolvedProperty.fromArray(a,b);this.targetObject.matrixWorldNeedsUpdate=!0}]]});THREE.PropertyBinding.Composite=function(a,b,c){c=c||THREE.PropertyBinding.parseTrackName(b);this._targetGroup=a;this._bindings=a.subscribe_(b,c)};
THREE.PropertyBinding.Composite.prototype={constructor:THREE.PropertyBinding.Composite,getValue:function(a,b){this.bind();var c=this._bindings[this._targetGroup.nCachedObjects_];void 0!==c&&c.getValue(a,b)},setValue:function(a,b){for(var c=this._bindings,d=this._targetGroup.nCachedObjects_,e=c.length;d!==e;++d)c[d].setValue(a,b)},bind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,c=a.length;b!==c;++b)a[b].bind()},unbind:function(){for(var a=this._bindings,b=this._targetGroup.nCachedObjects_,
c=a.length;b!==c;++b)a[b].unbind()}};THREE.PropertyBinding.create=function(a,b,c){return a instanceof THREE.AnimationObjectGroup?new THREE.PropertyBinding.Composite(a,b,c):new THREE.PropertyBinding(a,b,c)};
THREE.PropertyBinding.parseTrackName=function(a){var b=/^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,c=b.exec(a);if(!c)throw Error("cannot parse trackName at all: "+a);c.index===b.lastIndex&&b.lastIndex++;b={nodeName:c[3],objectName:c[5],objectIndex:c[7],propertyName:c[9],propertyIndex:c[11]};if(null===b.propertyName||0===b.propertyName.length)throw Error("can not parse propertyName from trackName: "+a);return b};
THREE.PropertyBinding.findNode=function(a,b){if(!b||""===b||"root"===b||"."===b||-1===b||b===a.name||b===a.uuid)return a;if(a.skeleton){var c=function(a){for(var c=0;c<a.bones.length;c++){var d=a.bones[c];if(d.name===b)return d}return null}(a.skeleton);if(c)return c}if(a.children){var d=function(a){for(var c=0;c<a.length;c++){var g=a[c];if(g.name===b||g.uuid===b||(g=d(g.children)))return g}return null};if(c=d(a.children))return c}return null};
THREE.PropertyMixer=function(a,b,c){this.binding=a;this.valueSize=c;a=Float64Array;switch(b){case "quaternion":b=this._slerp;break;case "string":case "bool":a=Array;b=this._select;break;default:b=this._lerp}this.buffer=new a(4*c);this._mixBufferRegion=b;this.referenceCount=this.useCount=this.cumulativeWeight=0};
THREE.PropertyMixer.prototype={constructor:THREE.PropertyMixer,accumulate:function(a,b){var c=this.buffer,d=this.valueSize,e=a*d+d,f=this.cumulativeWeight;if(0===f){for(f=0;f!==d;++f)c[e+f]=c[f];f=b}else f+=b,this._mixBufferRegion(c,e,0,b/f,d);this.cumulativeWeight=f},apply:function(a){var b=this.valueSize,c=this.buffer;a=a*b+b;var d=this.cumulativeWeight,e=this.binding;this.cumulativeWeight=0;1>d&&this._mixBufferRegion(c,a,3*b,1-d,b);for(var d=b,f=b+b;d!==f;++d)if(c[d]!==c[d+b]){e.setValue(c,a);
break}},saveOriginalState:function(){var a=this.buffer,b=this.valueSize,c=3*b;this.binding.getValue(a,c);for(var d=b;d!==c;++d)a[d]=a[c+d%b];this.cumulativeWeight=0},restoreOriginalState:function(){this.binding.setValue(this.buffer,3*this.valueSize)},_select:function(a,b,c,d,e){if(.5<=d)for(d=0;d!==e;++d)a[b+d]=a[c+d]},_slerp:function(a,b,c,d,e){THREE.Quaternion.slerpFlat(a,b,a,b,a,c,d)},_lerp:function(a,b,c,d,e){for(var f=1-d,g=0;g!==e;++g){var h=b+g;a[h]=a[h]*f+a[c+g]*d}}};
THREE.BooleanKeyframeTrack=function(a,b,c){THREE.KeyframeTrack.call(this,a,b,c)};THREE.BooleanKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.BooleanKeyframeTrack,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:THREE.InterpolateDiscrete,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});THREE.ColorKeyframeTrack=function(a,b,c,d){THREE.KeyframeTrack.call(this,a,b,c,d)};
THREE.ColorKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.ColorKeyframeTrack,ValueTypeName:"color"});THREE.NumberKeyframeTrack=function(a,b,c,d){THREE.KeyframeTrack.call(this,a,b,c,d)};THREE.NumberKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.NumberKeyframeTrack,ValueTypeName:"number"});THREE.QuaternionKeyframeTrack=function(a,b,c,d){THREE.KeyframeTrack.call(this,a,b,c,d)};
THREE.QuaternionKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.QuaternionKeyframeTrack,ValueTypeName:"quaternion",DefaultInterpolation:THREE.InterpolateLinear,InterpolantFactoryMethodLinear:function(a){return new THREE.QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),a)},InterpolantFactoryMethodSmooth:void 0});THREE.StringKeyframeTrack=function(a,b,c,d){THREE.KeyframeTrack.call(this,a,b,c,d)};
THREE.StringKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.StringKeyframeTrack,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:THREE.InterpolateDiscrete,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});THREE.VectorKeyframeTrack=function(a,b,c,d){THREE.KeyframeTrack.call(this,a,b,c,d)};
THREE.VectorKeyframeTrack.prototype=Object.assign(Object.create(THREE.KeyframeTrack.prototype),{constructor:THREE.VectorKeyframeTrack,ValueTypeName:"vector"});
THREE.Audio=function(a){THREE.Object3D.call(this);this.type="Audio";this.context=a.context;this.source=this.context.createBufferSource();this.source.onended=this.onEnded.bind(this);this.gain=this.context.createGain();this.gain.connect(a.getInput());this.autoplay=!1;this.startTime=0;this.playbackRate=1;this.isPlaying=!1;this.hasPlaybackControl=!0;this.sourceType="empty";this.filters=[]};
THREE.Audio.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Audio,getOutput:function(){return this.gain},setNodeSource:function(a){this.hasPlaybackControl=!1;this.sourceType="audioNode";this.source=a;this.connect();return this},setBuffer:function(a){this.source.buffer=a;this.sourceType="buffer";this.autoplay&&this.play();return this},play:function(){if(!0===this.isPlaying)console.warn("THREE.Audio: Audio is already playing.");else if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");
else{var a=this.context.createBufferSource();a.buffer=this.source.buffer;a.loop=this.source.loop;a.onended=this.source.onended;a.start(0,this.startTime);a.playbackRate.value=this.playbackRate;this.isPlaying=!0;this.source=a;return this.connect()}},pause:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.source.stop(),this.startTime=this.context.currentTime,this},stop:function(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");
else return this.source.stop(),this.startTime=0,this},connect:function(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].connect(this.filters[a]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this},disconnect:function(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(var a=1,b=this.filters.length;a<b;a++)this.filters[a-1].disconnect(this.filters[a]);
this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this},getFilters:function(){return this.filters},setFilters:function(a){a||(a=[]);!0===this.isPlaying?(this.disconnect(),this.filters=a,this.connect()):this.filters=a;return this},getFilter:function(){return this.getFilters()[0]},setFilter:function(a){return this.setFilters(a?[a]:[])},setPlaybackRate:function(a){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");
else return this.playbackRate=a,!0===this.isPlaying&&(this.source.playbackRate.value=this.playbackRate),this},getPlaybackRate:function(){return this.playbackRate},onEnded:function(){this.isPlaying=!1},getLoop:function(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.source.loop},setLoop:function(a){!1===this.hasPlaybackControl?console.warn("THREE.Audio: this Audio has no playback control."):this.source.loop=a},getVolume:function(){return this.gain.gain.value},
setVolume:function(a){this.gain.gain.value=a;return this}});THREE.AudioAnalyser=function(a,b){this.analyser=a.context.createAnalyser();this.analyser.fftSize=void 0!==b?b:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);a.getOutput().connect(this.analyser)};
Object.assign(THREE.AudioAnalyser.prototype,{getFrequencyData:function(){this.analyser.getByteFrequencyData(this.data);return this.data},getAverageFrequency:function(){for(var a=0,b=this.getFrequencyData(),c=0;c<b.length;c++)a+=b[c];return a/b.length}});Object.defineProperty(THREE,"AudioContext",{get:function(){var a;return function(){void 0===a&&(a=new (window.AudioContext||window.webkitAudioContext));return a}}()});
THREE.PositionalAudio=function(a){THREE.Audio.call(this,a);this.panner=this.context.createPanner();this.panner.connect(this.gain)};
THREE.PositionalAudio.prototype=Object.assign(Object.create(THREE.Audio.prototype),{constructor:THREE.PositionalAudio,getOutput:function(){return this.panner},getRefDistance:function(){return this.panner.refDistance},setRefDistance:function(a){this.panner.refDistance=a},getRolloffFactor:function(){return this.panner.rolloffFactor},setRolloffFactor:function(a){this.panner.rolloffFactor=a},getDistanceModel:function(){return this.panner.distanceModel},setDistanceModel:function(a){this.panner.distanceModel=
a},getMaxDistance:function(){return this.panner.maxDistance},setMaxDistance:function(a){this.panner.maxDistance=a},updateMatrixWorld:function(){var a=new THREE.Vector3;return function(b){THREE.Object3D.prototype.updateMatrixWorld.call(this,b);a.setFromMatrixPosition(this.matrixWorld);this.panner.setPosition(a.x,a.y,a.z)}}()});
THREE.AudioListener=function(){THREE.Object3D.call(this);this.type="AudioListener";this.context=THREE.AudioContext;this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null};
THREE.AudioListener.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.AudioListener,getInput:function(){return this.gain},removeFilter:function(){null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null)},getFilter:function(){return this.filter},setFilter:function(a){null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):
this.gain.disconnect(this.context.destination);this.filter=a;this.gain.connect(this.filter);this.filter.connect(this.context.destination)},getMasterVolume:function(){return this.gain.gain.value},setMasterVolume:function(a){this.gain.gain.value=a},updateMatrixWorld:function(){var a=new THREE.Vector3,b=new THREE.Quaternion,c=new THREE.Vector3,d=new THREE.Vector3;return function(e){THREE.Object3D.prototype.updateMatrixWorld.call(this,e);e=this.context.listener;var f=this.up;this.matrixWorld.decompose(a,
b,c);d.set(0,0,-1).applyQuaternion(b);e.setPosition(a.x,a.y,a.z);e.setOrientation(d.x,d.y,d.z,f.x,f.y,f.z)}}()});THREE.Camera=function(){THREE.Object3D.call(this);this.type="Camera";this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.constructor=THREE.Camera;
THREE.Camera.prototype.getWorldDirection=function(){var a=new THREE.Quaternion;return function(b){b=b||new THREE.Vector3;this.getWorldQuaternion(a);return b.set(0,0,-1).applyQuaternion(a)}}();THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();THREE.Camera.prototype.clone=function(){return(new this.constructor).copy(this)};
THREE.Camera.prototype.copy=function(a){THREE.Object3D.prototype.copy.call(this,a);this.matrixWorldInverse.copy(a.matrixWorldInverse);this.projectionMatrix.copy(a.projectionMatrix);return this};
THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);this.type="CubeCamera";var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));
this.add(g);var h=new THREE.PerspectiveCamera(90,1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var k=new THREE.PerspectiveCamera(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new THREE.Vector3(0,0,-1));this.add(k);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){null===this.parent&&this.updateMatrixWorld();var c=this.renderTarget,m=c.texture.generateMipmaps;c.texture.generateMipmaps=
!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.texture.generateMipmaps=m;c.activeCubeFace=5;a.render(b,k,c);a.setRenderTarget(null)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.CubeCamera.prototype.constructor=THREE.CubeCamera;
THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.type="OrthographicCamera";this.zoom=1;this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};
THREE.OrthographicCamera.prototype=Object.assign(Object.create(THREE.Camera.prototype),{constructor:THREE.OrthographicCamera,copy:function(a){THREE.Camera.prototype.copy.call(this,a);this.left=a.left;this.right=a.right;this.top=a.top;this.bottom=a.bottom;this.near=a.near;this.far=a.far;this.zoom=a.zoom;return this},updateProjectionMatrix:function(){var a=(this.right-this.left)/(2*this.zoom),b=(this.top-this.bottom)/(2*this.zoom),c=(this.right+this.left)/2,d=(this.top+this.bottom)/2;this.projectionMatrix.makeOrthographic(c-
a,c+a,d+b,d-b,this.near,this.far)},toJSON:function(a){a=THREE.Object3D.prototype.toJSON.call(this,a);a.object.zoom=this.zoom;a.object.left=this.left;a.object.right=this.right;a.object.top=this.top;a.object.bottom=this.bottom;a.object.near=this.near;a.object.far=this.far;return a}});
THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.type="PerspectiveCamera";this.fov=void 0!==a?a:50;this.zoom=1;this.near=void 0!==c?c:.1;this.far=void 0!==d?d:2E3;this.focus=10;this.aspect=void 0!==b?b:1;this.view=null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype=Object.assign(Object.create(THREE.Camera.prototype),{constructor:THREE.PerspectiveCamera,copy:function(a){THREE.Camera.prototype.copy.call(this,a);this.fov=a.fov;this.zoom=a.zoom;this.near=a.near;this.far=a.far;this.focus=a.focus;this.aspect=a.aspect;this.view=null===a.view?null:Object.assign({},a.view);this.filmGauge=a.filmGauge;this.filmOffset=a.filmOffset;return this},setFocalLength:function(a){a=.5*this.getFilmHeight()/a;this.fov=2*THREE.Math.RAD2DEG*Math.atan(a);
this.updateProjectionMatrix()},getFocalLength:function(){var a=Math.tan(.5*THREE.Math.DEG2RAD*this.fov);return.5*this.getFilmHeight()/a},getEffectiveFOV:function(){return 2*THREE.Math.RAD2DEG*Math.atan(Math.tan(.5*THREE.Math.DEG2RAD*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(a,b,c,d,e,f){this.aspect=a/b;this.view={fullWidth:a,fullHeight:b,offsetX:c,offsetY:d,
width:e,height:f};this.updateProjectionMatrix()},clearViewOffset:function(){this.view=null;this.updateProjectionMatrix()},updateProjectionMatrix:function(){var a=this.near,b=a*Math.tan(.5*THREE.Math.DEG2RAD*this.fov)/this.zoom,c=2*b,d=this.aspect*c,e=-.5*d,f=this.view;if(null!==f)var g=f.fullWidth,h=f.fullHeight,e=e+f.offsetX*d/g,b=b-f.offsetY*c/h,d=f.width/g*d,c=f.height/h*c;f=this.filmOffset;0!==f&&(e+=a*f/this.getFilmWidth());this.projectionMatrix.makeFrustum(e,e+d,b-c,b,a,this.far)},toJSON:function(a){a=
THREE.Object3D.prototype.toJSON.call(this,a);a.object.fov=this.fov;a.object.zoom=this.zoom;a.object.near=this.near;a.object.far=this.far;a.object.focus=this.focus;a.object.aspect=this.aspect;null!==this.view&&(a.object.view=Object.assign({},this.view));a.object.filmGauge=this.filmGauge;a.object.filmOffset=this.filmOffset;return a}});
THREE.StereoCamera=function(){this.type="StereoCamera";this.aspect=1;this.cameraL=new THREE.PerspectiveCamera;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=!1;this.cameraR=new THREE.PerspectiveCamera;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=!1};
Object.assign(THREE.StereoCamera.prototype,{update:function(){var a,b,c,d,e,f=new THREE.Matrix4,g=new THREE.Matrix4;return function(h){if(a!==h.focus||b!==h.fov||c!==h.aspect*this.aspect||d!==h.near||e!==h.far){a=h.focus;b=h.fov;c=h.aspect*this.aspect;d=h.near;e=h.far;var k=h.projectionMatrix.clone(),l=.032*d/a,n=d*Math.tan(THREE.Math.DEG2RAD*b*.5),p,m;g.elements[12]=-.032;f.elements[12]=.032;p=-n*c+l;m=n*c+l;k.elements[0]=2*d/(m-p);k.elements[8]=(m+p)/(m-p);this.cameraL.projectionMatrix.copy(k);
p=-n*c-l;m=n*c-l;k.elements[0]=2*d/(m-p);k.elements[8]=(m+p)/(m-p);this.cameraR.projectionMatrix.copy(k)}this.cameraL.matrixWorld.copy(h.matrixWorld).multiply(g);this.cameraR.matrixWorld.copy(h.matrixWorld).multiply(f)}}()});THREE.Light=function(a,b){THREE.Object3D.call(this);this.type="Light";this.color=new THREE.Color(a);this.intensity=void 0!==b?b:1;this.receiveShadow=void 0};
THREE.Light.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Light,copy:function(a){THREE.Object3D.prototype.copy.call(this,a);this.color.copy(a.color);this.intensity=a.intensity;return this},toJSON:function(a){a=THREE.Object3D.prototype.toJSON.call(this,a);a.object.color=this.color.getHex();a.object.intensity=this.intensity;void 0!==this.groundColor&&(a.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(a.object.distance=this.distance);void 0!==
this.angle&&(a.object.angle=this.angle);void 0!==this.decay&&(a.object.decay=this.decay);void 0!==this.penumbra&&(a.object.penumbra=this.penumbra);return a}});THREE.LightShadow=function(a){this.camera=a;this.bias=0;this.radius=1;this.mapSize=new THREE.Vector2(512,512);this.map=null;this.matrix=new THREE.Matrix4};Object.assign(THREE.LightShadow.prototype,{copy:function(a){this.camera=a.camera.clone();this.bias=a.bias;this.radius=a.radius;this.mapSize.copy(a.mapSize);return this},clone:function(){return(new this.constructor).copy(this)}});
THREE.AmbientLight=function(a,b){THREE.Light.call(this,a,b);this.type="AmbientLight";this.castShadow=void 0};THREE.AmbientLight.prototype=Object.assign(Object.create(THREE.Light.prototype),{constructor:THREE.AmbientLight});THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a,b);this.type="DirectionalLight";this.position.set(0,1,0);this.updateMatrix();this.target=new THREE.Object3D;this.shadow=new THREE.DirectionalLightShadow};
THREE.DirectionalLight.prototype=Object.assign(Object.create(THREE.Light.prototype),{constructor:THREE.DirectionalLight,copy:function(a){THREE.Light.prototype.copy.call(this,a);this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});THREE.DirectionalLightShadow=function(a){THREE.LightShadow.call(this,new THREE.OrthographicCamera(-5,5,5,-5,.5,500))};THREE.DirectionalLightShadow.prototype=Object.assign(Object.create(THREE.LightShadow.prototype),{constructor:THREE.DirectionalLightShadow});
THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a,c);this.type="HemisphereLight";this.castShadow=void 0;this.position.set(0,1,0);this.updateMatrix();this.groundColor=new THREE.Color(b)};THREE.HemisphereLight.prototype=Object.assign(Object.create(THREE.Light.prototype),{constructor:THREE.HemisphereLight,copy:function(a){THREE.Light.prototype.copy.call(this,a);this.groundColor.copy(a.groundColor);return this}});
THREE.PointLight=function(a,b,c,d){THREE.Light.call(this,a,b);this.type="PointLight";Object.defineProperty(this,"power",{get:function(){return 4*this.intensity*Math.PI},set:function(a){this.intensity=a/(4*Math.PI)}});this.distance=void 0!==c?c:0;this.decay=void 0!==d?d:1;this.shadow=new THREE.LightShadow(new THREE.PerspectiveCamera(90,1,.5,500))};
THREE.PointLight.prototype=Object.assign(Object.create(THREE.Light.prototype),{constructor:THREE.PointLight,copy:function(a){THREE.Light.prototype.copy.call(this,a);this.distance=a.distance;this.decay=a.decay;this.shadow=a.shadow.clone();return this}});
THREE.SpotLight=function(a,b,c,d,e,f){THREE.Light.call(this,a,b);this.type="SpotLight";this.position.set(0,1,0);this.updateMatrix();this.target=new THREE.Object3D;Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(a){this.intensity=a/Math.PI}});this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.penumbra=void 0!==e?e:0;this.decay=void 0!==f?f:1;this.shadow=new THREE.SpotLightShadow};
THREE.SpotLight.prototype=Object.assign(Object.create(THREE.Light.prototype),{constructor:THREE.SpotLight,copy:function(a){THREE.Light.prototype.copy.call(this,a);this.distance=a.distance;this.angle=a.angle;this.penumbra=a.penumbra;this.decay=a.decay;this.target=a.target.clone();this.shadow=a.shadow.clone();return this}});THREE.SpotLightShadow=function(){THREE.LightShadow.call(this,new THREE.PerspectiveCamera(50,1,.5,500))};
THREE.SpotLightShadow.prototype=Object.assign(Object.create(THREE.LightShadow.prototype),{constructor:THREE.SpotLightShadow,update:function(a){var b=2*THREE.Math.RAD2DEG*a.angle,c=this.mapSize.width/this.mapSize.height;a=a.distance||500;var d=this.camera;if(b!==d.fov||c!==d.aspect||a!==d.far)d.fov=b,d.aspect=c,d.far=a,d.updateProjectionMatrix()}});THREE.AudioLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.AudioLoader.prototype={constructor:THREE.AudioLoader,load:function(a,b,c,d){var e=new THREE.XHRLoader(this.manager);e.setResponseType("arraybuffer");e.load(a,function(a){THREE.AudioContext.decodeAudioData(a,function(a){b(a)})},c,d)}};THREE.Cache={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};
THREE.Loader=function(){this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};
THREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,extractUrlBase:function(a){a=a.split("/");if(1===a.length)return"./";a.pop();return a.join("/")+"/"},initMaterials:function(a,b,c){for(var d=[],e=0;e<a.length;++e)d[e]=this.createMaterial(a[e],b,c);return d},createMaterial:function(){var a,b,c;return function(d,e,f){function g(a,c,d,g,k){a=e+a;var l=THREE.Loader.Handlers.get(a);null!==l?a=l.load(a):(b.setCrossOrigin(f),a=b.load(a));void 0!==c&&(a.repeat.fromArray(c),1!==c[0]&&(a.wrapS=
THREE.RepeatWrapping),1!==c[1]&&(a.wrapT=THREE.RepeatWrapping));void 0!==d&&a.offset.fromArray(d);void 0!==g&&("repeat"===g[0]&&(a.wrapS=THREE.RepeatWrapping),"mirror"===g[0]&&(a.wrapS=THREE.MirroredRepeatWrapping),"repeat"===g[1]&&(a.wrapT=THREE.RepeatWrapping),"mirror"===g[1]&&(a.wrapT=THREE.MirroredRepeatWrapping));void 0!==k&&(a.anisotropy=k);c=THREE.Math.generateUUID();h[c]=a;return c}void 0===a&&(a=new THREE.Color);void 0===b&&(b=new THREE.TextureLoader);void 0===c&&(c=new THREE.MaterialLoader);
var h={},k={uuid:THREE.Math.generateUUID(),type:"MeshLambertMaterial"},l;for(l in d){var n=d[l];switch(l){case "DbgColor":case "DbgIndex":case "opticalDensity":case "illumination":break;case "DbgName":k.name=n;break;case "blending":k.blending=THREE[n];break;case "colorAmbient":case "mapAmbient":console.warn("THREE.Loader.createMaterial:",l,"is no longer supported.");break;case "colorDiffuse":k.color=a.fromArray(n).getHex();break;case "colorSpecular":k.specular=a.fromArray(n).getHex();break;case "colorEmissive":k.emissive=
a.fromArray(n).getHex();break;case "specularCoef":k.shininess=n;break;case "shading":"basic"===n.toLowerCase()&&(k.type="MeshBasicMaterial");"phong"===n.toLowerCase()&&(k.type="MeshPhongMaterial");break;case "mapDiffuse":k.map=g(n,d.mapDiffuseRepeat,d.mapDiffuseOffset,d.mapDiffuseWrap,d.mapDiffuseAnisotropy);break;case "mapDiffuseRepeat":case "mapDiffuseOffset":case "mapDiffuseWrap":case "mapDiffuseAnisotropy":break;case "mapLight":k.lightMap=g(n,d.mapLightRepeat,d.mapLightOffset,d.mapLightWrap,d.mapLightAnisotropy);
break;case "mapLightRepeat":case "mapLightOffset":case "mapLightWrap":case "mapLightAnisotropy":break;case "mapAO":k.aoMap=g(n,d.mapAORepeat,d.mapAOOffset,d.mapAOWrap,d.mapAOAnisotropy);break;case "mapAORepeat":case "mapAOOffset":case "mapAOWrap":case "mapAOAnisotropy":break;case "mapBump":k.bumpMap=g(n,d.mapBumpRepeat,d.mapBumpOffset,d.mapBumpWrap,d.mapBumpAnisotropy);break;case "mapBumpScale":k.bumpScale=n;break;case "mapBumpRepeat":case "mapBumpOffset":case "mapBumpWrap":case "mapBumpAnisotropy":break;
case "mapNormal":k.normalMap=g(n,d.mapNormalRepeat,d.mapNormalOffset,d.mapNormalWrap,d.mapNormalAnisotropy);break;case "mapNormalFactor":k.normalScale=[n,n];break;case "mapNormalRepeat":case "mapNormalOffset":case "mapNormalWrap":case "mapNormalAnisotropy":break;case "mapSpecular":k.specularMap=g(n,d.mapSpecularRepeat,d.mapSpecularOffset,d.mapSpecularWrap,d.mapSpecularAnisotropy);break;case "mapSpecularRepeat":case "mapSpecularOffset":case "mapSpecularWrap":case "mapSpecularAnisotropy":break;case "mapAlpha":k.alphaMap=
g(n,d.mapAlphaRepeat,d.mapAlphaOffset,d.mapAlphaWrap,d.mapAlphaAnisotropy);break;case "mapAlphaRepeat":case "mapAlphaOffset":case "mapAlphaWrap":case "mapAlphaAnisotropy":break;case "flipSided":k.side=THREE.BackSide;break;case "doubleSided":k.side=THREE.DoubleSide;break;case "transparency":console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");k.opacity=n;break;case "depthTest":case "depthWrite":case "colorWrite":case "opacity":case "reflectivity":case "transparent":case "visible":case "wireframe":k[l]=
n;break;case "vertexColors":!0===n&&(k.vertexColors=THREE.VertexColors);"face"===n&&(k.vertexColors=THREE.FaceColors);break;default:console.error("THREE.Loader.createMaterial: Unsupported",l,n)}}"MeshBasicMaterial"===k.type&&delete k.emissive;"MeshPhongMaterial"!==k.type&&delete k.specular;1>k.opacity&&(k.transparent=!0);c.setTextures(h);return c.parse(k)}}()};
THREE.Loader.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,b)},get:function(a){for(var b=this.handlers,c=0,d=b.length;c<d;c+=2){var e=b[c+1];if(b[c].test(a))return e}return null}};THREE.XHRLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){void 0!==this.path&&(a=this.path+a);var e=this,f=THREE.Cache.get(a);if(void 0!==f)return b&&setTimeout(function(){b(f)},0),f;var g=new XMLHttpRequest;g.overrideMimeType("text/plain");g.open("GET",a,!0);g.addEventListener("load",function(c){var f=c.target.response;THREE.Cache.add(a,f);200===this.status?(b&&b(f),e.manager.itemEnd(a)):0===this.status?(console.warn("THREE.XHRLoader: HTTP Status 0 received."),b&&b(f),e.manager.itemEnd(a)):
(d&&d(c),e.manager.itemError(a))},!1);void 0!==c&&g.addEventListener("progress",function(a){c(a)},!1);g.addEventListener("error",function(b){d&&d(b);e.manager.itemError(a)},!1);void 0!==this.responseType&&(g.responseType=this.responseType);void 0!==this.withCredentials&&(g.withCredentials=this.withCredentials);g.send(null);e.manager.itemStart(a);return g},setPath:function(a){this.path=a},setResponseType:function(a){this.responseType=a},setWithCredentials:function(a){this.withCredentials=a}};
THREE.FontLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.FontLoader.prototype={constructor:THREE.FontLoader,load:function(a,b,c,d){var e=this;(new THREE.XHRLoader(this.manager)).load(a,function(a){var c;try{c=JSON.parse(a)}catch(d){console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),c=JSON.parse(a.substring(65,a.length-2))}a=e.parse(c);b&&b(a)},c,d)},parse:function(a){return new THREE.Font(a)}};
THREE.ImageLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){void 0!==this.path&&(a=this.path+a);var e=this,f=THREE.Cache.get(a);if(void 0!==f)return e.manager.itemStart(a),b?setTimeout(function(){b(f);e.manager.itemEnd(a)},0):e.manager.itemEnd(a),f;var g=document.createElement("img");g.addEventListener("load",function(c){THREE.Cache.add(a,this);b&&b(this);e.manager.itemEnd(a)},!1);void 0!==c&&g.addEventListener("progress",function(a){c(a)},!1);g.addEventListener("error",function(b){d&&
d(b);e.manager.itemError(a)},!1);void 0!==this.crossOrigin&&(g.crossOrigin=this.crossOrigin);e.manager.itemStart(a);g.src=a;return g},setCrossOrigin:function(a){this.crossOrigin=a},setPath:function(a){this.path=a}};THREE.JSONLoader=function(a){"boolean"===typeof a&&(console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."),a=void 0);this.manager=void 0!==a?a:THREE.DefaultLoadingManager;this.withCredentials=!1};
THREE.JSONLoader.prototype={constructor:THREE.JSONLoader,get statusDomElement(){void 0===this._statusDomElement&&(this._statusDomElement=document.createElement("div"));console.warn("THREE.JSONLoader: .statusDomElement has been removed.");return this._statusDomElement},load:function(a,b,c,d){var e=this,f=this.texturePath&&"string"===typeof this.texturePath?this.texturePath:THREE.Loader.prototype.extractUrlBase(a),g=new THREE.XHRLoader(this.manager);g.setWithCredentials(this.withCredentials);g.load(a,
function(c){c=JSON.parse(c);var d=c.metadata;if(void 0!==d&&(d=d.type,void 0!==d)){if("object"===d.toLowerCase()){console.error("THREE.JSONLoader: "+a+" should be loaded with THREE.ObjectLoader instead.");return}if("scene"===d.toLowerCase()){console.error("THREE.JSONLoader: "+a+" should be loaded with THREE.SceneLoader instead.");return}}c=e.parse(c,f);b(c.geometry,c.materials)},c,d)},setTexturePath:function(a){this.texturePath=a},parse:function(a,b){var c=new THREE.Geometry,d=void 0!==a.scale?1/
a.scale:1;(function(b){var d,g,h,k,l,n,p,m,q,r,s,u,x,v=a.faces;n=a.vertices;var C=a.normals,w=a.colors,D=0;if(void 0!==a.uvs){for(d=0;d<a.uvs.length;d++)a.uvs[d].length&&D++;for(d=0;d<D;d++)c.faceVertexUvs[d]=[]}k=0;for(l=n.length;k<l;)d=new THREE.Vector3,d.x=n[k++]*b,d.y=n[k++]*b,d.z=n[k++]*b,c.vertices.push(d);k=0;for(l=v.length;k<l;)if(b=v[k++],q=b&1,h=b&2,d=b&8,p=b&16,r=b&32,n=b&64,b&=128,q){q=new THREE.Face3;q.a=v[k];q.b=v[k+1];q.c=v[k+3];s=new THREE.Face3;s.a=v[k+1];s.b=v[k+2];s.c=v[k+3];k+=
4;h&&(h=v[k++],q.materialIndex=h,s.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<D;d++)for(u=a.uvs[d],c.faceVertexUvs[d][h]=[],c.faceVertexUvs[d][h+1]=[],g=0;4>g;g++)m=v[k++],x=u[2*m],m=u[2*m+1],x=new THREE.Vector2(x,m),2!==g&&c.faceVertexUvs[d][h].push(x),0!==g&&c.faceVertexUvs[d][h+1].push(x);p&&(p=3*v[k++],q.normal.set(C[p++],C[p++],C[p]),s.normal.copy(q.normal));if(r)for(d=0;4>d;d++)p=3*v[k++],r=new THREE.Vector3(C[p++],C[p++],C[p]),2!==d&&q.vertexNormals.push(r),0!==d&&s.vertexNormals.push(r);
n&&(n=v[k++],n=w[n],q.color.setHex(n),s.color.setHex(n));if(b)for(d=0;4>d;d++)n=v[k++],n=w[n],2!==d&&q.vertexColors.push(new THREE.Color(n)),0!==d&&s.vertexColors.push(new THREE.Color(n));c.faces.push(q);c.faces.push(s)}else{q=new THREE.Face3;q.a=v[k++];q.b=v[k++];q.c=v[k++];h&&(h=v[k++],q.materialIndex=h);h=c.faces.length;if(d)for(d=0;d<D;d++)for(u=a.uvs[d],c.faceVertexUvs[d][h]=[],g=0;3>g;g++)m=v[k++],x=u[2*m],m=u[2*m+1],x=new THREE.Vector2(x,m),c.faceVertexUvs[d][h].push(x);p&&(p=3*v[k++],q.normal.set(C[p++],
C[p++],C[p]));if(r)for(d=0;3>d;d++)p=3*v[k++],r=new THREE.Vector3(C[p++],C[p++],C[p]),q.vertexNormals.push(r);n&&(n=v[k++],q.color.setHex(w[n]));if(b)for(d=0;3>d;d++)n=v[k++],q.vertexColors.push(new THREE.Color(w[n]));c.faces.push(q)}})(d);(function(){var b=void 0!==a.influencesPerVertex?a.influencesPerVertex:2;if(a.skinWeights)for(var d=0,g=a.skinWeights.length;d<g;d+=b)c.skinWeights.push(new THREE.Vector4(a.skinWeights[d],1<b?a.skinWeights[d+1]:0,2<b?a.skinWeights[d+2]:0,3<b?a.skinWeights[d+3]:
0));if(a.skinIndices)for(d=0,g=a.skinIndices.length;d<g;d+=b)c.skinIndices.push(new THREE.Vector4(a.skinIndices[d],1<b?a.skinIndices[d+1]:0,2<b?a.skinIndices[d+2]:0,3<b?a.skinIndices[d+3]:0));c.bones=a.bones;c.bones&&0<c.bones.length&&(c.skinWeights.length!==c.skinIndices.length||c.skinIndices.length!==c.vertices.length)&&console.warn("When skinning, number of vertices ("+c.vertices.length+"), skinIndices ("+c.skinIndices.length+"), and skinWeights ("+c.skinWeights.length+") should match.")})();(function(b){if(void 0!==
a.morphTargets)for(var d=0,g=a.morphTargets.length;d<g;d++){c.morphTargets[d]={};c.morphTargets[d].name=a.morphTargets[d].name;c.morphTargets[d].vertices=[];for(var h=c.morphTargets[d].vertices,k=a.morphTargets[d].vertices,l=0,n=k.length;l<n;l+=3){var p=new THREE.Vector3;p.x=k[l]*b;p.y=k[l+1]*b;p.z=k[l+2]*b;h.push(p)}}if(void 0!==a.morphColors&&0<a.morphColors.length)for(console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'),b=c.faces,h=a.morphColors[0].colors,
d=0,g=b.length;d<g;d++)b[d].color.fromArray(h,3*d)})(d);(function(){var b=[],d=[];void 0!==a.animation&&d.push(a.animation);void 0!==a.animations&&(a.animations.length?d=d.concat(a.animations):d.push(a.animations));for(var g=0;g<d.length;g++){var h=THREE.AnimationClip.parseAnimation(d[g],c.bones);h&&b.push(h)}c.morphTargets&&(d=THREE.AnimationClip.CreateClipsFromMorphTargetSequences(c.morphTargets,10),b=b.concat(d));0<b.length&&(c.animations=b)})();c.computeFaceNormals();c.computeBoundingSphere();
if(void 0===a.materials||0===a.materials.length)return{geometry:c};d=THREE.Loader.prototype.initMaterials(a.materials,b,this.crossOrigin);return{geometry:c,materials:d}}};
THREE.LoadingManager=function(a,b,c){var d=this,e=!1,f=0,g=0;this.onStart=void 0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){g++;if(!1===e&&void 0!==d.onStart)d.onStart(a,f,g);e=!0};this.itemEnd=function(a){f++;if(void 0!==d.onProgress)d.onProgress(a,f,g);if(f===g&&(e=!1,void 0!==d.onLoad))d.onLoad()};this.itemError=function(a){if(void 0!==d.onError)d.onError(a)}};THREE.DefaultLoadingManager=new THREE.LoadingManager;
THREE.BufferGeometryLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.BufferGeometryLoader.prototype={constructor:THREE.BufferGeometryLoader,load:function(a,b,c,d){var e=this;(new THREE.XHRLoader(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},parse:function(a){var b=new THREE.BufferGeometry,c=a.data.index,d={Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};void 0!==c&&(c=
new d[c.type](c.array),b.setIndex(new THREE.BufferAttribute(c,1)));var e=a.data.attributes,f;for(f in e){var g=e[f],c=new d[g.type](g.array);b.addAttribute(f,new THREE.BufferAttribute(c,g.itemSize,g.normalized))}d=a.data.groups||a.data.drawcalls||a.data.offsets;if(void 0!==d)for(f=0,c=d.length;f!==c;++f)e=d[f],b.addGroup(e.start,e.count,e.materialIndex);a=a.data.boundingSphere;void 0!==a&&(d=new THREE.Vector3,void 0!==a.center&&d.fromArray(a.center),b.boundingSphere=new THREE.Sphere(d,a.radius));
return b}};THREE.MaterialLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager;this.textures={}};
THREE.MaterialLoader.prototype={constructor:THREE.MaterialLoader,load:function(a,b,c,d){var e=this;(new THREE.XHRLoader(e.manager)).load(a,function(a){b(e.parse(JSON.parse(a)))},c,d)},setTextures:function(a){this.textures=a},getTexture:function(a){var b=this.textures;void 0===b[a]&&console.warn("THREE.MaterialLoader: Undefined texture",a);return b[a]},parse:function(a){var b=new THREE[a.type];void 0!==a.uuid&&(b.uuid=a.uuid);void 0!==a.name&&(b.name=a.name);void 0!==a.color&&b.color.setHex(a.color);
void 0!==a.roughness&&(b.roughness=a.roughness);void 0!==a.metalness&&(b.metalness=a.metalness);void 0!==a.emissive&&b.emissive.setHex(a.emissive);void 0!==a.specular&&b.specular.setHex(a.specular);void 0!==a.shininess&&(b.shininess=a.shininess);void 0!==a.uniforms&&(b.uniforms=a.uniforms);void 0!==a.vertexShader&&(b.vertexShader=a.vertexShader);void 0!==a.fragmentShader&&(b.fragmentShader=a.fragmentShader);void 0!==a.vertexColors&&(b.vertexColors=a.vertexColors);void 0!==a.shading&&(b.shading=a.shading);
void 0!==a.blending&&(b.blending=a.blending);void 0!==a.side&&(b.side=a.side);void 0!==a.opacity&&(b.opacity=a.opacity);void 0!==a.transparent&&(b.transparent=a.transparent);void 0!==a.alphaTest&&(b.alphaTest=a.alphaTest);void 0!==a.depthTest&&(b.depthTest=a.depthTest);void 0!==a.depthWrite&&(b.depthWrite=a.depthWrite);void 0!==a.colorWrite&&(b.colorWrite=a.colorWrite);void 0!==a.wireframe&&(b.wireframe=a.wireframe);void 0!==a.wireframeLinewidth&&(b.wireframeLinewidth=a.wireframeLinewidth);void 0!==
a.size&&(b.size=a.size);void 0!==a.sizeAttenuation&&(b.sizeAttenuation=a.sizeAttenuation);void 0!==a.map&&(b.map=this.getTexture(a.map));void 0!==a.alphaMap&&(b.alphaMap=this.getTexture(a.alphaMap),b.transparent=!0);void 0!==a.bumpMap&&(b.bumpMap=this.getTexture(a.bumpMap));void 0!==a.bumpScale&&(b.bumpScale=a.bumpScale);void 0!==a.normalMap&&(b.normalMap=this.getTexture(a.normalMap));if(void 0!==a.normalScale){var c=a.normalScale;!1===Array.isArray(c)&&(c=[c,c]);b.normalScale=(new THREE.Vector2).fromArray(c)}void 0!==
a.displacementMap&&(b.displacementMap=this.getTexture(a.displacementMap));void 0!==a.displacementScale&&(b.displacementScale=a.displacementScale);void 0!==a.displacementBias&&(b.displacementBias=a.displacementBias);void 0!==a.roughnessMap&&(b.roughnessMap=this.getTexture(a.roughnessMap));void 0!==a.metalnessMap&&(b.metalnessMap=this.getTexture(a.metalnessMap));void 0!==a.emissiveMap&&(b.emissiveMap=this.getTexture(a.emissiveMap));void 0!==a.emissiveIntensity&&(b.emissiveIntensity=a.emissiveIntensity);
void 0!==a.specularMap&&(b.specularMap=this.getTexture(a.specularMap));void 0!==a.envMap&&(b.envMap=this.getTexture(a.envMap),b.combine=THREE.MultiplyOperation);a.reflectivity&&(b.reflectivity=a.reflectivity);void 0!==a.lightMap&&(b.lightMap=this.getTexture(a.lightMap));void 0!==a.lightMapIntensity&&(b.lightMapIntensity=a.lightMapIntensity);void 0!==a.aoMap&&(b.aoMap=this.getTexture(a.aoMap));void 0!==a.aoMapIntensity&&(b.aoMapIntensity=a.aoMapIntensity);if(void 0!==a.materials)for(var c=0,d=a.materials.length;c<
d;c++)b.materials.push(this.parse(a.materials[c]));return b}};THREE.ObjectLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager;this.texturePath=""};
THREE.ObjectLoader.prototype={constructor:THREE.ObjectLoader,load:function(a,b,c,d){""===this.texturePath&&(this.texturePath=a.substring(0,a.lastIndexOf("/")+1));var e=this;(new THREE.XHRLoader(e.manager)).load(a,function(a){e.parse(JSON.parse(a),b)},c,d)},setTexturePath:function(a){this.texturePath=a},setCrossOrigin:function(a){this.crossOrigin=a},parse:function(a,b){var c=this.parseGeometries(a.geometries),d=this.parseImages(a.images,function(){void 0!==b&&b(e)}),d=this.parseTextures(a.textures,
d),d=this.parseMaterials(a.materials,d),e=this.parseObject(a.object,c,d);a.animations&&(e.animations=this.parseAnimations(a.animations));void 0!==a.images&&0!==a.images.length||void 0===b||b(e);return e},parseGeometries:function(a){var b={};if(void 0!==a)for(var c=new THREE.JSONLoader,d=new THREE.BufferGeometryLoader,e=0,f=a.length;e<f;e++){var g,h=a[e];switch(h.type){case "PlaneGeometry":case "PlaneBufferGeometry":g=new THREE[h.type](h.width,h.height,h.widthSegments,h.heightSegments);break;case "BoxGeometry":case "BoxBufferGeometry":case "CubeGeometry":g=
new THREE[h.type](h.width,h.height,h.depth,h.widthSegments,h.heightSegments,h.depthSegments);break;case "CircleGeometry":case "CircleBufferGeometry":g=new THREE[h.type](h.radius,h.segments,h.thetaStart,h.thetaLength);break;case "CylinderGeometry":case "CylinderBufferGeometry":g=new THREE[h.type](h.radiusTop,h.radiusBottom,h.height,h.radialSegments,h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case "ConeGeometry":case "ConeBufferGeometry":g=new THREE[h.type](h.radius,h.height,h.radialSegments,
h.heightSegments,h.openEnded,h.thetaStart,h.thetaLength);break;case "SphereGeometry":case "SphereBufferGeometry":g=new THREE[h.type](h.radius,h.widthSegments,h.heightSegments,h.phiStart,h.phiLength,h.thetaStart,h.thetaLength);break;case "DodecahedronGeometry":case "IcosahedronGeometry":case "OctahedronGeometry":case "TetrahedronGeometry":g=new THREE[h.type](h.radius,h.detail);break;case "RingGeometry":case "RingBufferGeometry":g=new THREE[h.type](h.innerRadius,h.outerRadius,h.thetaSegments,h.phiSegments,
h.thetaStart,h.thetaLength);break;case "TorusGeometry":case "TorusBufferGeometry":g=new THREE[h.type](h.radius,h.tube,h.radialSegments,h.tubularSegments,h.arc);break;case "TorusKnotGeometry":case "TorusKnotBufferGeometry":g=new THREE[h.type](h.radius,h.tube,h.tubularSegments,h.radialSegments,h.p,h.q);break;case "LatheGeometry":case "LatheBufferGeometry":g=new THREE[h.type](h.points,h.segments,h.phiStart,h.phiLength);break;case "BufferGeometry":g=d.parse(h);break;case "Geometry":g=c.parse(h.data,this.texturePath).geometry;
break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+h.type+'"');continue}g.uuid=h.uuid;void 0!==h.name&&(g.name=h.name);b[h.uuid]=g}return b},parseMaterials:function(a,b){var c={};if(void 0!==a){var d=new THREE.MaterialLoader;d.setTextures(b);for(var e=0,f=a.length;e<f;e++){var g=d.parse(a[e]);c[g.uuid]=g}}return c},parseAnimations:function(a){for(var b=[],c=0;c<a.length;c++){var d=THREE.AnimationClip.parse(a[c]);b.push(d)}return b},parseImages:function(a,b){function c(a){d.manager.itemStart(a);
return g.load(a,function(){d.manager.itemEnd(a)})}var d=this,e={};if(void 0!==a&&0<a.length){var f=new THREE.LoadingManager(b),g=new THREE.ImageLoader(f);g.setCrossOrigin(this.crossOrigin);for(var f=0,h=a.length;f<h;f++){var k=a[f],l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(k.url)?k.url:d.texturePath+k.url;e[k.uuid]=c(l)}}return e},parseTextures:function(a,b){function c(a){if("number"===typeof a)return a;console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",a);return THREE[a]}
var d={};if(void 0!==a)for(var e=0,f=a.length;e<f;e++){var g=a[e];void 0===g.image&&console.warn('THREE.ObjectLoader: No "image" specified for',g.uuid);void 0===b[g.image]&&console.warn("THREE.ObjectLoader: Undefined image",g.image);var h=new THREE.Texture(b[g.image]);h.needsUpdate=!0;h.uuid=g.uuid;void 0!==g.name&&(h.name=g.name);void 0!==g.mapping&&(h.mapping=c(g.mapping));void 0!==g.offset&&(h.offset=new THREE.Vector2(g.offset[0],g.offset[1]));void 0!==g.repeat&&(h.repeat=new THREE.Vector2(g.repeat[0],
g.repeat[1]));void 0!==g.minFilter&&(h.minFilter=c(g.minFilter));void 0!==g.magFilter&&(h.magFilter=c(g.magFilter));void 0!==g.anisotropy&&(h.anisotropy=g.anisotropy);Array.isArray(g.wrap)&&(h.wrapS=c(g.wrap[0]),h.wrapT=c(g.wrap[1]));d[g.uuid]=h}return d},parseObject:function(){var a=new THREE.Matrix4;return function(b,c,d){function e(a){void 0===c[a]&&console.warn("THREE.ObjectLoader: Undefined geometry",a);return c[a]}function f(a){if(void 0!==a)return void 0===d[a]&&console.warn("THREE.ObjectLoader: Undefined material",
a),d[a]}var g;switch(b.type){case "Scene":g=new THREE.Scene;break;case "PerspectiveCamera":g=new THREE.PerspectiveCamera(b.fov,b.aspect,b.near,b.far);void 0!==b.focus&&(g.focus=b.focus);void 0!==b.zoom&&(g.zoom=b.zoom);void 0!==b.filmGauge&&(g.filmGauge=b.filmGauge);void 0!==b.filmOffset&&(g.filmOffset=b.filmOffset);void 0!==b.view&&(g.view=Object.assign({},b.view));break;case "OrthographicCamera":g=new THREE.OrthographicCamera(b.left,b.right,b.top,b.bottom,b.near,b.far);break;case "AmbientLight":g=
new THREE.AmbientLight(b.color,b.intensity);break;case "DirectionalLight":g=new THREE.DirectionalLight(b.color,b.intensity);break;case "PointLight":g=new THREE.PointLight(b.color,b.intensity,b.distance,b.decay);break;case "SpotLight":g=new THREE.SpotLight(b.color,b.intensity,b.distance,b.angle,b.penumbra,b.decay);break;case "HemisphereLight":g=new THREE.HemisphereLight(b.color,b.groundColor,b.intensity);break;case "Mesh":g=e(b.geometry);var h=f(b.material);g=g.bones&&0<g.bones.length?new THREE.SkinnedMesh(g,
h):new THREE.Mesh(g,h);break;case "LOD":g=new THREE.LOD;break;case "Line":g=new THREE.Line(e(b.geometry),f(b.material),b.mode);break;case "PointCloud":case "Points":g=new THREE.Points(e(b.geometry),f(b.material));break;case "Sprite":g=new THREE.Sprite(f(b.material));break;case "Group":g=new THREE.Group;break;default:g=new THREE.Object3D}g.uuid=b.uuid;void 0!==b.name&&(g.name=b.name);void 0!==b.matrix?(a.fromArray(b.matrix),a.decompose(g.position,g.quaternion,g.scale)):(void 0!==b.position&&g.position.fromArray(b.position),
void 0!==b.rotation&&g.rotation.fromArray(b.rotation),void 0!==b.scale&&g.scale.fromArray(b.scale));void 0!==b.castShadow&&(g.castShadow=b.castShadow);void 0!==b.receiveShadow&&(g.receiveShadow=b.receiveShadow);void 0!==b.visible&&(g.visible=b.visible);void 0!==b.userData&&(g.userData=b.userData);if(void 0!==b.children)for(var k in b.children)g.add(this.parseObject(b.children[k],c,d));if("LOD"===b.type)for(b=b.levels,h=0;h<b.length;h++){var l=b[h];k=g.getObjectByProperty("uuid",l.object);void 0!==
k&&g.addLevel(k,l.distance)}return g}}()};THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b,c,d){var e=new THREE.Texture,f=new THREE.ImageLoader(this.manager);f.setCrossOrigin(this.crossOrigin);f.setPath(this.path);f.load(a,function(a){e.image=a;e.needsUpdate=!0;void 0!==b&&b(e)},c,d);return e},setCrossOrigin:function(a){this.crossOrigin=a},setPath:function(a){this.path=a}};
THREE.CubeTextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.CubeTextureLoader.prototype={constructor:THREE.CubeTextureLoader,load:function(a,b,c,d){function e(c){g.load(a[c],function(a){f.images[c]=a;h++;6===h&&(f.needsUpdate=!0,b&&b(f))},void 0,d)}var f=new THREE.CubeTexture,g=new THREE.ImageLoader(this.manager);g.setCrossOrigin(this.crossOrigin);g.setPath(this.path);var h=0;for(c=0;c<a.length;++c)e(c);return f},setCrossOrigin:function(a){this.crossOrigin=a},setPath:function(a){this.path=a}};
THREE.DataTextureLoader=THREE.BinaryTextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager;this._parser=null};
THREE.BinaryTextureLoader.prototype={constructor:THREE.BinaryTextureLoader,load:function(a,b,c,d){var e=this,f=new THREE.DataTexture,g=new THREE.XHRLoader(this.manager);g.setResponseType("arraybuffer");g.load(a,function(a){if(a=e._parser(a))void 0!==a.image?f.image=a.image:void 0!==a.data&&(f.image.width=a.width,f.image.height=a.height,f.image.data=a.data),f.wrapS=void 0!==a.wrapS?a.wrapS:THREE.ClampToEdgeWrapping,f.wrapT=void 0!==a.wrapT?a.wrapT:THREE.ClampToEdgeWrapping,f.magFilter=void 0!==a.magFilter?
a.magFilter:THREE.LinearFilter,f.minFilter=void 0!==a.minFilter?a.minFilter:THREE.LinearMipMapLinearFilter,f.anisotropy=void 0!==a.anisotropy?a.anisotropy:1,void 0!==a.format&&(f.format=a.format),void 0!==a.type&&(f.type=a.type),void 0!==a.mipmaps&&(f.mipmaps=a.mipmaps),1===a.mipmapCount&&(f.minFilter=THREE.LinearFilter),f.needsUpdate=!0,b&&b(f,a)},c,d);return f}};THREE.CompressedTextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager;this._parser=null};
THREE.CompressedTextureLoader.prototype={constructor:THREE.CompressedTextureLoader,load:function(a,b,c,d){function e(e){k.load(a[e],function(a){a=f._parser(a,!0);g[e]={width:a.width,height:a.height,format:a.format,mipmaps:a.mipmaps};l+=1;6===l&&(1===a.mipmapCount&&(h.minFilter=THREE.LinearFilter),h.format=a.format,h.needsUpdate=!0,b&&b(h))},c,d)}var f=this,g=[],h=new THREE.CompressedTexture;h.image=g;var k=new THREE.XHRLoader(this.manager);k.setPath(this.path);k.setResponseType("arraybuffer");if(Array.isArray(a))for(var l=
0,n=0,p=a.length;n<p;++n)e(n);else k.load(a,function(a){a=f._parser(a,!0);if(a.isCubemap)for(var c=a.mipmaps.length/a.mipmapCount,d=0;d<c;d++){g[d]={mipmaps:[]};for(var e=0;e<a.mipmapCount;e++)g[d].mipmaps.push(a.mipmaps[d*a.mipmapCount+e]),g[d].format=a.format,g[d].width=a.width,g[d].height=a.height}else h.image.width=a.width,h.image.height=a.height,h.mipmaps=a.mipmaps;1===a.mipmapCount&&(h.minFilter=THREE.LinearFilter);h.format=a.format;h.needsUpdate=!0;b&&b(h)},c,d);return h},setPath:function(a){this.path=
a}};
THREE.Material=function(){Object.defineProperty(this,"id",{value:THREE.MaterialIdCount++});this.uuid=THREE.Math.generateUUID();this.name="";this.type="Material";this.lights=this.fog=!0;this.blending=THREE.NormalBlending;this.side=THREE.FrontSide;this.shading=THREE.SmoothShading;this.vertexColors=THREE.NoColors;this.opacity=1;this.transparent=!1;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.blendEquationAlpha=this.blendDstAlpha=this.blendSrcAlpha=
null;this.depthFunc=THREE.LessEqualDepth;this.depthWrite=this.depthTest=!0;this.clippingPlanes=null;this.clipShadows=!1;this.colorWrite=!0;this.precision=null;this.polygonOffset=!1;this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.premultipliedAlpha=!1;this.overdraw=0;this._needsUpdate=this.visible=!0};
THREE.Material.prototype={constructor:THREE.Material,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");else{var d=this[b];void 0===d?console.warn("THREE."+this.type+": '"+b+"' is not a property of this material."):d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):
this[b]="overdraw"===b?Number(c):c}}},toJSON:function(a){function b(a){var b=[],c;for(c in a){var d=a[c];delete d.metadata;b.push(d)}return b}var c=void 0===a;c&&(a={textures:{},images:{}});var d={metadata:{version:4.4,type:"Material",generator:"Material.toJSON"}};d.uuid=this.uuid;d.type=this.type;""!==this.name&&(d.name=this.name);this.color instanceof THREE.Color&&(d.color=this.color.getHex());.5!==this.roughness&&(d.roughness=this.roughness);.5!==this.metalness&&(d.metalness=this.metalness);this.emissive instanceof
THREE.Color&&(d.emissive=this.emissive.getHex());this.specular instanceof THREE.Color&&(d.specular=this.specular.getHex());void 0!==this.shininess&&(d.shininess=this.shininess);this.map instanceof THREE.Texture&&(d.map=this.map.toJSON(a).uuid);this.alphaMap instanceof THREE.Texture&&(d.alphaMap=this.alphaMap.toJSON(a).uuid);this.lightMap instanceof THREE.Texture&&(d.lightMap=this.lightMap.toJSON(a).uuid);this.bumpMap instanceof THREE.Texture&&(d.bumpMap=this.bumpMap.toJSON(a).uuid,d.bumpScale=this.bumpScale);
this.normalMap instanceof THREE.Texture&&(d.normalMap=this.normalMap.toJSON(a).uuid,d.normalScale=this.normalScale.toArray());this.displacementMap instanceof THREE.Texture&&(d.displacementMap=this.displacementMap.toJSON(a).uuid,d.displacementScale=this.displacementScale,d.displacementBias=this.displacementBias);this.roughnessMap instanceof THREE.Texture&&(d.roughnessMap=this.roughnessMap.toJSON(a).uuid);this.metalnessMap instanceof THREE.Texture&&(d.metalnessMap=this.metalnessMap.toJSON(a).uuid);
this.emissiveMap instanceof THREE.Texture&&(d.emissiveMap=this.emissiveMap.toJSON(a).uuid);this.specularMap instanceof THREE.Texture&&(d.specularMap=this.specularMap.toJSON(a).uuid);this.envMap instanceof THREE.Texture&&(d.envMap=this.envMap.toJSON(a).uuid,d.reflectivity=this.reflectivity);void 0!==this.size&&(d.size=this.size);void 0!==this.sizeAttenuation&&(d.sizeAttenuation=this.sizeAttenuation);this.blending!==THREE.NormalBlending&&(d.blending=this.blending);this.shading!==THREE.SmoothShading&&
(d.shading=this.shading);this.side!==THREE.FrontSide&&(d.side=this.side);this.vertexColors!==THREE.NoColors&&(d.vertexColors=this.vertexColors);1>this.opacity&&(d.opacity=this.opacity);!0===this.transparent&&(d.transparent=this.transparent);0<this.alphaTest&&(d.alphaTest=this.alphaTest);!0===this.premultipliedAlpha&&(d.premultipliedAlpha=this.premultipliedAlpha);!0===this.wireframe&&(d.wireframe=this.wireframe);1<this.wireframeLinewidth&&(d.wireframeLinewidth=this.wireframeLinewidth);c&&(c=b(a.textures),
a=b(a.images),0<c.length&&(d.textures=c),0<a.length&&(d.images=a));return d},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.name=a.name;this.fog=a.fog;this.lights=a.lights;this.blending=a.blending;this.side=a.side;this.vertexColors=a.vertexColors;this.opacity=a.opacity;this.transparent=a.transparent;this.blendSrc=a.blendSrc;this.blendDst=a.blendDst;this.blendEquation=a.blendEquation;this.blendSrcAlpha=a.blendSrcAlpha;this.blendDstAlpha=a.blendDstAlpha;this.blendEquationAlpha=
a.blendEquationAlpha;this.depthFunc=a.depthFunc;this.depthTest=a.depthTest;this.depthWrite=a.depthWrite;this.colorWrite=a.colorWrite;this.precision=a.precision;this.polygonOffset=a.polygonOffset;this.polygonOffsetFactor=a.polygonOffsetFactor;this.polygonOffsetUnits=a.polygonOffsetUnits;this.alphaTest=a.alphaTest;this.premultipliedAlpha=a.premultipliedAlpha;this.overdraw=a.overdraw;this.visible=a.visible;this.clipShadows=a.clipShadows;a=a.clippingPlanes;var b=null;if(null!==a)for(var c=a.length,b=
Array(c),d=0;d!==c;++d)b[d]=a[d].clone();this.clippingPlanes=b;return this},update:function(){this.dispatchEvent({type:"update"})},dispose:function(){this.dispatchEvent({type:"dispose"})}};Object.assign(THREE.Material.prototype,THREE.EventDispatcher.prototype);THREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.type="LineBasicMaterial";this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.lights=!1;this.setValues(a)};
THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);THREE.LineBasicMaterial.prototype.constructor=THREE.LineBasicMaterial;THREE.LineBasicMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.linewidth=a.linewidth;this.linecap=a.linecap;this.linejoin=a.linejoin;return this};
THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.type="LineDashedMaterial";this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.lights=!1;this.setValues(a)};THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);THREE.LineDashedMaterial.prototype.constructor=THREE.LineDashedMaterial;
THREE.LineDashedMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.linewidth=a.linewidth;this.scale=a.scale;this.dashSize=a.dashSize;this.gapSize=a.gapSize;return this};
THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.type="MeshBasicMaterial";this.color=new THREE.Color(16777215);this.aoMap=this.map=null;this.aoMapIntensity=1;this.envMap=this.alphaMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.lights=this.morphTargets=this.skinning=!1;this.setValues(a)};
THREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshBasicMaterial.prototype.constructor=THREE.MeshBasicMaterial;
THREE.MeshBasicMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;
this.skinning=a.skinning;this.morphTargets=a.morphTargets;return this};THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.type="MeshDepthMaterial";this.depthPacking=THREE.BasicDepthPacking;this.morphTargets=this.skinning=!1;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.constructor=THREE.MeshDepthMaterial;THREE.MeshDepthMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.depthPacking=a.depthPacking;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.map=a.map;this.alphaMap=a.alphaMap;this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;return this};
THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.type="MeshLambertMaterial";this.color=new THREE.Color(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new THREE.Color(0);this.emissiveIntensity=1;this.envMap=this.alphaMap=this.specularMap=this.emissiveMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=
"round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshLambertMaterial.prototype.constructor=THREE.MeshLambertMaterial;
THREE.MeshLambertMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=
a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.type="MeshNormalMaterial";this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=this.lights=this.fog=!1;this.setValues(a)};
THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.constructor=THREE.MeshNormalMaterial;THREE.MeshNormalMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;return this};
THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.type="MeshPhongMaterial";this.color=new THREE.Color(16777215);this.specular=new THREE.Color(1118481);this.shininess=30;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new THREE.Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=
0;this.envMap=this.alphaMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshPhongMaterial.prototype.constructor=THREE.MeshPhongMaterial;
THREE.MeshPhongMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.specular.copy(a.specular);this.shininess=a.shininess;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=a.normalMap;this.normalScale.copy(a.normalScale);
this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.specularMap=a.specularMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.combine=a.combine;this.reflectivity=a.reflectivity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;this.skinning=a.skinning;this.morphTargets=a.morphTargets;
this.morphNormals=a.morphNormals;return this};
THREE.MeshStandardMaterial=function(a){THREE.Material.call(this);this.defines={STANDARD:""};this.type="MeshStandardMaterial";this.color=new THREE.Color(16777215);this.metalness=this.roughness=.5;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new THREE.Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.displacementMap=null;this.displacementScale=
1;this.displacementBias=0;this.envMap=this.alphaMap=this.metalnessMap=this.roughnessMap=null;this.envMapIntensity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshStandardMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshStandardMaterial.prototype.constructor=THREE.MeshStandardMaterial;
THREE.MeshStandardMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.defines={STANDARD:""};this.color.copy(a.color);this.roughness=a.roughness;this.metalness=a.metalness;this.map=a.map;this.lightMap=a.lightMap;this.lightMapIntensity=a.lightMapIntensity;this.aoMap=a.aoMap;this.aoMapIntensity=a.aoMapIntensity;this.emissive.copy(a.emissive);this.emissiveMap=a.emissiveMap;this.emissiveIntensity=a.emissiveIntensity;this.bumpMap=a.bumpMap;this.bumpScale=a.bumpScale;this.normalMap=
a.normalMap;this.normalScale.copy(a.normalScale);this.displacementMap=a.displacementMap;this.displacementScale=a.displacementScale;this.displacementBias=a.displacementBias;this.roughnessMap=a.roughnessMap;this.metalnessMap=a.metalnessMap;this.alphaMap=a.alphaMap;this.envMap=a.envMap;this.envMapIntensity=a.envMapIntensity;this.refractionRatio=a.refractionRatio;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.wireframeLinecap=a.wireframeLinecap;this.wireframeLinejoin=a.wireframeLinejoin;
this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;return this};THREE.MeshPhysicalMaterial=function(a){THREE.MeshStandardMaterial.call(this);this.defines={PHYSICAL:""};this.type="MeshPhysicalMaterial";this.reflectivity=.5;this.setValues(a)};THREE.MeshPhysicalMaterial.prototype=Object.create(THREE.MeshStandardMaterial.prototype);THREE.MeshPhysicalMaterial.prototype.constructor=THREE.MeshPhysicalMaterial;
THREE.MeshPhysicalMaterial.prototype.copy=function(a){THREE.MeshStandardMaterial.prototype.copy.call(this,a);this.defines={PHYSICAL:""};this.reflectivity=a.reflectivity;return this};THREE.MultiMaterial=function(a){this.uuid=THREE.Math.generateUUID();this.type="MultiMaterial";this.materials=a instanceof Array?a:[];this.visible=!0};
THREE.MultiMaterial.prototype={constructor:THREE.MultiMaterial,toJSON:function(a){for(var b={metadata:{version:4.2,type:"material",generator:"MaterialExporter"},uuid:this.uuid,type:this.type,materials:[]},c=this.materials,d=0,e=c.length;d<e;d++){var f=c[d].toJSON(a);delete f.metadata;b.materials.push(f)}b.visible=this.visible;return b},clone:function(){for(var a=new this.constructor,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());a.visible=this.visible;return a}};
THREE.PointsMaterial=function(a){THREE.Material.call(this);this.type="PointsMaterial";this.color=new THREE.Color(16777215);this.map=null;this.size=1;this.sizeAttenuation=!0;this.lights=!1;this.setValues(a)};THREE.PointsMaterial.prototype=Object.create(THREE.Material.prototype);THREE.PointsMaterial.prototype.constructor=THREE.PointsMaterial;
THREE.PointsMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.size=a.size;this.sizeAttenuation=a.sizeAttenuation;return this};
THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.type="ShaderMaterial";this.defines={};this.uniforms={};this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.morphNormals=this.morphTargets=this.skinning=this.clipping=this.lights=this.fog=!1;this.extensions={derivatives:!1,fragDepth:!1,
drawBuffers:!1,shaderTextureLOD:!1};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;void 0!==a&&(void 0!==a.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(a))};THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);THREE.ShaderMaterial.prototype.constructor=THREE.ShaderMaterial;
THREE.ShaderMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.fragmentShader=a.fragmentShader;this.vertexShader=a.vertexShader;this.uniforms=THREE.UniformsUtils.clone(a.uniforms);this.defines=a.defines;this.wireframe=a.wireframe;this.wireframeLinewidth=a.wireframeLinewidth;this.lights=a.lights;this.clipping=a.clipping;this.skinning=a.skinning;this.morphTargets=a.morphTargets;this.morphNormals=a.morphNormals;this.extensions=a.extensions;return this};
THREE.ShaderMaterial.prototype.toJSON=function(a){a=THREE.Material.prototype.toJSON.call(this,a);a.uniforms=this.uniforms;a.vertexShader=this.vertexShader;a.fragmentShader=this.fragmentShader;return a};THREE.RawShaderMaterial=function(a){THREE.ShaderMaterial.call(this,a);this.type="RawShaderMaterial"};THREE.RawShaderMaterial.prototype=Object.create(THREE.ShaderMaterial.prototype);THREE.RawShaderMaterial.prototype.constructor=THREE.RawShaderMaterial;
THREE.SpriteMaterial=function(a){THREE.Material.call(this);this.type="SpriteMaterial";this.color=new THREE.Color(16777215);this.map=null;this.rotation=0;this.lights=this.fog=!1;this.setValues(a)};THREE.SpriteMaterial.prototype=Object.create(THREE.Material.prototype);THREE.SpriteMaterial.prototype.constructor=THREE.SpriteMaterial;THREE.SpriteMaterial.prototype.copy=function(a){THREE.Material.prototype.copy.call(this,a);this.color.copy(a.color);this.map=a.map;this.rotation=a.rotation;return this};
THREE.ShadowMaterial=function(){THREE.ShaderMaterial.call(this,{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.lights,{opacity:{value:1}}]),vertexShader:THREE.ShaderChunk.shadow_vert,fragmentShader:THREE.ShaderChunk.shadow_frag});this.transparent=this.lights=!0;Object.defineProperties(this,{opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(a){this.uniforms.opacity.value=a}}})};THREE.ShadowMaterial.prototype=Object.create(THREE.ShaderMaterial.prototype);
THREE.ShadowMaterial.prototype.constructor=THREE.ShadowMaterial;
THREE.Texture=function(a,b,c,d,e,f,g,h,k,l){Object.defineProperty(this,"id",{value:THREE.TextureIdCount++});this.uuid=THREE.Math.generateUUID();this.sourceFile=this.name="";this.image=void 0!==a?a:THREE.Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:THREE.Texture.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;
this.anisotropy=void 0!==k?k:1;this.format=void 0!==g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=void 0!==l?l:THREE.LinearEncoding;this.version=0;this.onUpdate=null};THREE.Texture.DEFAULT_IMAGE=void 0;THREE.Texture.DEFAULT_MAPPING=THREE.UVMapping;
THREE.Texture.prototype={constructor:THREE.Texture,set needsUpdate(a){!0===a&&this.version++},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.image=a.image;this.mipmaps=a.mipmaps.slice(0);this.mapping=a.mapping;this.wrapS=a.wrapS;this.wrapT=a.wrapT;this.magFilter=a.magFilter;this.minFilter=a.minFilter;this.anisotropy=a.anisotropy;this.format=a.format;this.type=a.type;this.offset.copy(a.offset);this.repeat.copy(a.repeat);this.generateMipmaps=a.generateMipmaps;this.premultiplyAlpha=
a.premultiplyAlpha;this.flipY=a.flipY;this.unpackAlignment=a.unpackAlignment;this.encoding=a.encoding;return this},toJSON:function(a){if(void 0!==a.textures[this.uuid])return a.textures[this.uuid];var b={metadata:{version:4.4,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],wrap:[this.wrapS,this.wrapT],minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy};
if(void 0!==this.image){var c=this.image;void 0===c.uuid&&(c.uuid=THREE.Math.generateUUID());if(void 0===a.images[c.uuid]){var d=a.images,e=c.uuid,f=c.uuid,g;void 0!==c.toDataURL?g=c:(g=document.createElement("canvas"),g.width=c.width,g.height=c.height,g.getContext("2d").drawImage(c,0,0,c.width,c.height));g=2048<g.width||2048<g.height?g.toDataURL("image/jpeg",.6):g.toDataURL("image/png");d[e]={uuid:f,url:g}}b.image=c.uuid}return a.textures[this.uuid]=b},dispose:function(){this.dispatchEvent({type:"dispose"})},
transformUv:function(a){if(this.mapping===THREE.UVMapping){a.multiply(this.repeat);a.add(this.offset);if(0>a.x||1<a.x)switch(this.wrapS){case THREE.RepeatWrapping:a.x-=Math.floor(a.x);break;case THREE.ClampToEdgeWrapping:a.x=0>a.x?0:1;break;case THREE.MirroredRepeatWrapping:1===Math.abs(Math.floor(a.x)%2)?a.x=Math.ceil(a.x)-a.x:a.x-=Math.floor(a.x)}if(0>a.y||1<a.y)switch(this.wrapT){case THREE.RepeatWrapping:a.y-=Math.floor(a.y);break;case THREE.ClampToEdgeWrapping:a.y=0>a.y?0:1;break;case THREE.MirroredRepeatWrapping:1===
Math.abs(Math.floor(a.y)%2)?a.y=Math.ceil(a.y)-a.y:a.y-=Math.floor(a.y)}this.flipY&&(a.y=1-a.y)}}};Object.assign(THREE.Texture.prototype,THREE.EventDispatcher.prototype);THREE.TextureIdCount=0;
THREE.DepthTexture=function(a,b,c,d,e,f,g,h,k){THREE.Texture.call(this,null,d,e,f,g,h,THREE.DepthFormat,c,k);this.image={width:a,height:b};this.type=void 0!==c?c:THREE.UnsignedShortType;this.magFilter=void 0!==g?g:THREE.NearestFilter;this.minFilter=void 0!==h?h:THREE.NearestFilter;this.generateMipmaps=this.flipY=!1};THREE.DepthTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DepthTexture.prototype.constructor=THREE.DepthTexture;
THREE.CanvasTexture=function(a,b,c,d,e,f,g,h,k){THREE.Texture.call(this,a,b,c,d,e,f,g,h,k);this.needsUpdate=!0};THREE.CanvasTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CanvasTexture.prototype.constructor=THREE.CanvasTexture;THREE.CubeTexture=function(a,b,c,d,e,f,g,h,k,l){a=void 0!==a?a:[];b=void 0!==b?b:THREE.CubeReflectionMapping;THREE.Texture.call(this,a,b,c,d,e,f,g,h,k,l);this.flipY=!1};THREE.CubeTexture.prototype=Object.create(THREE.Texture.prototype);
THREE.CubeTexture.prototype.constructor=THREE.CubeTexture;Object.defineProperty(THREE.CubeTexture.prototype,"images",{get:function(){return this.image},set:function(a){this.image=a}});THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,k,l,n,p){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n,p);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=this.flipY=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);THREE.CompressedTexture.prototype.constructor=THREE.CompressedTexture;
THREE.DataTexture=function(a,b,c,d,e,f,g,h,k,l,n,p){THREE.Texture.call(this,null,f,g,h,k,l,d,e,n,p);this.image={data:a,width:b,height:c};this.magFilter=void 0!==k?k:THREE.NearestFilter;this.minFilter=void 0!==l?l:THREE.NearestFilter;this.generateMipmaps=this.flipY=!1};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.constructor=THREE.DataTexture;
THREE.VideoTexture=function(a,b,c,d,e,f,g,h,k){function l(){requestAnimationFrame(l);a.readyState>=a.HAVE_CURRENT_DATA&&(n.needsUpdate=!0)}THREE.Texture.call(this,a,b,c,d,e,f,g,h,k);this.generateMipmaps=!1;var n=this;l()};THREE.VideoTexture.prototype=Object.create(THREE.Texture.prototype);THREE.VideoTexture.prototype.constructor=THREE.VideoTexture;THREE.Group=function(){THREE.Object3D.call(this);this.type="Group"};THREE.Group.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Group});
THREE.Points=function(a,b){THREE.Object3D.call(this);this.type="Points";this.geometry=void 0!==a?a:new THREE.BufferGeometry;this.material=void 0!==b?b:new THREE.PointsMaterial({color:16777215*Math.random()})};
THREE.Points.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Points,raycast:function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere;return function(d,e){function f(a,c){var f=b.distanceSqToPoint(a);if(f<n){var h=b.closestPointToPoint(a);h.applyMatrix4(k);var m=d.ray.origin.distanceTo(h);m<d.near||m>d.far||e.push({distance:m,distanceToRay:Math.sqrt(f),point:h.clone(),index:c,face:null,object:g})}}var g=this,h=this.geometry,k=this.matrixWorld,l=d.params.Points.threshold;
null===h.boundingSphere&&h.computeBoundingSphere();c.copy(h.boundingSphere);c.applyMatrix4(k);if(!1!==d.ray.intersectsSphere(c)){a.getInverse(k);b.copy(d.ray).applyMatrix4(a);var l=l/((this.scale.x+this.scale.y+this.scale.z)/3),n=l*l,l=new THREE.Vector3;if(h instanceof THREE.BufferGeometry){var p=h.index,h=h.attributes.position.array;if(null!==p)for(var m=p.array,p=0,q=m.length;p<q;p++){var r=m[p];l.fromArray(h,3*r);f(l,r)}else for(p=0,m=h.length/3;p<m;p++)l.fromArray(h,3*p),f(l,p)}else for(l=h.vertices,
p=0,m=l.length;p<m;p++)f(l[p],p)}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});THREE.Line=function(a,b,c){if(1===c)return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),new THREE.LineSegments(a,b);THREE.Object3D.call(this);this.type="Line";this.geometry=void 0!==a?a:new THREE.BufferGeometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()})};
THREE.Line.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Line,raycast:function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere;return function(d,e){var f=d.linePrecision,f=f*f,g=this.geometry,h=this.matrixWorld;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(h);if(!1!==d.ray.intersectsSphere(c)){a.getInverse(h);b.copy(d.ray).applyMatrix4(a);var k=new THREE.Vector3,l=new THREE.Vector3,h=new THREE.Vector3,n=
new THREE.Vector3,p=this instanceof THREE.LineSegments?2:1;if(g instanceof THREE.BufferGeometry){var m=g.index,q=g.attributes.position.array;if(null!==m)for(var m=m.array,g=0,r=m.length-1;g<r;g+=p){var s=m[g+1];k.fromArray(q,3*m[g]);l.fromArray(q,3*s);s=b.distanceSqToSegment(k,l,n,h);s>f||(n.applyMatrix4(this.matrixWorld),s=d.ray.origin.distanceTo(n),s<d.near||s>d.far||e.push({distance:s,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}else for(g=0,r=
q.length/3-1;g<r;g+=p)k.fromArray(q,3*g),l.fromArray(q,3*g+3),s=b.distanceSqToSegment(k,l,n,h),s>f||(n.applyMatrix4(this.matrixWorld),s=d.ray.origin.distanceTo(n),s<d.near||s>d.far||e.push({distance:s,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}else if(g instanceof THREE.Geometry)for(k=g.vertices,l=k.length,g=0;g<l-1;g+=p)s=b.distanceSqToSegment(k[g],k[g+1],n,h),s>f||(n.applyMatrix4(this.matrixWorld),s=d.ray.origin.distanceTo(n),s<d.near||s>d.far||
e.push({distance:s,point:h.clone().applyMatrix4(this.matrixWorld),index:g,face:null,faceIndex:null,object:this}))}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});THREE.LineSegments=function(a,b){THREE.Line.call(this,a,b);this.type="LineSegments"};THREE.LineSegments.prototype=Object.assign(Object.create(THREE.Line.prototype),{constructor:THREE.LineSegments});
THREE.Mesh=function(a,b){THREE.Object3D.call(this);this.type="Mesh";this.geometry=void 0!==a?a:new THREE.BufferGeometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.drawMode=THREE.TrianglesDrawMode;this.updateMorphTargets()};
THREE.Mesh.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Mesh,setDrawMode:function(a){this.drawMode=a},updateMorphTargets:function(){if(void 0!==this.geometry.morphTargets&&0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}},getMorphTargetIndexByName:function(a){if(void 0!==
this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target "+a+" does not exist. Returning 0.");return 0},raycast:function(){function a(a,b,c,d,e,g,f){THREE.Triangle.barycoordFromPoint(a,b,c,d,s);e.multiplyScalar(s.x);g.multiplyScalar(s.y);f.multiplyScalar(s.z);e.add(g).add(f);return e.clone()}function b(a,b,c,d,e,g,f){var h=a.material;if(null===(h.side===THREE.BackSide?c.intersectTriangle(g,e,d,!0,f):c.intersectTriangle(d,e,
g,h.side!==THREE.DoubleSide,f)))return null;x.copy(f);x.applyMatrix4(a.matrixWorld);c=b.ray.origin.distanceTo(x);return c<b.near||c>b.far?null:{distance:c,point:x.clone(),object:a}}function c(c,d,e,f,l,p,n,s){g.fromArray(f,3*p);h.fromArray(f,3*n);k.fromArray(f,3*s);if(c=b(c,d,e,g,h,k,u))l&&(m.fromArray(l,2*p),q.fromArray(l,2*n),r.fromArray(l,2*s),c.uv=a(u,g,h,k,m,q,r)),c.face=new THREE.Face3(p,n,s,THREE.Triangle.normal(g,h,k)),c.faceIndex=p;return c}var d=new THREE.Matrix4,e=new THREE.Ray,f=new THREE.Sphere,
g=new THREE.Vector3,h=new THREE.Vector3,k=new THREE.Vector3,l=new THREE.Vector3,n=new THREE.Vector3,p=new THREE.Vector3,m=new THREE.Vector2,q=new THREE.Vector2,r=new THREE.Vector2,s=new THREE.Vector3,u=new THREE.Vector3,x=new THREE.Vector3;return function(s,x){var w=this.geometry,D=this.material,A=this.matrixWorld;if(void 0!==D&&(null===w.boundingSphere&&w.computeBoundingSphere(),f.copy(w.boundingSphere),f.applyMatrix4(A),!1!==s.ray.intersectsSphere(f)&&(d.getInverse(A),e.copy(s.ray).applyMatrix4(d),
null===w.boundingBox||!1!==e.intersectsBox(w.boundingBox)))){var y,B;if(w instanceof THREE.BufferGeometry){var G,z,D=w.index,A=w.attributes,w=A.position.array;void 0!==A.uv&&(y=A.uv.array);if(null!==D)for(var A=D.array,H=0,M=A.length;H<M;H+=3){if(D=A[H],G=A[H+1],z=A[H+2],B=c(this,s,e,w,y,D,G,z))B.faceIndex=Math.floor(H/3),x.push(B)}else for(H=0,M=w.length;H<M;H+=9)if(D=H/3,G=D+1,z=D+2,B=c(this,s,e,w,y,D,G,z))B.index=D,x.push(B)}else if(w instanceof THREE.Geometry){var O,N,A=D instanceof THREE.MultiMaterial,
H=!0===A?D.materials:null,M=w.vertices;G=w.faces;z=w.faceVertexUvs[0];0<z.length&&(y=z);for(var E=0,K=G.length;E<K;E++){var I=G[E];B=!0===A?H[I.materialIndex]:D;if(void 0!==B){z=M[I.a];O=M[I.b];N=M[I.c];if(!0===B.morphTargets){B=w.morphTargets;var L=this.morphTargetInfluences;g.set(0,0,0);h.set(0,0,0);k.set(0,0,0);for(var P=0,Q=B.length;P<Q;P++){var R=L[P];if(0!==R){var F=B[P].vertices;g.addScaledVector(l.subVectors(F[I.a],z),R);h.addScaledVector(n.subVectors(F[I.b],O),R);k.addScaledVector(p.subVectors(F[I.c],
N),R)}}g.add(z);h.add(O);k.add(N);z=g;O=h;N=k}if(B=b(this,s,e,z,O,N,u))y&&(L=y[E],m.copy(L[0]),q.copy(L[1]),r.copy(L[2]),B.uv=a(u,z,O,N,m,q,r)),B.face=I,B.faceIndex=E,x.push(B)}}}}}}(),clone:function(){return(new this.constructor(this.geometry,this.material)).copy(this)}});THREE.Bone=function(a){THREE.Object3D.call(this);this.type="Bone";this.skin=a};
THREE.Bone.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Bone,copy:function(a){THREE.Object3D.prototype.copy.call(this,a);this.skin=a.skin;return this}});
THREE.Skeleton=function(a,b,c){this.useVertexTexture=void 0!==c?c:!0;this.identityMatrix=new THREE.Matrix4;a=a||[];this.bones=a.slice(0);this.useVertexTexture?(a=Math.sqrt(4*this.bones.length),a=THREE.Math.nextPowerOfTwo(Math.ceil(a)),this.boneTextureHeight=this.boneTextureWidth=a=Math.max(a,4),this.boneMatrices=new Float32Array(this.boneTextureWidth*this.boneTextureHeight*4),this.boneTexture=new THREE.DataTexture(this.boneMatrices,this.boneTextureWidth,this.boneTextureHeight,THREE.RGBAFormat,THREE.FloatType)):
this.boneMatrices=new Float32Array(16*this.bones.length);if(void 0===b)this.calculateInverses();else if(this.bones.length===b.length)this.boneInverses=b.slice(0);else for(console.warn("THREE.Skeleton bonInverses is the wrong length."),this.boneInverses=[],b=0,a=this.bones.length;b<a;b++)this.boneInverses.push(new THREE.Matrix4)};
Object.assign(THREE.Skeleton.prototype,{calculateInverses:function(){this.boneInverses=[];for(var a=0,b=this.bones.length;a<b;a++){var c=new THREE.Matrix4;this.bones[a]&&c.getInverse(this.bones[a].matrixWorld);this.boneInverses.push(c)}},pose:function(){for(var a,b=0,c=this.bones.length;b<c;b++)(a=this.bones[b])&&a.matrixWorld.getInverse(this.boneInverses[b]);b=0;for(c=this.bones.length;b<c;b++)if(a=this.bones[b])a.parent?(a.matrix.getInverse(a.parent.matrixWorld),a.matrix.multiply(a.matrixWorld)):
a.matrix.copy(a.matrixWorld),a.matrix.decompose(a.position,a.quaternion,a.scale)},update:function(){var a=new THREE.Matrix4;return function(){for(var b=0,c=this.bones.length;b<c;b++)a.multiplyMatrices(this.bones[b]?this.bones[b].matrixWorld:this.identityMatrix,this.boneInverses[b]),a.toArray(this.boneMatrices,16*b);this.useVertexTexture&&(this.boneTexture.needsUpdate=!0)}}(),clone:function(){return new THREE.Skeleton(this.bones,this.boneInverses,this.useVertexTexture)}});
THREE.SkinnedMesh=function(a,b,c){THREE.Mesh.call(this,a,b);this.type="SkinnedMesh";this.bindMode="attached";this.bindMatrix=new THREE.Matrix4;this.bindMatrixInverse=new THREE.Matrix4;a=[];if(this.geometry&&void 0!==this.geometry.bones){for(var d,e=0,f=this.geometry.bones.length;e<f;++e)d=this.geometry.bones[e],b=new THREE.Bone(this),a.push(b),b.name=d.name,b.position.fromArray(d.pos),b.quaternion.fromArray(d.rotq),void 0!==d.scl&&b.scale.fromArray(d.scl);e=0;for(f=this.geometry.bones.length;e<f;++e)d=
this.geometry.bones[e],-1!==d.parent&&null!==d.parent&&void 0!==a[d.parent]?a[d.parent].add(a[e]):this.add(a[e])}this.normalizeSkinWeights();this.updateMatrixWorld(!0);this.bind(new THREE.Skeleton(a,void 0,c),this.matrixWorld)};
THREE.SkinnedMesh.prototype=Object.assign(Object.create(THREE.Mesh.prototype),{constructor:THREE.SkinnedMesh,bind:function(a,b){this.skeleton=a;void 0===b&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),b=this.matrixWorld);this.bindMatrix.copy(b);this.bindMatrixInverse.getInverse(b)},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){if(this.geometry instanceof THREE.Geometry)for(var a=0;a<this.geometry.skinWeights.length;a++){var b=this.geometry.skinWeights[a],c=
1/b.lengthManhattan();Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0)}else if(this.geometry instanceof THREE.BufferGeometry)for(var b=new THREE.Vector4,d=this.geometry.attributes.skinWeight,a=0;a<d.count;a++)b.x=d.getX(a),b.y=d.getY(a),b.z=d.getZ(a),b.w=d.getW(a),c=1/b.lengthManhattan(),Infinity!==c?b.multiplyScalar(c):b.set(1,0,0,0),d.setXYZW(a,b.x,b.y,b.z,b.w)},updateMatrixWorld:function(a){THREE.Mesh.prototype.updateMatrixWorld.call(this,!0);"attached"===this.bindMode?this.bindMatrixInverse.getInverse(this.matrixWorld):
"detached"===this.bindMode?this.bindMatrixInverse.getInverse(this.bindMatrix):console.warn("THREE.SkinnedMesh unrecognized bindMode: "+this.bindMode)},clone:function(){return(new this.constructor(this.geometry,this.material,this.useVertexTexture)).copy(this)}});THREE.LOD=function(){THREE.Object3D.call(this);this.type="LOD";Object.defineProperties(this,{levels:{enumerable:!0,value:[]}})};
THREE.LOD.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.LOD,copy:function(a){THREE.Object3D.prototype.copy.call(this,a,!1);a=a.levels;for(var b=0,c=a.length;b<c;b++){var d=a[b];this.addLevel(d.object.clone(),d.distance)}return this},addLevel:function(a,b){void 0===b&&(b=0);b=Math.abs(b);for(var c=this.levels,d=0;d<c.length&&!(b<c[d].distance);d++);c.splice(d,0,{distance:b,object:a});this.add(a)},getObjectForDistance:function(a){for(var b=this.levels,c=1,d=b.length;c<
d&&!(a<b[c].distance);c++);return b[c-1].object},raycast:function(){var a=new THREE.Vector3;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.origin.distanceTo(a);this.getObjectForDistance(d).raycast(b,c)}}(),update:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){var d=this.levels;if(1<d.length){a.setFromMatrixPosition(c.matrixWorld);b.setFromMatrixPosition(this.matrixWorld);c=a.distanceTo(b);d[0].object.visible=!0;for(var e=1,f=d.length;e<f;e++)if(c>=
d[e].distance)d[e-1].object.visible=!1,d[e].object.visible=!0;else break;for(;e<f;e++)d[e].object.visible=!1}}}(),toJSON:function(a){a=THREE.Object3D.prototype.toJSON.call(this,a);a.object.levels=[];for(var b=this.levels,c=0,d=b.length;c<d;c++){var e=b[c];a.object.levels.push({object:e.object.uuid,distance:e.distance})}return a}});THREE.Sprite=function(a){THREE.Object3D.call(this);this.type="Sprite";this.material=void 0!==a?a:new THREE.SpriteMaterial};
THREE.Sprite.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.Sprite,raycast:function(){var a=new THREE.Vector3;return function(b,c){a.setFromMatrixPosition(this.matrixWorld);var d=b.ray.distanceSqToPoint(a);d>this.scale.x*this.scale.y/4||c.push({distance:Math.sqrt(d),point:this.position,face:null,object:this})}}(),clone:function(){return(new this.constructor(this.material)).copy(this)}});
THREE.LensFlare=function(a,b,c,d,e){THREE.Object3D.call(this);this.lensFlares=[];this.positionScreen=new THREE.Vector3;this.customUpdateCallback=void 0;void 0!==a&&this.add(a,b,c,d,e)};
THREE.LensFlare.prototype=Object.assign(Object.create(THREE.Object3D.prototype),{constructor:THREE.LensFlare,copy:function(a){THREE.Object3D.prototype.copy.call(this,a);this.positionScreen.copy(a.positionScreen);this.customUpdateCallback=a.customUpdateCallback;for(var b=0,c=a.lensFlares.length;b<c;b++)this.lensFlares.push(a.lensFlares[b]);return this},add:function(a,b,c,d,e,f){void 0===b&&(b=-1);void 0===c&&(c=0);void 0===f&&(f=1);void 0===e&&(e=new THREE.Color(16777215));void 0===d&&(d=THREE.NormalBlending);
c=Math.min(c,Math.max(0,c));this.lensFlares.push({texture:a,size:b,distance:c,x:0,y:0,z:0,scale:1,rotation:0,opacity:f,color:e,blending:d})},updateLensFlares:function(){var a,b=this.lensFlares.length,c,d=2*-this.positionScreen.x,e=2*-this.positionScreen.y;for(a=0;a<b;a++)c=this.lensFlares[a],c.x=this.positionScreen.x+d*c.distance,c.y=this.positionScreen.y+e*c.distance,c.wantedRotation=c.x*Math.PI*.25,c.rotation+=.25*(c.wantedRotation-c.rotation)}});
THREE.Scene=function(){THREE.Object3D.call(this);this.type="Scene";this.overrideMaterial=this.fog=null;this.autoUpdate=!0};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);THREE.Scene.prototype.constructor=THREE.Scene;
THREE.Scene.prototype.copy=function(a,b){THREE.Object3D.prototype.copy.call(this,a,b);null!==a.fog&&(this.fog=a.fog.clone());null!==a.overrideMaterial&&(this.overrideMaterial=a.overrideMaterial.clone());this.autoUpdate=a.autoUpdate;this.matrixAutoUpdate=a.matrixAutoUpdate;return this};THREE.Fog=function(a,b,c){this.name="";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};
THREE.FogExp2=function(a,b){this.name="";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.ShaderChunk={};THREE.ShaderChunk.alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";THREE.ShaderChunk.alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";THREE.ShaderChunk.alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
THREE.ShaderChunk.aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";THREE.ShaderChunk.aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
THREE.ShaderChunk.begin_vertex="\nvec3 transformed = vec3( position );\n";THREE.ShaderChunk.beginnormal_vertex="\nvec3 objectNormal = vec3( normal );\n";THREE.ShaderChunk.bsdfs="bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
THREE.ShaderChunk.bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
THREE.ShaderChunk.clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";THREE.ShaderChunk.clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
THREE.ShaderChunk.clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";THREE.ShaderChunk.clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";THREE.ShaderChunk.color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";THREE.ShaderChunk.color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
THREE.ShaderChunk.color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";THREE.ShaderChunk.color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";THREE.ShaderChunk.common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
THREE.ShaderChunk.cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
THREE.ShaderChunk.defaultnormal_vertex="#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";THREE.ShaderChunk.displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";THREE.ShaderChunk.displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
THREE.ShaderChunk.emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";THREE.ShaderChunk.emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";THREE.ShaderChunk.encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
THREE.ShaderChunk.encodings_fragment="  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";THREE.ShaderChunk.envmap_fragment="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
THREE.ShaderChunk.envmap_pars_fragment="#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
THREE.ShaderChunk.envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";THREE.ShaderChunk.envmap_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
THREE.ShaderChunk.fog_fragment="#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
THREE.ShaderChunk.fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";THREE.ShaderChunk.lightmap_fragment="#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";THREE.ShaderChunk.lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
THREE.ShaderChunk.lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
THREE.ShaderChunk.lights_pars="uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
THREE.ShaderChunk.lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";THREE.ShaderChunk.lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
THREE.ShaderChunk.lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n";THREE.ShaderChunk.lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t#endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
THREE.ShaderChunk.lights_template="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
THREE.ShaderChunk.logdepthbuf_fragment="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";THREE.ShaderChunk.logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";THREE.ShaderChunk.logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
THREE.ShaderChunk.logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";THREE.ShaderChunk.map_fragment="#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
THREE.ShaderChunk.map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";THREE.ShaderChunk.map_particle_fragment="#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";THREE.ShaderChunk.map_particle_pars_fragment="#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";THREE.ShaderChunk.metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
THREE.ShaderChunk.metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";THREE.ShaderChunk.morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
THREE.ShaderChunk.morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";THREE.ShaderChunk.morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
THREE.ShaderChunk.normal_fragment="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
THREE.ShaderChunk.normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
THREE.ShaderChunk.packing="vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
THREE.ShaderChunk.premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";THREE.ShaderChunk.project_vertex="#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";THREE.ShaderChunk.roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
THREE.ShaderChunk.roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";THREE.ShaderChunk.shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
THREE.ShaderChunk.shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
THREE.ShaderChunk.shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
THREE.ShaderChunk.shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
THREE.ShaderChunk.skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";THREE.ShaderChunk.skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
THREE.ShaderChunk.skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";THREE.ShaderChunk.skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
THREE.ShaderChunk.specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";THREE.ShaderChunk.specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";THREE.ShaderChunk.tonemapping_fragment="#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
THREE.ShaderChunk.tonemapping_pars_fragment="#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
THREE.ShaderChunk.uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";THREE.ShaderChunk.uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";THREE.ShaderChunk.uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";THREE.ShaderChunk.uv_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
THREE.ShaderChunk.uv_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";THREE.ShaderChunk.uv_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
THREE.ShaderChunk.worldpos_vertex="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
THREE.UniformsUtils={merge:function(a){for(var b={},c=0;c<a.length;c++){var d=this.clone(a[c]),e;for(e in d)b[e]=d[e]}return b},clone:function(a){var b={},c;for(c in a){b[c]={};for(var d in a[c]){var e=a[c][d];e instanceof THREE.Color||e instanceof THREE.Vector2||e instanceof THREE.Vector3||e instanceof THREE.Vector4||e instanceof THREE.Matrix3||e instanceof THREE.Matrix4||e instanceof THREE.Texture?b[c][d]=e.clone():Array.isArray(e)?b[c][d]=e.slice():b[c][d]=e}}return b}};
THREE.UniformsLib={common:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"1f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)},specularMap:{type:"t",value:null},alphaMap:{type:"t",value:null},envMap:{type:"t",value:null},flipEnvMap:{type:"1f",value:-1},reflectivity:{type:"1f",value:1},refractionRatio:{type:"1f",value:.98}},aomap:{aoMap:{type:"t",value:null},aoMapIntensity:{type:"1f",value:1}},lightmap:{lightMap:{type:"t",value:null},lightMapIntensity:{type:"1f",
value:1}},emissivemap:{emissiveMap:{type:"t",value:null}},bumpmap:{bumpMap:{type:"t",value:null},bumpScale:{type:"1f",value:1}},normalmap:{normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new THREE.Vector2(1,1)}},displacementmap:{displacementMap:{type:"t",value:null},displacementScale:{type:"1f",value:1},displacementBias:{type:"1f",value:0}},roughnessmap:{roughnessMap:{type:"t",value:null}},metalnessmap:{metalnessMap:{type:"t",value:null}},fog:{fogDensity:{type:"1f",value:2.5E-4},fogNear:{type:"1f",
value:1},fogFar:{type:"1f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:"3fv",value:[]},directionalLights:{type:"sa",value:[],properties:{direction:{type:"v3"},color:{type:"c"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}},directionalShadowMap:{type:"tv",value:[]},directionalShadowMatrix:{type:"m4v",value:[]},spotLights:{type:"sa",value:[],properties:{color:{type:"c"},position:{type:"v3"},direction:{type:"v3"},
distance:{type:"1f"},coneCos:{type:"1f"},penumbraCos:{type:"1f"},decay:{type:"1f"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}},spotShadowMap:{type:"tv",value:[]},spotShadowMatrix:{type:"m4v",value:[]},pointLights:{type:"sa",value:[],properties:{color:{type:"c"},position:{type:"v3"},decay:{type:"1f"},distance:{type:"1f"},shadow:{type:"1i"},shadowBias:{type:"1f"},shadowRadius:{type:"1f"},shadowMapSize:{type:"v2"}}},pointShadowMap:{type:"tv",value:[]},
pointShadowMatrix:{type:"m4v",value:[]},hemisphereLights:{type:"sa",value:[],properties:{direction:{type:"v3"},skyColor:{type:"c"},groundColor:{type:"c"}}}},points:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"1f",value:1},size:{type:"1f",value:1},scale:{type:"1f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)}}};THREE.ShaderChunk.cube_frag="uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\t#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk.cube_vert="varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";THREE.ShaderChunk.depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
THREE.ShaderChunk.depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.distanceRGBA_frag="uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";THREE.ShaderChunk.distanceRGBA_vert="varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
THREE.ShaderChunk.equirect_frag="uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk.equirect_vert="varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";THREE.ShaderChunk.linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";
THREE.ShaderChunk.meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.meshphysical_frag="#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshphysical_vert="#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.normal_frag="uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";THREE.ShaderChunk.normal_vert="varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.shadow_frag="uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";THREE.ShaderChunk.shadow_vert="#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.aomap,THREE.UniformsLib.fog]),vertexShader:THREE.ShaderChunk.meshbasic_vert,fragmentShader:THREE.ShaderChunk.meshbasic_frag},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.aomap,THREE.UniformsLib.lightmap,THREE.UniformsLib.emissivemap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,{emissive:{type:"c",value:new THREE.Color(0)}}]),vertexShader:THREE.ShaderChunk.meshlambert_vert,
fragmentShader:THREE.ShaderChunk.meshlambert_frag},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.aomap,THREE.UniformsLib.lightmap,THREE.UniformsLib.emissivemap,THREE.UniformsLib.bumpmap,THREE.UniformsLib.normalmap,THREE.UniformsLib.displacementmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,{emissive:{type:"c",value:new THREE.Color(0)},specular:{type:"c",value:new THREE.Color(1118481)},shininess:{type:"1f",value:30}}]),vertexShader:THREE.ShaderChunk.meshphong_vert,
fragmentShader:THREE.ShaderChunk.meshphong_frag},standard:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.aomap,THREE.UniformsLib.lightmap,THREE.UniformsLib.emissivemap,THREE.UniformsLib.bumpmap,THREE.UniformsLib.normalmap,THREE.UniformsLib.displacementmap,THREE.UniformsLib.roughnessmap,THREE.UniformsLib.metalnessmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,{emissive:{type:"c",value:new THREE.Color(0)},roughness:{type:"1f",value:.5},metalness:{type:"1f",value:0},
envMapIntensity:{type:"1f",value:1}}]),vertexShader:THREE.ShaderChunk.meshphysical_vert,fragmentShader:THREE.ShaderChunk.meshphysical_frag},points:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.points,THREE.UniformsLib.fog]),vertexShader:THREE.ShaderChunk.points_vert,fragmentShader:THREE.ShaderChunk.points_frag},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,{scale:{type:"1f",value:1},dashSize:{type:"1f",value:1},totalSize:{type:"1f",value:2}}]),
vertexShader:THREE.ShaderChunk.linedashed_vert,fragmentShader:THREE.ShaderChunk.linedashed_frag},depth:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.displacementmap]),vertexShader:THREE.ShaderChunk.depth_vert,fragmentShader:THREE.ShaderChunk.depth_frag},normal:{uniforms:{opacity:{type:"1f",value:1}},vertexShader:THREE.ShaderChunk.normal_vert,fragmentShader:THREE.ShaderChunk.normal_frag},cube:{uniforms:{tCube:{type:"t",value:null},tFlip:{type:"1f",value:-1}},vertexShader:THREE.ShaderChunk.cube_vert,
fragmentShader:THREE.ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{type:"t",value:null},tFlip:{type:"1f",value:-1}},vertexShader:THREE.ShaderChunk.equirect_vert,fragmentShader:THREE.ShaderChunk.equirect_frag},distanceRGBA:{uniforms:{lightPos:{type:"v3",value:new THREE.Vector3}},vertexShader:THREE.ShaderChunk.distanceRGBA_vert,fragmentShader:THREE.ShaderChunk.distanceRGBA_frag}};
THREE.ShaderLib.physical={uniforms:THREE.UniformsUtils.merge([THREE.ShaderLib.standard.uniforms,{}]),vertexShader:THREE.ShaderChunk.meshphysical_vert,fragmentShader:THREE.ShaderChunk.meshphysical_frag};
THREE.WebGLRenderer=function(a){function b(a,b,c,d){!0===K&&(a*=d,b*=d,c*=d);J.clearColor(a,b,c,d)}function c(){J.init();J.scissor(ra.copy(ya).multiplyScalar($));J.viewport(ma.copy(na).multiplyScalar($));b(aa.r,aa.g,aa.b,ia)}function d(){ea=fa=null;oa="";Z=-1;J.reset()}function e(a){a.preventDefault();d();c();T.clear()}function f(a){a=a.target;a.removeEventListener("dispose",f);a:{var b=T.get(a);if(a.image&&b.__image__webglTextureCube)t.deleteTexture(b.__image__webglTextureCube);else{if(void 0===
b.__webglInit)break a;t.deleteTexture(b.__webglTexture)}T.delete(a)}ja.textures--}function g(a){a=a.target;a.removeEventListener("dispose",g);var b=T.get(a),c=T.get(a.texture);if(a){void 0!==c.__webglTexture&&t.deleteTexture(c.__webglTexture);a.depthTexture&&a.depthTexture.dispose();if(a instanceof THREE.WebGLRenderTargetCube)for(c=0;6>c;c++)t.deleteFramebuffer(b.__webglFramebuffer[c]),b.__webglDepthbuffer&&t.deleteRenderbuffer(b.__webglDepthbuffer[c]);else t.deleteFramebuffer(b.__webglFramebuffer),
b.__webglDepthbuffer&&t.deleteRenderbuffer(b.__webglDepthbuffer);T.delete(a.texture);T.delete(a)}ja.textures--}function h(a){a=a.target;a.removeEventListener("dispose",h);k(a);T.delete(a)}function k(a){var b=T.get(a).program;a.program=void 0;void 0!==b&&pa.releaseProgram(b)}function l(a,b){return Math.abs(b[0])-Math.abs(a[0])}function n(a,b){return a.object.renderOrder!==b.object.renderOrder?a.object.renderOrder-b.object.renderOrder:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==
b.z?a.z-b.z:a.id-b.id}function p(a,b){return a.object.renderOrder!==b.object.renderOrder?a.object.renderOrder-b.object.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function m(a,b,c,d,e){var g;c.transparent?(d=R,g=++F):(d=P,g=++Q);g=d[g];void 0!==g?(g.id=a.id,g.object=a,g.geometry=b,g.material=c,g.z=X.z,g.group=e):(g={id:a.id,object:a,geometry:b,material:c,z:X.z,group:e},d.push(g))}function q(a){if(!Ba.intersectsSphere(a))return!1;var b=ba.numPlanes;if(0===b)return!0;var c=W.clippingPlanes,d=a.center;a=
-a.radius;var e=0;do if(c[e].distanceToPoint(d)<a)return!1;while(++e!==b);return!0}function r(a,b){if(!1!==a.visible){if(a.layers.test(b.layers))if(a instanceof THREE.Light)L.push(a);else if(a instanceof THREE.Sprite){var c;(c=!1===a.frustumCulled)||(ka.center.set(0,0,0),ka.radius=.7071067811865476,ka.applyMatrix4(a.matrixWorld),c=!0===q(ka));c&&U.push(a)}else if(a instanceof THREE.LensFlare)Y.push(a);else if(a instanceof THREE.ImmediateRenderObject)!0===W.sortObjects&&(X.setFromMatrixPosition(a.matrixWorld),
X.applyProjection(sa)),m(a,null,a.material,X.z,null);else if(a instanceof THREE.Mesh||a instanceof THREE.Line||a instanceof THREE.Points)if(a instanceof THREE.SkinnedMesh&&a.skeleton.update(),(c=!1===a.frustumCulled)||(c=a.geometry,null===c.boundingSphere&&c.computeBoundingSphere(),ka.copy(c.boundingSphere).applyMatrix4(a.matrixWorld),c=!0===q(ka)),c){var d=a.material;if(!0===d.visible)if(!0===W.sortObjects&&(X.setFromMatrixPosition(a.matrixWorld),X.applyProjection(sa)),c=qa.update(a),d instanceof
THREE.MultiMaterial)for(var e=c.groups,g=d.materials,d=0,f=e.length;d<f;d++){var h=e[d],k=g[h.materialIndex];!0===k.visible&&m(a,c,k,X.z,h)}else m(a,c,d,X.z,null)}c=a.children;d=0;for(f=c.length;d<f;d++)r(c[d],b)}}function s(a,b,c,d){for(var e=0,g=a.length;e<g;e++){var f=a[e],h=f.object,k=f.geometry,m=void 0===d?f.material:d,f=f.group;h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse,h.matrixWorld);h.normalMatrix.getNormalMatrix(h.modelViewMatrix);if(h instanceof THREE.ImmediateRenderObject){u(m);
var l=x(b,c,m,h);oa="";h.render(function(a){W.renderBufferImmediate(a,l,m)})}else W.renderBufferDirect(b,c,k,m,h,f)}}function u(a){a.side!==THREE.DoubleSide?J.enable(t.CULL_FACE):J.disable(t.CULL_FACE);J.setFlipSided(a.side===THREE.BackSide);!0===a.transparent?J.setBlending(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha,a.premultipliedAlpha):J.setBlending(THREE.NoBlending);J.setDepthFunc(a.depthFunc);J.setDepthTest(a.depthTest);J.setDepthWrite(a.depthWrite);
J.setColorWrite(a.colorWrite);J.setPolygonOffset(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits)}function x(a,b,c,d){ta=0;var e=T.get(c);ua&&((za||a!==ea)&&ba.setState(c.clippingPlanes,c.clipShadows,a,e,a===ea&&c.id===Z),void 0!==e.numClippingPlanes&&e.numClippingPlanes!==ba.numPlanes&&(c.needsUpdate=!0));void 0===e.program&&(c.needsUpdate=!0);void 0!==e.lightsHash&&e.lightsHash!==S.hash&&(c.needsUpdate=!0);if(c.needsUpdate){a:{var g=T.get(c),f=pa.getParameters(c,S,b,ba.numPlanes,d),m=
pa.getProgramCode(c,f),l=g.program,p=!0;if(void 0===l)c.addEventListener("dispose",h);else if(l.code!==m)k(c);else if(void 0!==f.shaderID)break a;else p=!1;p&&(f.shaderID?(l=THREE.ShaderLib[f.shaderID],g.__webglShader={name:c.type,uniforms:THREE.UniformsUtils.clone(l.uniforms),vertexShader:l.vertexShader,fragmentShader:l.fragmentShader}):g.__webglShader={name:c.type,uniforms:c.uniforms,vertexShader:c.vertexShader,fragmentShader:c.fragmentShader},c.__webglShader=g.__webglShader,l=pa.acquireProgram(c,
f,m),g.program=l,c.program=l);f=l.getAttributes();if(c.morphTargets)for(m=c.numSupportedMorphTargets=0;m<W.maxMorphTargets;m++)0<=f["morphTarget"+m]&&c.numSupportedMorphTargets++;if(c.morphNormals)for(m=c.numSupportedMorphNormals=0;m<W.maxMorphNormals;m++)0<=f["morphNormal"+m]&&c.numSupportedMorphNormals++;f=g.__webglShader.uniforms;(c instanceof THREE.ShaderMaterial||c instanceof THREE.RawShaderMaterial)&&!0!==c.clipping||(g.numClippingPlanes=ba.numPlanes,f.clippingPlanes=ba.uniform);c.lights&&(g.lightsHash=
S.hash,f.ambientLightColor.value=S.ambient,f.directionalLights.value=S.directional,f.spotLights.value=S.spot,f.pointLights.value=S.point,f.hemisphereLights.value=S.hemi,f.directionalShadowMap.value=S.directionalShadowMap,f.directionalShadowMatrix.value=S.directionalShadowMatrix,f.spotShadowMap.value=S.spotShadowMap,f.spotShadowMatrix.value=S.spotShadowMatrix,f.pointShadowMap.value=S.pointShadowMap,f.pointShadowMatrix.value=S.pointShadowMatrix);m=g.program.getUniforms();m=THREE.WebGLUniforms.seqWithValue(m.seq,
f);g.uniformsList=m;g.dynamicUniforms=THREE.WebGLUniforms.splitDynamic(m,f)}c.needsUpdate=!1}var n=!1,p=l=!1,g=e.program,m=g.getUniforms(),f=e.__webglShader.uniforms;g.id!==fa&&(t.useProgram(g.program),fa=g.id,p=l=n=!0);c.id!==Z&&(Z=c.id,l=!0);if(n||a!==ea){m.set(t,a,"projectionMatrix");ca.logarithmicDepthBuffer&&m.setValue(t,"logDepthBufFC",2/(Math.log(a.far+1)/Math.LN2));a!==ea&&(ea=a,p=l=!0);if(c instanceof THREE.ShaderMaterial||c instanceof THREE.MeshPhongMaterial||c instanceof THREE.MeshStandardMaterial||
c.envMap)n=m.map.cameraPosition,void 0!==n&&n.setValue(t,X.setFromMatrixPosition(a.matrixWorld));(c instanceof THREE.MeshPhongMaterial||c instanceof THREE.MeshLambertMaterial||c instanceof THREE.MeshBasicMaterial||c instanceof THREE.MeshStandardMaterial||c instanceof THREE.ShaderMaterial||c.skinning)&&m.setValue(t,"viewMatrix",a.matrixWorldInverse);m.set(t,W,"toneMappingExposure");m.set(t,W,"toneMappingWhitePoint")}c.skinning&&(m.setOptional(t,d,"bindMatrix"),m.setOptional(t,d,"bindMatrixInverse"),
n=d.skeleton)&&(ca.floatVertexTextures&&n.useVertexTexture?(m.set(t,n,"boneTexture"),m.set(t,n,"boneTextureWidth"),m.set(t,n,"boneTextureHeight")):m.setOptional(t,n,"boneMatrices"));if(l){c.lights&&(l=p,f.ambientLightColor.needsUpdate=l,f.directionalLights.needsUpdate=l,f.pointLights.needsUpdate=l,f.spotLights.needsUpdate=l,f.hemisphereLights.needsUpdate=l);b&&c.fog&&(f.fogColor.value=b.color,b instanceof THREE.Fog?(f.fogNear.value=b.near,f.fogFar.value=b.far):b instanceof THREE.FogExp2&&(f.fogDensity.value=
b.density));if(c instanceof THREE.MeshBasicMaterial||c instanceof THREE.MeshLambertMaterial||c instanceof THREE.MeshPhongMaterial||c instanceof THREE.MeshStandardMaterial||c instanceof THREE.MeshDepthMaterial){f.opacity.value=c.opacity;f.diffuse.value=c.color;c.emissive&&f.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity);f.map.value=c.map;f.specularMap.value=c.specularMap;f.alphaMap.value=c.alphaMap;c.aoMap&&(f.aoMap.value=c.aoMap,f.aoMapIntensity.value=c.aoMapIntensity);var q;
c.map?q=c.map:c.specularMap?q=c.specularMap:c.displacementMap?q=c.displacementMap:c.normalMap?q=c.normalMap:c.bumpMap?q=c.bumpMap:c.roughnessMap?q=c.roughnessMap:c.metalnessMap?q=c.metalnessMap:c.alphaMap?q=c.alphaMap:c.emissiveMap&&(q=c.emissiveMap);void 0!==q&&(q instanceof THREE.WebGLRenderTarget&&(q=q.texture),b=q.offset,q=q.repeat,f.offsetRepeat.value.set(b.x,b.y,q.x,q.y));f.envMap.value=c.envMap;f.flipEnvMap.value=c.envMap instanceof THREE.CubeTexture?-1:1;f.reflectivity.value=c.reflectivity;
f.refractionRatio.value=c.refractionRatio}c instanceof THREE.LineBasicMaterial?(f.diffuse.value=c.color,f.opacity.value=c.opacity):c instanceof THREE.LineDashedMaterial?(f.diffuse.value=c.color,f.opacity.value=c.opacity,f.dashSize.value=c.dashSize,f.totalSize.value=c.dashSize+c.gapSize,f.scale.value=c.scale):c instanceof THREE.PointsMaterial?(f.diffuse.value=c.color,f.opacity.value=c.opacity,f.size.value=c.size*$,f.scale.value=.5*z.clientHeight,f.map.value=c.map,null!==c.map&&(q=c.map.offset,c=c.map.repeat,
f.offsetRepeat.value.set(q.x,q.y,c.x,c.y))):c instanceof THREE.MeshLambertMaterial?(c.lightMap&&(f.lightMap.value=c.lightMap,f.lightMapIntensity.value=c.lightMapIntensity),c.emissiveMap&&(f.emissiveMap.value=c.emissiveMap)):c instanceof THREE.MeshPhongMaterial?(f.specular.value=c.specular,f.shininess.value=Math.max(c.shininess,1E-4),c.lightMap&&(f.lightMap.value=c.lightMap,f.lightMapIntensity.value=c.lightMapIntensity),c.emissiveMap&&(f.emissiveMap.value=c.emissiveMap),c.bumpMap&&(f.bumpMap.value=
c.bumpMap,f.bumpScale.value=c.bumpScale),c.normalMap&&(f.normalMap.value=c.normalMap,f.normalScale.value.copy(c.normalScale)),c.displacementMap&&(f.displacementMap.value=c.displacementMap,f.displacementScale.value=c.displacementScale,f.displacementBias.value=c.displacementBias)):c instanceof THREE.MeshPhysicalMaterial?v(f,c):c instanceof THREE.MeshStandardMaterial?v(f,c):c instanceof THREE.MeshDepthMaterial?c.displacementMap&&(f.displacementMap.value=c.displacementMap,f.displacementScale.value=c.displacementScale,
f.displacementBias.value=c.displacementBias):c instanceof THREE.MeshNormalMaterial&&(f.opacity.value=c.opacity);THREE.WebGLUniforms.upload(t,e.uniformsList,f,W)}m.set(t,d,"modelViewMatrix");m.set(t,d,"normalMatrix");m.setValue(t,"modelMatrix",d.matrixWorld);e=e.dynamicUniforms;null!==e&&(THREE.WebGLUniforms.evalDynamic(e,f,d,a),THREE.WebGLUniforms.upload(t,e,f,W));return g}function v(a,b){a.roughness.value=b.roughness;a.metalness.value=b.metalness;b.roughnessMap&&(a.roughnessMap.value=b.roughnessMap);
b.metalnessMap&&(a.metalnessMap.value=b.metalnessMap);b.lightMap&&(a.lightMap.value=b.lightMap,a.lightMapIntensity.value=b.lightMapIntensity);b.emissiveMap&&(a.emissiveMap.value=b.emissiveMap);b.bumpMap&&(a.bumpMap.value=b.bumpMap,a.bumpScale.value=b.bumpScale);b.normalMap&&(a.normalMap.value=b.normalMap,a.normalScale.value.copy(b.normalScale));b.displacementMap&&(a.displacementMap.value=b.displacementMap,a.displacementScale.value=b.displacementScale,a.displacementBias.value=b.displacementBias);b.envMap&&
(a.envMapIntensity.value=b.envMapIntensity)}function C(a,b,c){c?(t.texParameteri(a,t.TEXTURE_WRAP_S,G(b.wrapS)),t.texParameteri(a,t.TEXTURE_WRAP_T,G(b.wrapT)),t.texParameteri(a,t.TEXTURE_MAG_FILTER,G(b.magFilter)),t.texParameteri(a,t.TEXTURE_MIN_FILTER,G(b.minFilter))):(t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),b.wrapS===THREE.ClampToEdgeWrapping&&b.wrapT===THREE.ClampToEdgeWrapping||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
b),t.texParameteri(a,t.TEXTURE_MAG_FILTER,B(b.magFilter)),t.texParameteri(a,t.TEXTURE_MIN_FILTER,B(b.minFilter)),b.minFilter!==THREE.NearestFilter&&b.minFilter!==THREE.LinearFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.",b));!(c=V.get("EXT_texture_filter_anisotropic"))||b.type===THREE.FloatType&&null===V.get("OES_texture_float_linear")||b.type===THREE.HalfFloatType&&null===V.get("OES_texture_half_float_linear")||
!(1<b.anisotropy||T.get(b).__currentAnisotropy)||(t.texParameterf(a,c.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(b.anisotropy,W.getMaxAnisotropy())),T.get(b).__currentAnisotropy=b.anisotropy)}function w(a,b){if(a.width>b||a.height>b){var c=b/Math.max(a.width,a.height),d=document.createElement("canvas");d.width=Math.floor(a.width*c);d.height=Math.floor(a.height*c);d.getContext("2d").drawImage(a,0,0,a.width,a.height,0,0,d.width,d.height);console.warn("THREE.WebGLRenderer: image is too big ("+a.width+"x"+a.height+
"). Resized to "+d.width+"x"+d.height,a);return d}return a}function D(a){return THREE.Math.isPowerOfTwo(a.width)&&THREE.Math.isPowerOfTwo(a.height)}function A(a,b,c,d){var e=G(b.texture.format),f=G(b.texture.type);J.texImage2D(d,0,e,b.width,b.height,0,e,f,null);t.bindFramebuffer(t.FRAMEBUFFER,a);t.framebufferTexture2D(t.FRAMEBUFFER,c,d,T.get(b.texture).__webglTexture,0);t.bindFramebuffer(t.FRAMEBUFFER,null)}function y(a,b){t.bindRenderbuffer(t.RENDERBUFFER,a);b.depthBuffer&&!b.stencilBuffer?(t.renderbufferStorage(t.RENDERBUFFER,
t.DEPTH_COMPONENT16,b.width,b.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,a)):b.depthBuffer&&b.stencilBuffer?(t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,b.width,b.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,a)):t.renderbufferStorage(t.RENDERBUFFER,t.RGBA4,b.width,b.height);t.bindRenderbuffer(t.RENDERBUFFER,null)}function B(a){return a===THREE.NearestFilter||a===THREE.NearestMipMapNearestFilter||a===THREE.NearestMipMapLinearFilter?
t.NEAREST:t.LINEAR}function G(a){var b;if(a===THREE.RepeatWrapping)return t.REPEAT;if(a===THREE.ClampToEdgeWrapping)return t.CLAMP_TO_EDGE;if(a===THREE.MirroredRepeatWrapping)return t.MIRRORED_REPEAT;if(a===THREE.NearestFilter)return t.NEAREST;if(a===THREE.NearestMipMapNearestFilter)return t.NEAREST_MIPMAP_NEAREST;if(a===THREE.NearestMipMapLinearFilter)return t.NEAREST_MIPMAP_LINEAR;if(a===THREE.LinearFilter)return t.LINEAR;if(a===THREE.LinearMipMapNearestFilter)return t.LINEAR_MIPMAP_NEAREST;if(a===
THREE.LinearMipMapLinearFilter)return t.LINEAR_MIPMAP_LINEAR;if(a===THREE.UnsignedByteType)return t.UNSIGNED_BYTE;if(a===THREE.UnsignedShort4444Type)return t.UNSIGNED_SHORT_4_4_4_4;if(a===THREE.UnsignedShort5551Type)return t.UNSIGNED_SHORT_5_5_5_1;if(a===THREE.UnsignedShort565Type)return t.UNSIGNED_SHORT_5_6_5;if(a===THREE.ByteType)return t.BYTE;if(a===THREE.ShortType)return t.SHORT;if(a===THREE.UnsignedShortType)return t.UNSIGNED_SHORT;if(a===THREE.IntType)return t.INT;if(a===THREE.UnsignedIntType)return t.UNSIGNED_INT;
if(a===THREE.FloatType)return t.FLOAT;b=V.get("OES_texture_half_float");if(null!==b&&a===THREE.HalfFloatType)return b.HALF_FLOAT_OES;if(a===THREE.AlphaFormat)return t.ALPHA;if(a===THREE.RGBFormat)return t.RGB;if(a===THREE.RGBAFormat)return t.RGBA;if(a===THREE.LuminanceFormat)return t.LUMINANCE;if(a===THREE.LuminanceAlphaFormat)return t.LUMINANCE_ALPHA;if(a===THREE.DepthFormat)return t.DEPTH_COMPONENT;if(a===THREE.AddEquation)return t.FUNC_ADD;if(a===THREE.SubtractEquation)return t.FUNC_SUBTRACT;if(a===
THREE.ReverseSubtractEquation)return t.FUNC_REVERSE_SUBTRACT;if(a===THREE.ZeroFactor)return t.ZERO;if(a===THREE.OneFactor)return t.ONE;if(a===THREE.SrcColorFactor)return t.SRC_COLOR;if(a===THREE.OneMinusSrcColorFactor)return t.ONE_MINUS_SRC_COLOR;if(a===THREE.SrcAlphaFactor)return t.SRC_ALPHA;if(a===THREE.OneMinusSrcAlphaFactor)return t.ONE_MINUS_SRC_ALPHA;if(a===THREE.DstAlphaFactor)return t.DST_ALPHA;if(a===THREE.OneMinusDstAlphaFactor)return t.ONE_MINUS_DST_ALPHA;if(a===THREE.DstColorFactor)return t.DST_COLOR;
if(a===THREE.OneMinusDstColorFactor)return t.ONE_MINUS_DST_COLOR;if(a===THREE.SrcAlphaSaturateFactor)return t.SRC_ALPHA_SATURATE;b=V.get("WEBGL_compressed_texture_s3tc");if(null!==b){if(a===THREE.RGB_S3TC_DXT1_Format)return b.COMPRESSED_RGB_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT1_Format)return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(a===THREE.RGBA_S3TC_DXT3_Format)return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(a===THREE.RGBA_S3TC_DXT5_Format)return b.COMPRESSED_RGBA_S3TC_DXT5_EXT}b=V.get("WEBGL_compressed_texture_pvrtc");
if(null!==b){if(a===THREE.RGB_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(a===THREE.RGB_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(a===THREE.RGBA_PVRTC_4BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(a===THREE.RGBA_PVRTC_2BPPV1_Format)return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}b=V.get("WEBGL_compressed_texture_etc1");if(null!==b&&a===THREE.RGB_ETC1_Format)return b.COMPRESSED_RGB_ETC1_WEBGL;b=V.get("EXT_blend_minmax");if(null!==b){if(a===THREE.MinEquation)return b.MIN_EXT;
if(a===THREE.MaxEquation)return b.MAX_EXT}return 0}console.log("THREE.WebGLRenderer",THREE.REVISION);a=a||{};var z=void 0!==a.canvas?a.canvas:document.createElement("canvas"),H=void 0!==a.context?a.context:null,M=void 0!==a.alpha?a.alpha:!1,O=void 0!==a.depth?a.depth:!0,N=void 0!==a.stencil?a.stencil:!0,E=void 0!==a.antialias?a.antialias:!1,K=void 0!==a.premultipliedAlpha?a.premultipliedAlpha:!0,I=void 0!==a.preserveDrawingBuffer?a.preserveDrawingBuffer:!1,L=[],P=[],Q=-1,R=[],F=-1,da=new Float32Array(8),
U=[],Y=[];this.domElement=z;this.context=null;this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.clippingPlanes=[];this.localClippingEnabled=!1;this.gammaFactor=2;this.physicallyCorrectLights=this.gammaOutput=this.gammaInput=!1;this.toneMapping=THREE.LinearToneMapping;this.toneMappingWhitePoint=this.toneMappingExposure=1;this.maxMorphTargets=8;this.maxMorphNormals=4;this.autoScaleCubemaps=!0;var W=this,fa=null,la=null,ga=null,Z=-1,oa="",ea=null,ra=
new THREE.Vector4,Aa=null,ma=new THREE.Vector4,ta=0,aa=new THREE.Color(0),ia=0,va=z.width,wa=z.height,$=1,ya=new THREE.Vector4(0,0,va,wa),Ca=!1,na=new THREE.Vector4(0,0,va,wa),Ba=new THREE.Frustum,ba=new THREE.WebGLClipping,ua=!1,za=!1,ka=new THREE.Sphere,sa=new THREE.Matrix4,X=new THREE.Vector3,S={hash:"",ambient:[0,0,0],directional:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadowMap:[],spotShadowMatrix:[],point:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],shadows:[]},
ja={geometries:0,textures:0},ha={calls:0,vertices:0,faces:0,points:0};this.info={render:ha,memory:ja,programs:null};var t;try{M={alpha:M,depth:O,stencil:N,antialias:E,premultipliedAlpha:K,preserveDrawingBuffer:I};t=H||z.getContext("webgl",M)||z.getContext("experimental-webgl",M);if(null===t){if(null!==z.getContext("webgl"))throw"Error creating WebGL context with your selected attributes.";throw"Error creating WebGL context.";}void 0===t.getShaderPrecisionFormat&&(t.getShaderPrecisionFormat=function(){return{rangeMin:1,
rangeMax:1,precision:1}});z.addEventListener("webglcontextlost",e,!1)}catch(Fa){console.error("THREE.WebGLRenderer: "+Fa)}var Da="undefined"!==typeof WebGL2RenderingContext&&t instanceof WebGL2RenderingContext,V=new THREE.WebGLExtensions(t);V.get("WEBGL_depth_texture");V.get("OES_texture_float");V.get("OES_texture_float_linear");V.get("OES_texture_half_float");V.get("OES_texture_half_float_linear");V.get("OES_standard_derivatives");V.get("ANGLE_instanced_arrays");V.get("OES_element_index_uint")&&
(THREE.BufferGeometry.MaxIndex=4294967296);var ca=new THREE.WebGLCapabilities(t,V,a),J=new THREE.WebGLState(t,V,G),T=new THREE.WebGLProperties,qa=new THREE.WebGLObjects(t,T,this.info),pa=new THREE.WebGLPrograms(this,ca),xa=new THREE.WebGLLights;this.info.programs=pa.programs;var Ga=new THREE.WebGLBufferRenderer(t,V,ha),Ha=new THREE.WebGLIndexedBufferRenderer(t,V,ha);c();this.context=t;this.capabilities=ca;this.extensions=V;this.properties=T;this.state=J;var Ea=new THREE.WebGLShadowMap(this,S,qa);
this.shadowMap=Ea;var Ia=new THREE.SpritePlugin(this,U),Ja=new THREE.LensFlarePlugin(this,Y);this.getContext=function(){return t};this.getContextAttributes=function(){return t.getContextAttributes()};this.forceContextLoss=function(){V.get("WEBGL_lose_context").loseContext()};this.getMaxAnisotropy=function(){var a;return function(){if(void 0!==a)return a;var b=V.get("EXT_texture_filter_anisotropic");return a=null!==b?t.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT):0}}();this.getPrecision=function(){return ca.precision};
this.getPixelRatio=function(){return $};this.setPixelRatio=function(a){void 0!==a&&($=a,this.setSize(na.z,na.w,!1))};this.getSize=function(){return{width:va,height:wa}};this.setSize=function(a,b,c){va=a;wa=b;z.width=a*$;z.height=b*$;!1!==c&&(z.style.width=a+"px",z.style.height=b+"px");this.setViewport(0,0,a,b)};this.setViewport=function(a,b,c,d){J.viewport(na.set(a,b,c,d))};this.setScissor=function(a,b,c,d){J.scissor(ya.set(a,b,c,d))};this.setScissorTest=function(a){J.setScissorTest(Ca=a)};this.getClearColor=
function(){return aa};this.setClearColor=function(a,c){aa.set(a);ia=void 0!==c?c:1;b(aa.r,aa.g,aa.b,ia)};this.getClearAlpha=function(){return ia};this.setClearAlpha=function(a){ia=a;b(aa.r,aa.g,aa.b,ia)};this.clear=function(a,b,c){var d=0;if(void 0===a||a)d|=t.COLOR_BUFFER_BIT;if(void 0===b||b)d|=t.DEPTH_BUFFER_BIT;if(void 0===c||c)d|=t.STENCIL_BUFFER_BIT;t.clear(d)};this.clearColor=function(){this.clear(!0,!1,!1)};this.clearDepth=function(){this.clear(!1,!0,!1)};this.clearStencil=function(){this.clear(!1,
!1,!0)};this.clearTarget=function(a,b,c,d){this.setRenderTarget(a);this.clear(b,c,d)};this.resetGLState=d;this.dispose=function(){z.removeEventListener("webglcontextlost",e,!1)};this.renderBufferImmediate=function(a,b,c){J.initAttributes();var d=T.get(a);a.hasPositions&&!d.position&&(d.position=t.createBuffer());a.hasNormals&&!d.normal&&(d.normal=t.createBuffer());a.hasUvs&&!d.uv&&(d.uv=t.createBuffer());a.hasColors&&!d.color&&(d.color=t.createBuffer());b=b.getAttributes();a.hasPositions&&(t.bindBuffer(t.ARRAY_BUFFER,
d.position),t.bufferData(t.ARRAY_BUFFER,a.positionArray,t.DYNAMIC_DRAW),J.enableAttribute(b.position),t.vertexAttribPointer(b.position,3,t.FLOAT,!1,0,0));if(a.hasNormals){t.bindBuffer(t.ARRAY_BUFFER,d.normal);if("MeshPhongMaterial"!==c.type&&"MeshStandardMaterial"!==c.type&&"MeshPhysicalMaterial"!==c.type&&c.shading===THREE.FlatShading)for(var e=0,f=3*a.count;e<f;e+=9){var g=a.normalArray,h=(g[e+0]+g[e+3]+g[e+6])/3,k=(g[e+1]+g[e+4]+g[e+7])/3,m=(g[e+2]+g[e+5]+g[e+8])/3;g[e+0]=h;g[e+1]=k;g[e+2]=m;g[e+
3]=h;g[e+4]=k;g[e+5]=m;g[e+6]=h;g[e+7]=k;g[e+8]=m}t.bufferData(t.ARRAY_BUFFER,a.normalArray,t.DYNAMIC_DRAW);J.enableAttribute(b.normal);t.vertexAttribPointer(b.normal,3,t.FLOAT,!1,0,0)}a.hasUvs&&c.map&&(t.bindBuffer(t.ARRAY_BUFFER,d.uv),t.bufferData(t.ARRAY_BUFFER,a.uvArray,t.DYNAMIC_DRAW),J.enableAttribute(b.uv),t.vertexAttribPointer(b.uv,2,t.FLOAT,!1,0,0));a.hasColors&&c.vertexColors!==THREE.NoColors&&(t.bindBuffer(t.ARRAY_BUFFER,d.color),t.bufferData(t.ARRAY_BUFFER,a.colorArray,t.DYNAMIC_DRAW),
J.enableAttribute(b.color),t.vertexAttribPointer(b.color,3,t.FLOAT,!1,0,0));J.disableUnusedAttributes();t.drawArrays(t.TRIANGLES,0,a.count);a.count=0};this.renderBufferDirect=function(a,b,c,d,e,f){u(d);var g=x(a,b,d,e),h=!1;a=c.id+"_"+g.id+"_"+d.wireframe;a!==oa&&(oa=a,h=!0);b=e.morphTargetInfluences;if(void 0!==b){a=[];for(var k=0,h=b.length;k<h;k++){var m=b[k];a.push([m,k])}a.sort(l);8<a.length&&(a.length=8);for(var p=c.morphAttributes,k=0,h=a.length;k<h;k++)m=a[k],da[k]=m[0],0!==m[0]?(b=m[1],!0===
d.morphTargets&&p.position&&c.addAttribute("morphTarget"+k,p.position[b]),!0===d.morphNormals&&p.normal&&c.addAttribute("morphNormal"+k,p.normal[b])):(!0===d.morphTargets&&c.removeAttribute("morphTarget"+k),!0===d.morphNormals&&c.removeAttribute("morphNormal"+k));g.getUniforms().setValue(t,"morphTargetInfluences",da);h=!0}b=c.index;k=c.attributes.position;!0===d.wireframe&&(b=qa.getWireframeAttribute(c));null!==b?(a=Ha,a.setIndex(b)):a=Ga;if(h){a:{var h=void 0,n;if(c instanceof THREE.InstancedBufferGeometry&&
(n=V.get("ANGLE_instanced_arrays"),null===n)){console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");break a}void 0===h&&(h=0);J.initAttributes();var m=c.attributes,g=g.getAttributes(),p=d.defaultAttributeValues,q;for(q in g){var r=g[q];if(0<=r){var s=m[q];if(void 0!==s){var v=t.FLOAT,w=s.array,E=s.normalized;w instanceof Float32Array?v=t.FLOAT:w instanceof Float64Array?console.warn("Unsupported data buffer format: Float64Array"):
w instanceof Uint16Array?v=t.UNSIGNED_SHORT:w instanceof Int16Array?v=t.SHORT:w instanceof Uint32Array?v=t.UNSIGNED_INT:w instanceof Int32Array?v=t.INT:w instanceof Int8Array?v=t.BYTE:w instanceof Uint8Array&&(v=t.UNSIGNED_BYTE);var w=s.itemSize,L=qa.getAttributeBuffer(s);if(s instanceof THREE.InterleavedBufferAttribute){var y=s.data,C=y.stride,s=s.offset;y instanceof THREE.InstancedInterleavedBuffer?(J.enableAttributeAndDivisor(r,y.meshPerAttribute,n),void 0===c.maxInstancedCount&&(c.maxInstancedCount=
y.meshPerAttribute*y.count)):J.enableAttribute(r);t.bindBuffer(t.ARRAY_BUFFER,L);t.vertexAttribPointer(r,w,v,E,C*y.array.BYTES_PER_ELEMENT,(h*C+s)*y.array.BYTES_PER_ELEMENT)}else s instanceof THREE.InstancedBufferAttribute?(J.enableAttributeAndDivisor(r,s.meshPerAttribute,n),void 0===c.maxInstancedCount&&(c.maxInstancedCount=s.meshPerAttribute*s.count)):J.enableAttribute(r),t.bindBuffer(t.ARRAY_BUFFER,L),t.vertexAttribPointer(r,w,v,E,0,h*w*s.array.BYTES_PER_ELEMENT)}else if(void 0!==p&&(v=p[q],void 0!==
v))switch(v.length){case 2:t.vertexAttrib2fv(r,v);break;case 3:t.vertexAttrib3fv(r,v);break;case 4:t.vertexAttrib4fv(r,v);break;default:t.vertexAttrib1fv(r,v)}}}J.disableUnusedAttributes()}null!==b&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,qa.getAttributeBuffer(b))}n=Infinity;null!==b?n=b.count:void 0!==k&&(n=k.count);q=c.drawRange.start;b=c.drawRange.count;k=null!==f?f.start:0;h=null!==f?f.count:Infinity;f=Math.max(0,q,k);n=Math.min(0+n,q+b,k+h)-1;n=Math.max(0,n-f+1);if(e instanceof THREE.Mesh)if(!0===
d.wireframe)J.setLineWidth(d.wireframeLinewidth*(null===la?$:1)),a.setMode(t.LINES);else switch(e.drawMode){case THREE.TrianglesDrawMode:a.setMode(t.TRIANGLES);break;case THREE.TriangleStripDrawMode:a.setMode(t.TRIANGLE_STRIP);break;case THREE.TriangleFanDrawMode:a.setMode(t.TRIANGLE_FAN)}else e instanceof THREE.Line?(d=d.linewidth,void 0===d&&(d=1),J.setLineWidth(d*(null===la?$:1)),e instanceof THREE.LineSegments?a.setMode(t.LINES):a.setMode(t.LINE_STRIP)):e instanceof THREE.Points&&a.setMode(t.POINTS);
c instanceof THREE.InstancedBufferGeometry?0<c.maxInstancedCount&&a.renderInstances(c,f,n):a.render(f,n)};this.render=function(a,b,c,d){if(!1===b instanceof THREE.Camera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else{var e=a.fog;oa="";Z=-1;ea=null;!0===a.autoUpdate&&a.updateMatrixWorld();null===b.parent&&b.updateMatrixWorld();b.matrixWorldInverse.getInverse(b.matrixWorld);sa.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);Ba.setFromMatrix(sa);
L.length=0;F=Q=-1;U.length=0;Y.length=0;za=this.localClippingEnabled;ua=ba.init(this.clippingPlanes,za,b);r(a,b);P.length=Q+1;R.length=F+1;!0===W.sortObjects&&(P.sort(n),R.sort(p));ua&&ba.beginShadows();for(var f=L,g=0,h=0,k=f.length;h<k;h++){var m=f[h];m.castShadow&&(S.shadows[g++]=m)}S.shadows.length=g;Ea.render(a,b);for(var f=L,l=m=0,q=0,v,x,u,w,E=b.matrixWorldInverse,y=0,C=0,A=0,I=0,g=0,h=f.length;g<h;g++)if(k=f[g],v=k.color,x=k.intensity,u=k.distance,w=k.shadow&&k.shadow.map?k.shadow.map.texture:
null,k instanceof THREE.AmbientLight)m+=v.r*x,l+=v.g*x,q+=v.b*x;else if(k instanceof THREE.DirectionalLight){var z=xa.get(k);z.color.copy(k.color).multiplyScalar(k.intensity);z.direction.setFromMatrixPosition(k.matrixWorld);X.setFromMatrixPosition(k.target.matrixWorld);z.direction.sub(X);z.direction.transformDirection(E);if(z.shadow=k.castShadow)z.shadowBias=k.shadow.bias,z.shadowRadius=k.shadow.radius,z.shadowMapSize=k.shadow.mapSize;S.directionalShadowMap[y]=w;S.directionalShadowMatrix[y]=k.shadow.matrix;
S.directional[y++]=z}else if(k instanceof THREE.SpotLight){z=xa.get(k);z.position.setFromMatrixPosition(k.matrixWorld);z.position.applyMatrix4(E);z.color.copy(v).multiplyScalar(x);z.distance=u;z.direction.setFromMatrixPosition(k.matrixWorld);X.setFromMatrixPosition(k.target.matrixWorld);z.direction.sub(X);z.direction.transformDirection(E);z.coneCos=Math.cos(k.angle);z.penumbraCos=Math.cos(k.angle*(1-k.penumbra));z.decay=0===k.distance?0:k.decay;if(z.shadow=k.castShadow)z.shadowBias=k.shadow.bias,
z.shadowRadius=k.shadow.radius,z.shadowMapSize=k.shadow.mapSize;S.spotShadowMap[A]=w;S.spotShadowMatrix[A]=k.shadow.matrix;S.spot[A++]=z}else if(k instanceof THREE.PointLight){z=xa.get(k);z.position.setFromMatrixPosition(k.matrixWorld);z.position.applyMatrix4(E);z.color.copy(k.color).multiplyScalar(k.intensity);z.distance=k.distance;z.decay=0===k.distance?0:k.decay;if(z.shadow=k.castShadow)z.shadowBias=k.shadow.bias,z.shadowRadius=k.shadow.radius,z.shadowMapSize=k.shadow.mapSize;S.pointShadowMap[C]=
w;void 0===S.pointShadowMatrix[C]&&(S.pointShadowMatrix[C]=new THREE.Matrix4);X.setFromMatrixPosition(k.matrixWorld).negate();S.pointShadowMatrix[C].identity().setPosition(X);S.point[C++]=z}else k instanceof THREE.HemisphereLight&&(z=xa.get(k),z.direction.setFromMatrixPosition(k.matrixWorld),z.direction.transformDirection(E),z.direction.normalize(),z.skyColor.copy(k.color).multiplyScalar(x),z.groundColor.copy(k.groundColor).multiplyScalar(x),S.hemi[I++]=z);S.ambient[0]=m;S.ambient[1]=l;S.ambient[2]=
q;S.directional.length=y;S.spot.length=A;S.point.length=C;S.hemi.length=I;S.hash=y+","+C+","+A+","+I+","+S.shadows.length;ua&&ba.endShadows();ha.calls=0;ha.vertices=0;ha.faces=0;ha.points=0;void 0===c&&(c=null);this.setRenderTarget(c);(this.autoClear||d)&&this.clear(this.autoClearColor,this.autoClearDepth,this.autoClearStencil);a.overrideMaterial?(d=a.overrideMaterial,s(P,b,e,d),s(R,b,e,d)):(J.setBlending(THREE.NoBlending),s(P,b,e),s(R,b,e));Ia.render(a,b);Ja.render(a,b,ma);c&&(a=c.texture,a.generateMipmaps&&
D(c)&&a.minFilter!==THREE.NearestFilter&&a.minFilter!==THREE.LinearFilter&&(a=c instanceof THREE.WebGLRenderTargetCube?t.TEXTURE_CUBE_MAP:t.TEXTURE_2D,c=T.get(c.texture).__webglTexture,J.bindTexture(a,c),t.generateMipmap(a),J.bindTexture(a,null)));J.setDepthTest(!0);J.setDepthWrite(!0);J.setColorWrite(!0)}};this.setFaceCulling=function(a,b){J.setCullFace(a);J.setFlipSided(b===THREE.FrontFaceDirectionCW)};this.allocTextureUnit=function(){var a=ta;a>=ca.maxTextures&&console.warn("WebGLRenderer: trying to use "+
a+" texture units while this GPU supports only "+ca.maxTextures);ta+=1;return a};this.setTexture2D=function(){var a=!1;return function(b,c){b instanceof THREE.WebGLRenderTarget&&(a||(console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);var d=b,e=T.get(d);if(0<d.version&&e.__version!==d.version){var g=d.image;if(void 0===g)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined",d);
else if(!1===g.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete",d);else{void 0===e.__webglInit&&(e.__webglInit=!0,d.addEventListener("dispose",f),e.__webglTexture=t.createTexture(),ja.textures++);J.activeTexture(t.TEXTURE0+c);J.bindTexture(t.TEXTURE_2D,e.__webglTexture);t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,d.flipY);t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,d.premultiplyAlpha);t.pixelStorei(t.UNPACK_ALIGNMENT,d.unpackAlignment);var h=w(d.image,ca.maxTextureSize);
if((d.wrapS!==THREE.ClampToEdgeWrapping||d.wrapT!==THREE.ClampToEdgeWrapping||d.minFilter!==THREE.NearestFilter&&d.minFilter!==THREE.LinearFilter)&&!1===D(h))if(g=h,g instanceof HTMLImageElement||g instanceof HTMLCanvasElement){var k=document.createElement("canvas");k.width=THREE.Math.nearestPowerOfTwo(g.width);k.height=THREE.Math.nearestPowerOfTwo(g.height);k.getContext("2d").drawImage(g,0,0,k.width,k.height);console.warn("THREE.WebGLRenderer: image is not power of two ("+g.width+"x"+g.height+"). Resized to "+
k.width+"x"+k.height,g);h=k}else h=g;var g=D(h),k=G(d.format),m=G(d.type);C(t.TEXTURE_2D,d,g);var l=d.mipmaps;if(d instanceof THREE.DepthTexture){l=t.DEPTH_COMPONENT;if(d.type===THREE.FloatType){if(!Da)throw Error("Float Depth Texture only supported in WebGL2.0");l=t.DEPTH_COMPONENT32F}else Da&&(l=t.DEPTH_COMPONENT16);J.texImage2D(t.TEXTURE_2D,0,l,h.width,h.height,0,k,m,null)}else if(d instanceof THREE.DataTexture)if(0<l.length&&g){for(var n=0,p=l.length;n<p;n++)h=l[n],J.texImage2D(t.TEXTURE_2D,n,
k,h.width,h.height,0,k,m,h.data);d.generateMipmaps=!1}else J.texImage2D(t.TEXTURE_2D,0,k,h.width,h.height,0,k,m,h.data);else if(d instanceof THREE.CompressedTexture)for(n=0,p=l.length;n<p;n++)h=l[n],d.format!==THREE.RGBAFormat&&d.format!==THREE.RGBFormat?-1<J.getCompressedTextureFormats().indexOf(k)?J.compressedTexImage2D(t.TEXTURE_2D,n,k,h.width,h.height,0,h.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):J.texImage2D(t.TEXTURE_2D,
n,k,h.width,h.height,0,k,m,h.data);else if(0<l.length&&g){n=0;for(p=l.length;n<p;n++)h=l[n],J.texImage2D(t.TEXTURE_2D,n,k,k,m,h);d.generateMipmaps=!1}else J.texImage2D(t.TEXTURE_2D,0,k,k,m,h);d.generateMipmaps&&g&&t.generateMipmap(t.TEXTURE_2D);e.__version=d.version;if(d.onUpdate)d.onUpdate(d)}}else J.activeTexture(t.TEXTURE0+c),J.bindTexture(t.TEXTURE_2D,e.__webglTexture)}}();this.setTexture=function(){var a=!1;return function(b,c){a||(console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
a=!0);W.setTexture2D(b,c)}}();this.setTextureCube=function(){var a=!1;return function(b,c){b instanceof THREE.WebGLRenderTargetCube&&(a||(console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."),a=!0),b=b.texture);if(b instanceof THREE.CubeTexture||Array.isArray(b.image)&&6===b.image.length){var d=b,e=T.get(d);if(6===d.image.length)if(0<d.version&&e.__version!==d.version){e.__image__webglTextureCube||(d.addEventListener("dispose",
f),e.__image__webglTextureCube=t.createTexture(),ja.textures++);J.activeTexture(t.TEXTURE0+c);J.bindTexture(t.TEXTURE_CUBE_MAP,e.__image__webglTextureCube);t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,d.flipY);for(var g=d instanceof THREE.CompressedTexture,h=d.image[0]instanceof THREE.DataTexture,k=[],m=0;6>m;m++)k[m]=!W.autoScaleCubemaps||g||h?h?d.image[m].image:d.image[m]:w(d.image[m],ca.maxCubemapSize);var l=D(k[0]),n=G(d.format),p=G(d.type);C(t.TEXTURE_CUBE_MAP,d,l);for(m=0;6>m;m++)if(g)for(var q,r=k[m].mipmaps,
s=0,x=r.length;s<x;s++)q=r[s],d.format!==THREE.RGBAFormat&&d.format!==THREE.RGBFormat?-1<J.getCompressedTextureFormats().indexOf(n)?J.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+m,s,n,q.width,q.height,0,q.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):J.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+m,s,n,q.width,q.height,0,n,p,q.data);else h?J.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+m,0,n,k[m].width,k[m].height,0,n,p,k[m].data):
J.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+m,0,n,n,p,k[m]);d.generateMipmaps&&l&&t.generateMipmap(t.TEXTURE_CUBE_MAP);e.__version=d.version;if(d.onUpdate)d.onUpdate(d)}else J.activeTexture(t.TEXTURE0+c),J.bindTexture(t.TEXTURE_CUBE_MAP,e.__image__webglTextureCube)}else d=b,J.activeTexture(t.TEXTURE0+c),J.bindTexture(t.TEXTURE_CUBE_MAP,T.get(d).__webglTexture)}}();this.getCurrentRenderTarget=function(){return la};this.setRenderTarget=function(a){if((la=a)&&void 0===T.get(a).__webglFramebuffer){var b=
T.get(a),c=T.get(a.texture);a.addEventListener("dispose",g);c.__webglTexture=t.createTexture();ja.textures++;var d=a instanceof THREE.WebGLRenderTargetCube,e=THREE.Math.isPowerOfTwo(a.width)&&THREE.Math.isPowerOfTwo(a.height);if(d){b.__webglFramebuffer=[];for(var f=0;6>f;f++)b.__webglFramebuffer[f]=t.createFramebuffer()}else b.__webglFramebuffer=t.createFramebuffer();if(d){J.bindTexture(t.TEXTURE_CUBE_MAP,c.__webglTexture);C(t.TEXTURE_CUBE_MAP,a.texture,e);for(f=0;6>f;f++)A(b.__webglFramebuffer[f],
a,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+f);a.texture.generateMipmaps&&e&&t.generateMipmap(t.TEXTURE_CUBE_MAP);J.bindTexture(t.TEXTURE_CUBE_MAP,null)}else J.bindTexture(t.TEXTURE_2D,c.__webglTexture),C(t.TEXTURE_2D,a.texture,e),A(b.__webglFramebuffer,a,t.COLOR_ATTACHMENT0,t.TEXTURE_2D),a.texture.generateMipmaps&&e&&t.generateMipmap(t.TEXTURE_2D),J.bindTexture(t.TEXTURE_2D,null);if(a.depthBuffer){b=T.get(a);c=a instanceof THREE.WebGLRenderTargetCube;if(a.depthTexture){if(c)throw Error("target.depthTexture not supported in Cube render targets");
if(a instanceof THREE.WebGLRenderTargetCube)throw Error("Depth Texture with cube render targets is not supported!");t.bindFramebuffer(t.FRAMEBUFFER,b.__webglFramebuffer);if(!(a.depthTexture instanceof THREE.DepthTexture))throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");T.get(a.depthTexture).__webglTexture&&a.depthTexture.image.width===a.width&&a.depthTexture.image.height===a.height||(a.depthTexture.image.width=a.width,a.depthTexture.image.height=a.height,a.depthTexture.needsUpdate=
!0);W.setTexture2D(a.depthTexture,0);b=T.get(a.depthTexture).__webglTexture;t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,b,0)}else if(c)for(b.__webglDepthbuffer=[],c=0;6>c;c++)t.bindFramebuffer(t.FRAMEBUFFER,b.__webglFramebuffer[c]),b.__webglDepthbuffer[c]=t.createRenderbuffer(),y(b.__webglDepthbuffer[c],a);else t.bindFramebuffer(t.FRAMEBUFFER,b.__webglFramebuffer),b.__webglDepthbuffer=t.createRenderbuffer(),y(b.__webglDepthbuffer,a);t.bindFramebuffer(t.FRAMEBUFFER,null)}}b=
a instanceof THREE.WebGLRenderTargetCube;a?(c=T.get(a),c=b?c.__webglFramebuffer[a.activeCubeFace]:c.__webglFramebuffer,ra.copy(a.scissor),Aa=a.scissorTest,ma.copy(a.viewport)):(c=null,ra.copy(ya).multiplyScalar($),Aa=Ca,ma.copy(na).multiplyScalar($));ga!==c&&(t.bindFramebuffer(t.FRAMEBUFFER,c),ga=c);J.scissor(ra);J.setScissorTest(Aa);J.viewport(ma);b&&(b=T.get(a.texture),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+a.activeCubeFace,b.__webglTexture,a.activeMipMapLevel))};
this.readRenderTargetPixels=function(a,b,c,d,e,f){if(!1===a instanceof THREE.WebGLRenderTarget)console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");else{var g=T.get(a).__webglFramebuffer;if(g){var h=!1;g!==ga&&(t.bindFramebuffer(t.FRAMEBUFFER,g),h=!0);try{var k=a.texture;k.format!==THREE.RGBAFormat&&G(k.format)!==t.getParameter(t.IMPLEMENTATION_COLOR_READ_FORMAT)?console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."):
k.type===THREE.UnsignedByteType||G(k.type)===t.getParameter(t.IMPLEMENTATION_COLOR_READ_TYPE)||k.type===THREE.FloatType&&V.get("WEBGL_color_buffer_float")||k.type===THREE.HalfFloatType&&V.get("EXT_color_buffer_half_float")?t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE?0<=b&&b<=a.width-d&&0<=c&&c<=a.height-e&&t.readPixels(b,c,d,e,G(k.format),G(k.type),f):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."):console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")}finally{h&&
t.bindFramebuffer(t.FRAMEBUFFER,ga)}}}}};
THREE.WebGLRenderTarget=function(a,b,c){this.uuid=THREE.Math.generateUUID();this.width=a;this.height=b;this.scissor=new THREE.Vector4(0,0,a,b);this.scissorTest=!1;this.viewport=new THREE.Vector4(0,0,a,b);c=c||{};void 0===c.minFilter&&(c.minFilter=THREE.LinearFilter);this.texture=new THREE.Texture(void 0,void 0,c.wrapS,c.wrapT,c.magFilter,c.minFilter,c.format,c.type,c.anisotropy,c.encoding);this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:
!0;this.depthTexture=null};
Object.assign(THREE.WebGLRenderTarget.prototype,THREE.EventDispatcher.prototype,{setSize:function(a,b){if(this.width!==a||this.height!==b)this.width=a,this.height=b,this.dispose();this.viewport.set(0,0,a,b);this.scissor.set(0,0,a,b)},clone:function(){return(new this.constructor).copy(this)},copy:function(a){this.width=a.width;this.height=a.height;this.viewport.copy(a.viewport);this.texture=a.texture.clone();this.depthBuffer=a.depthBuffer;this.stencilBuffer=a.stencilBuffer;this.depthTexture=a.depthTexture;
return this},dispose:function(){this.dispatchEvent({type:"dispose"})}});THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeMipMapLevel=this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube.prototype.constructor=THREE.WebGLRenderTargetCube;
THREE.WebGLBufferRenderer=function(a,b,c){var d;this.setMode=function(a){d=a};this.render=function(b,f){a.drawArrays(d,b,f);c.calls++;c.vertices+=f;d===a.TRIANGLES&&(c.faces+=f/3)};this.renderInstances=function(e){var f=b.get("ANGLE_instanced_arrays");if(null===f)console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");else{var g=e.attributes.position,h=0,h=g instanceof THREE.InterleavedBufferAttribute?g.data.count:
g.count;f.drawArraysInstancedANGLE(d,0,h,e.maxInstancedCount);c.calls++;c.vertices+=h*e.maxInstancedCount;d===a.TRIANGLES&&(c.faces+=e.maxInstancedCount*h/3)}}};
THREE.WebGLClipping=function(){function a(){l.value!==d&&(l.value=d,l.needsUpdate=0<e);c.numPlanes=e}function b(a,b,d,e){var f=null!==a?a.length:0,g=null;if(0!==f){g=l.value;if(!0!==e||null===g){e=d+4*f;b=b.matrixWorldInverse;k.getNormalMatrix(b);if(null===g||g.length<e)g=new Float32Array(e);for(e=0;e!==f;++e,d+=4)h.copy(a[e]).applyMatrix4(b,k),h.normal.toArray(g,d),g[d+3]=h.constant}l.value=g;l.needsUpdate=!0}c.numPlanes=f;return g}var c=this,d=null,e=0,f=!1,g=!1,h=new THREE.Plane,k=new THREE.Matrix3,
l={value:null,needsUpdate:!1};this.uniform=l;this.numPlanes=0;this.init=function(a,c,g){var h=0!==a.length||c||0!==e||f;f=c;d=b(a,g,0);e=a.length;return h};this.beginShadows=function(){g=!0;b(null)};this.endShadows=function(){g=!1;a()};this.setState=function(c,h,k,q,r){if(!f||null===c||0===c.length||g&&!h)g?b(null):a();else{h=g?0:e;var s=4*h,u=q.clippingState||null;l.value=u;u=b(c,k,s,r);for(c=0;c!==s;++c)u[c]=d[c];q.clippingState=u;this.numPlanes+=h}}};
THREE.WebGLIndexedBufferRenderer=function(a,b,c){var d,e,f;this.setMode=function(a){d=a};this.setIndex=function(c){c.array instanceof Uint32Array&&b.get("OES_element_index_uint")?(e=a.UNSIGNED_INT,f=4):(e=a.UNSIGNED_SHORT,f=2)};this.render=function(b,h){a.drawElements(d,h,e,b*f);c.calls++;c.vertices+=h;d===a.TRIANGLES&&(c.faces+=h/3)};this.renderInstances=function(g,h,k){var l=b.get("ANGLE_instanced_arrays");null===l?console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."):
(l.drawElementsInstancedANGLE(d,k,e,h*f,g.maxInstancedCount),c.calls++,c.vertices+=k*g.maxInstancedCount,d===a.TRIANGLES&&(c.faces+=g.maxInstancedCount*k/3))}};
THREE.WebGLExtensions=function(a){var b={};this.get=function(c){if(void 0!==b[c])return b[c];var d;switch(c){case "WEBGL_depth_texture":d=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case "EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case "WEBGL_compressed_texture_s3tc":d=
a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case "WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;case "WEBGL_compressed_texture_etc1":d=a.getExtension("WEBGL_compressed_texture_etc1");break;default:d=a.getExtension(c)}null===d&&console.warn("THREE.WebGLRenderer: "+c+" extension not supported.");
return b[c]=d}};
THREE.WebGLCapabilities=function(a,b,c){function d(b){if("highp"===b){if(0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.HIGH_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.HIGH_FLOAT).precision)return"highp";b="mediump"}return"mediump"===b&&0<a.getShaderPrecisionFormat(a.VERTEX_SHADER,a.MEDIUM_FLOAT).precision&&0<a.getShaderPrecisionFormat(a.FRAGMENT_SHADER,a.MEDIUM_FLOAT).precision?"mediump":"lowp"}this.getMaxPrecision=d;this.precision=void 0!==c.precision?c.precision:"highp";
this.logarithmicDepthBuffer=void 0!==c.logarithmicDepthBuffer?c.logarithmicDepthBuffer:!1;this.maxTextures=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);this.maxVertexTextures=a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS);this.maxTextureSize=a.getParameter(a.MAX_TEXTURE_SIZE);this.maxCubemapSize=a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE);this.maxAttributes=a.getParameter(a.MAX_VERTEX_ATTRIBS);this.maxVertexUniforms=a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);this.maxVaryings=a.getParameter(a.MAX_VARYING_VECTORS);
this.maxFragmentUniforms=a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);this.vertexTextures=0<this.maxVertexTextures;this.floatFragmentTextures=!!b.get("OES_texture_float");this.floatVertexTextures=this.vertexTextures&&this.floatFragmentTextures;c=d(this.precision);c!==this.precision&&(console.warn("THREE.WebGLRenderer:",this.precision,"not supported, using",c,"instead."),this.precision=c);this.logarithmicDepthBuffer&&(this.logarithmicDepthBuffer=!!b.get("EXT_frag_depth"))};
THREE.WebGLGeometries=function(a,b,c){function d(a){var h=a.target;a=f[h.id];null!==a.index&&e(a.index);var k=a.attributes,l;for(l in k)e(k[l]);h.removeEventListener("dispose",d);delete f[h.id];l=b.get(h);l.wireframe&&e(l.wireframe);b.delete(h);h=b.get(a);h.wireframe&&e(h.wireframe);b.delete(a);c.memory.geometries--}function e(c){var d;d=c instanceof THREE.InterleavedBufferAttribute?b.get(c.data).__webglBuffer:b.get(c).__webglBuffer;void 0!==d&&(a.deleteBuffer(d),c instanceof THREE.InterleavedBufferAttribute?
b.delete(c.data):b.delete(c))}var f={};this.get=function(a){var b=a.geometry;if(void 0!==f[b.id])return f[b.id];b.addEventListener("dispose",d);var e;b instanceof THREE.BufferGeometry?e=b:b instanceof THREE.Geometry&&(void 0===b._bufferGeometry&&(b._bufferGeometry=(new THREE.BufferGeometry).setFromObject(a)),e=b._bufferGeometry);f[b.id]=e;c.memory.geometries++;return e}};
THREE.WebGLLights=function(){var a={};this.get=function(b){if(void 0!==a[b.id])return a[b.id];var c;switch(b.type){case "DirectionalLight":c={direction:new THREE.Vector3,color:new THREE.Color,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new THREE.Vector2};break;case "SpotLight":c={position:new THREE.Vector3,direction:new THREE.Vector3,color:new THREE.Color,distance:0,coneCos:0,penumbraCos:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new THREE.Vector2};break;case "PointLight":c=
{position:new THREE.Vector3,color:new THREE.Color,distance:0,decay:0,shadow:!1,shadowBias:0,shadowRadius:1,shadowMapSize:new THREE.Vector2};break;case "HemisphereLight":c={direction:new THREE.Vector3,skyColor:new THREE.Color,groundColor:new THREE.Color}}return a[b.id]=c}};
THREE.WebGLObjects=function(a,b,c){function d(c,d){var e=c instanceof THREE.InterleavedBufferAttribute?c.data:c,f=b.get(e);void 0===f.__webglBuffer?(f.__webglBuffer=a.createBuffer(),a.bindBuffer(d,f.__webglBuffer),a.bufferData(d,e.array,e.dynamic?a.DYNAMIC_DRAW:a.STATIC_DRAW),f.version=e.version):f.version!==e.version&&(a.bindBuffer(d,f.__webglBuffer),!1===e.dynamic||-1===e.updateRange.count?a.bufferSubData(d,0,e.array):0===e.updateRange.count?console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."):
(a.bufferSubData(d,e.updateRange.offset*e.array.BYTES_PER_ELEMENT,e.array.subarray(e.updateRange.offset,e.updateRange.offset+e.updateRange.count)),e.updateRange.count=0),f.version=e.version)}function e(a,b,c){if(b>c){var d=b;b=c;c=d}d=a[b];return void 0===d?(a[b]=[c],!0):-1===d.indexOf(c)?(d.push(c),!0):!1}var f=new THREE.WebGLGeometries(a,b,c);this.getAttributeBuffer=function(a){return a instanceof THREE.InterleavedBufferAttribute?b.get(a.data).__webglBuffer:b.get(a).__webglBuffer};this.getWireframeAttribute=
function(c){var f=b.get(c);if(void 0!==f.wireframe)return f.wireframe;var k=[],l=c.index,n=c.attributes;c=n.position;if(null!==l)for(var n={},l=l.array,p=0,m=l.length;p<m;p+=3){var q=l[p+0],r=l[p+1],s=l[p+2];e(n,q,r)&&k.push(q,r);e(n,r,s)&&k.push(r,s);e(n,s,q)&&k.push(s,q)}else for(l=n.position.array,p=0,m=l.length/3-1;p<m;p+=3)q=p+0,r=p+1,s=p+2,k.push(q,r,r,s,s,q);k=new THREE.BufferAttribute(new (65535<c.count?Uint32Array:Uint16Array)(k),1);d(k,a.ELEMENT_ARRAY_BUFFER);return f.wireframe=k};this.update=
function(b){var c=f.get(b);b.geometry instanceof THREE.Geometry&&c.updateFromObject(b);b=c.index;var e=c.attributes;null!==b&&d(b,a.ELEMENT_ARRAY_BUFFER);for(var l in e)d(e[l],a.ARRAY_BUFFER);b=c.morphAttributes;for(l in b)for(var e=b[l],n=0,p=e.length;n<p;n++)d(e[n],a.ARRAY_BUFFER);return c}};
THREE.WebGLProgram=function(){function a(a){switch(a){case THREE.LinearEncoding:return["Linear","( value )"];case THREE.sRGBEncoding:return["sRGB","( value )"];case THREE.RGBEEncoding:return["RGBE","( value )"];case THREE.RGBM7Encoding:return["RGBM","( value, 7.0 )"];case THREE.RGBM16Encoding:return["RGBM","( value, 16.0 )"];case THREE.RGBDEncoding:return["RGBD","( value, 256.0 )"];case THREE.GammaEncoding:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:throw Error("unsupported encoding: "+
a);}}function b(b,c){var d=a(c);return"vec4 "+b+"( vec4 value ) { return "+d[0]+"ToLinear"+d[1]+"; }"}function c(b,c){var d=a(c);return"vec4 "+b+"( vec4 value ) { return LinearTo"+d[0]+d[1]+"; }"}function d(a,b){var c;switch(b){case THREE.LinearToneMapping:c="Linear";break;case THREE.ReinhardToneMapping:c="Reinhard";break;case THREE.Uncharted2ToneMapping:c="Uncharted2";break;case THREE.CineonToneMapping:c="OptimizedCineon";break;default:throw Error("unsupported toneMapping: "+b);}return"vec3 "+a+
"( vec3 color ) { return "+c+"ToneMapping( color ); }"}function e(a,b,c){a=a||{};return[a.derivatives||b.envMapCubeUV||b.bumpMap||b.normalMap||b.flatShading?"#extension GL_OES_standard_derivatives : enable":"",(a.fragDepth||b.logarithmicDepthBuffer)&&c.get("EXT_frag_depth")?"#extension GL_EXT_frag_depth : enable":"",a.drawBuffers&&c.get("WEBGL_draw_buffers")?"#extension GL_EXT_draw_buffers : require":"",(a.shaderTextureLOD||b.envMap)&&c.get("EXT_shader_texture_lod")?"#extension GL_EXT_shader_texture_lod : enable":
""].filter(g).join("\n")}function f(a){var b=[],c;for(c in a){var d=a[c];!1!==d&&b.push("#define "+c+" "+d)}return b.join("\n")}function g(a){return""!==a}function h(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights)}function k(a){return a.replace(/#include +<([\w\d.]+)>/g,function(a,b){var c=THREE.ShaderChunk[b];if(void 0===c)throw Error("Can not resolve #include <"+
b+">");return k(c)})}function l(a){return a.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,function(a,b,c,d){a="";for(b=parseInt(b);b<parseInt(c);b++)a+=d.replace(/\[ i \]/g,"[ "+b+" ]");return a})}var n=0;return function(a,m,q,r){var s=a.context,u=q.extensions,x=q.defines,v=q.__webglShader.vertexShader,C=q.__webglShader.fragmentShader,w="SHADOWMAP_TYPE_BASIC";r.shadowMapType===THREE.PCFShadowMap?w="SHADOWMAP_TYPE_PCF":r.shadowMapType===THREE.PCFSoftShadowMap&&(w="SHADOWMAP_TYPE_PCF_SOFT");
var D="ENVMAP_TYPE_CUBE",A="ENVMAP_MODE_REFLECTION",y="ENVMAP_BLENDING_MULTIPLY";if(r.envMap){switch(q.envMap.mapping){case THREE.CubeReflectionMapping:case THREE.CubeRefractionMapping:D="ENVMAP_TYPE_CUBE";break;case THREE.CubeUVReflectionMapping:case THREE.CubeUVRefractionMapping:D="ENVMAP_TYPE_CUBE_UV";break;case THREE.EquirectangularReflectionMapping:case THREE.EquirectangularRefractionMapping:D="ENVMAP_TYPE_EQUIREC";break;case THREE.SphericalReflectionMapping:D="ENVMAP_TYPE_SPHERE"}switch(q.envMap.mapping){case THREE.CubeRefractionMapping:case THREE.EquirectangularRefractionMapping:A=
"ENVMAP_MODE_REFRACTION"}switch(q.combine){case THREE.MultiplyOperation:y="ENVMAP_BLENDING_MULTIPLY";break;case THREE.MixOperation:y="ENVMAP_BLENDING_MIX";break;case THREE.AddOperation:y="ENVMAP_BLENDING_ADD"}}var B=0<a.gammaFactor?a.gammaFactor:1,u=e(u,r,a.extensions),G=f(x),z=s.createProgram();q instanceof THREE.RawShaderMaterial?w=x="":(x=["precision "+r.precision+" float;","precision "+r.precision+" int;","#define SHADER_NAME "+q.__webglShader.name,G,r.supportsVertexTextures?"#define VERTEX_TEXTURES":
"","#define GAMMA_FACTOR "+B,"#define MAX_BONES "+r.maxBones,r.map?"#define USE_MAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+A:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.displacementMap&&r.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?
"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.vertexColors?"#define USE_COLOR":"",r.flatShading?"#define FLAT_SHADED":"",r.skinning?"#define USE_SKINNING":"",r.useVertexTexture?"#define BONE_TEXTURE":"",r.morphTargets?"#define USE_MORPHTARGETS":"",r.morphNormals&&!1===r.flatShading?"#define USE_MORPHNORMALS":"",r.doubleSided?"#define DOUBLE_SIDED":"",r.flipSided?"#define FLIP_SIDED":"","#define NUM_CLIPPING_PLANES "+r.numClippingPlanes,r.shadowMapEnabled?"#define USE_SHADOWMAP":
"",r.shadowMapEnabled?"#define "+w:"",r.sizeAttenuation?"#define USE_SIZEATTENUATION":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&a.extensions.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_COLOR",
"\tattribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;",
"\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(g).join("\n"),w=[u,"precision "+r.precision+" float;","precision "+r.precision+" int;","#define SHADER_NAME "+q.__webglShader.name,G,r.alphaTest?"#define ALPHATEST "+r.alphaTest:"","#define GAMMA_FACTOR "+B,r.useFog&&r.fog?"#define USE_FOG":"",r.useFog&&r.fogExp?"#define FOG_EXP2":"",r.map?"#define USE_MAP":"",r.envMap?"#define USE_ENVMAP":"",r.envMap?"#define "+D:"",r.envMap?
"#define "+A:"",r.envMap?"#define "+y:"",r.lightMap?"#define USE_LIGHTMAP":"",r.aoMap?"#define USE_AOMAP":"",r.emissiveMap?"#define USE_EMISSIVEMAP":"",r.bumpMap?"#define USE_BUMPMAP":"",r.normalMap?"#define USE_NORMALMAP":"",r.specularMap?"#define USE_SPECULARMAP":"",r.roughnessMap?"#define USE_ROUGHNESSMAP":"",r.metalnessMap?"#define USE_METALNESSMAP":"",r.alphaMap?"#define USE_ALPHAMAP":"",r.vertexColors?"#define USE_COLOR":"",r.flatShading?"#define FLAT_SHADED":"",r.doubleSided?"#define DOUBLE_SIDED":
"",r.flipSided?"#define FLIP_SIDED":"","#define NUM_CLIPPING_PLANES "+r.numClippingPlanes,r.shadowMapEnabled?"#define USE_SHADOWMAP":"",r.shadowMapEnabled?"#define "+w:"",r.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",r.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",r.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",r.logarithmicDepthBuffer&&a.extensions.get("EXT_frag_depth")?"#define USE_LOGDEPTHBUF_EXT":"",r.envMap&&a.extensions.get("EXT_shader_texture_lod")?"#define TEXTURE_LOD_EXT":
"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;",r.toneMapping!==THREE.NoToneMapping?"#define TONE_MAPPING":"",r.toneMapping!==THREE.NoToneMapping?THREE.ShaderChunk.tonemapping_pars_fragment:"",r.toneMapping!==THREE.NoToneMapping?d("toneMapping",r.toneMapping):"",r.outputEncoding||r.mapEncoding||r.envMapEncoding||r.emissiveMapEncoding?THREE.ShaderChunk.encodings_pars_fragment:"",r.mapEncoding?b("mapTexelToLinear",r.mapEncoding):"",r.envMapEncoding?b("envMapTexelToLinear",r.envMapEncoding):
"",r.emissiveMapEncoding?b("emissiveMapTexelToLinear",r.emissiveMapEncoding):"",r.outputEncoding?c("linearToOutputTexel",r.outputEncoding):"",r.depthPacking?"#define DEPTH_PACKING "+q.depthPacking:"","\n"].filter(g).join("\n"));v=k(v,r);v=h(v,r);C=k(C,r);C=h(C,r);!1===q instanceof THREE.ShaderMaterial&&(v=l(v),C=l(C));C=w+C;v=THREE.WebGLShader(s,s.VERTEX_SHADER,x+v);C=THREE.WebGLShader(s,s.FRAGMENT_SHADER,C);s.attachShader(z,v);s.attachShader(z,C);void 0!==q.index0AttributeName?s.bindAttribLocation(z,
0,q.index0AttributeName):!0===r.morphTargets&&s.bindAttribLocation(z,0,"position");s.linkProgram(z);r=s.getProgramInfoLog(z);D=s.getShaderInfoLog(v);A=s.getShaderInfoLog(C);B=y=!0;if(!1===s.getProgramParameter(z,s.LINK_STATUS))y=!1,console.error("THREE.WebGLProgram: shader error: ",s.getError(),"gl.VALIDATE_STATUS",s.getProgramParameter(z,s.VALIDATE_STATUS),"gl.getProgramInfoLog",r,D,A);else if(""!==r)console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",r);else if(""===D||""===A)B=!1;B&&(this.diagnostics=
{runnable:y,material:q,programLog:r,vertexShader:{log:D,prefix:x},fragmentShader:{log:A,prefix:w}});s.deleteShader(v);s.deleteShader(C);var H;this.getUniforms=function(){void 0===H&&(H=new THREE.WebGLUniforms(s,z,a));return H};var M;this.getAttributes=function(){if(void 0===M){for(var a={},b=s.getProgramParameter(z,s.ACTIVE_ATTRIBUTES),c=0;c<b;c++){var d=s.getActiveAttrib(z,c).name;a[d]=s.getAttribLocation(z,d)}M=a}return M};this.destroy=function(){s.deleteProgram(z);this.program=void 0};Object.defineProperties(this,
{uniforms:{get:function(){console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");return this.getUniforms()}},attributes:{get:function(){console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");return this.getAttributes()}}});this.id=n++;this.code=m;this.usedTimes=1;this.program=z;this.vertexShader=v;this.fragmentShader=C;return this}}();
THREE.WebGLPrograms=function(a,b){function c(a,b){var c;a?a instanceof THREE.Texture?c=a.encoding:a instanceof THREE.WebGLRenderTarget&&(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),c=a.texture.encoding):c=THREE.LinearEncoding;c===THREE.LinearEncoding&&b&&(c=THREE.GammaEncoding);return c}var d=[],e={MeshDepthMaterial:"depth",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",
MeshPhongMaterial:"phong",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points"},f="precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes depthPacking".split(" ");
this.getParameters=function(d,f,k,l,n){var p=e[d.type],m;b.floatVertexTextures&&n&&n.skeleton&&n.skeleton.useVertexTexture?m=1024:(m=Math.floor((b.maxVertexUniforms-20)/4),void 0!==n&&n instanceof THREE.SkinnedMesh&&(m=Math.min(n.skeleton.bones.length,m),m<n.skeleton.bones.length&&console.warn("WebGLRenderer: too many bones - "+n.skeleton.bones.length+", this GPU supports just "+m+" (try OpenGL instead of ANGLE)")));var q=a.getPrecision();null!==d.precision&&(q=b.getMaxPrecision(d.precision),q!==
d.precision&&console.warn("THREE.WebGLProgram.getParameters:",d.precision,"not supported, using",q,"instead."));var r=a.getCurrentRenderTarget();return{shaderID:p,precision:q,supportsVertexTextures:b.vertexTextures,outputEncoding:c(r?r.texture:null,a.gammaOutput),map:!!d.map,mapEncoding:c(d.map,a.gammaInput),envMap:!!d.envMap,envMapMode:d.envMap&&d.envMap.mapping,envMapEncoding:c(d.envMap,a.gammaInput),envMapCubeUV:!!d.envMap&&(d.envMap.mapping===THREE.CubeUVReflectionMapping||d.envMap.mapping===
THREE.CubeUVRefractionMapping),lightMap:!!d.lightMap,aoMap:!!d.aoMap,emissiveMap:!!d.emissiveMap,emissiveMapEncoding:c(d.emissiveMap,a.gammaInput),bumpMap:!!d.bumpMap,normalMap:!!d.normalMap,displacementMap:!!d.displacementMap,roughnessMap:!!d.roughnessMap,metalnessMap:!!d.metalnessMap,specularMap:!!d.specularMap,alphaMap:!!d.alphaMap,combine:d.combine,vertexColors:d.vertexColors,fog:k,useFog:d.fog,fogExp:k instanceof THREE.FogExp2,flatShading:d.shading===THREE.FlatShading,sizeAttenuation:d.sizeAttenuation,
logarithmicDepthBuffer:b.logarithmicDepthBuffer,skinning:d.skinning,maxBones:m,useVertexTexture:b.floatVertexTextures&&n&&n.skeleton&&n.skeleton.useVertexTexture,morphTargets:d.morphTargets,morphNormals:d.morphNormals,maxMorphTargets:a.maxMorphTargets,maxMorphNormals:a.maxMorphNormals,numDirLights:f.directional.length,numPointLights:f.point.length,numSpotLights:f.spot.length,numHemiLights:f.hemi.length,numClippingPlanes:l,shadowMapEnabled:a.shadowMap.enabled&&n.receiveShadow&&0<f.shadows.length,shadowMapType:a.shadowMap.type,
toneMapping:a.toneMapping,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:d.premultipliedAlpha,alphaTest:d.alphaTest,doubleSided:d.side===THREE.DoubleSide,flipSided:d.side===THREE.BackSide,depthPacking:void 0!==d.depthPacking?d.depthPacking:!1}};this.getProgramCode=function(a,b){var c=[];b.shaderID?c.push(b.shaderID):(c.push(a.fragmentShader),c.push(a.vertexShader));if(void 0!==a.defines)for(var d in a.defines)c.push(d),c.push(a.defines[d]);for(d=0;d<f.length;d++)c.push(b[f[d]]);
return c.join()};this.acquireProgram=function(b,c,e){for(var f,n=0,p=d.length;n<p;n++){var m=d[n];if(m.code===e){f=m;++f.usedTimes;break}}void 0===f&&(f=new THREE.WebGLProgram(a,e,b,c),d.push(f));return f};this.releaseProgram=function(a){if(0===--a.usedTimes){var b=d.indexOf(a);d[b]=d[d.length-1];d.pop();a.destroy()}};this.programs=d};
THREE.WebGLProperties=function(){var a={};this.get=function(b){b=b.uuid;var c=a[b];void 0===c&&(c={},a[b]=c);return c};this.delete=function(b){delete a[b.uuid]};this.clear=function(){a={}}};
THREE.WebGLShader=function(){function a(a){a=a.split("\n");for(var c=0;c<a.length;c++)a[c]=c+1+": "+a[c];return a.join("\n")}return function(b,c,d){var e=b.createShader(c);b.shaderSource(e,d);b.compileShader(e);!1===b.getShaderParameter(e,b.COMPILE_STATUS)&&console.error("THREE.WebGLShader: Shader couldn't compile.");""!==b.getShaderInfoLog(e)&&console.warn("THREE.WebGLShader: gl.getShaderInfoLog()",c===b.VERTEX_SHADER?"vertex":"fragment",b.getShaderInfoLog(e),a(d));return e}}();
THREE.WebGLShadowMap=function(a,b,c){function d(b,c,d,e){var f=b.geometry,g=null,g=r,h=b.customDepthMaterial;d&&(g=s,h=b.customDistanceMaterial);h?g=h:(b=b instanceof THREE.SkinnedMesh&&c.skinning,h=0,void 0!==f.morphTargets&&0<f.morphTargets.length&&c.morphTargets&&(h|=1),b&&(h|=2),g=g[h]);a.localClippingEnabled&&!0===c.clipShadows&&0!==c.clippingPlanes.length&&(h=g.uuid,f=c.uuid,b=u[h],void 0===b&&(b={},u[h]=b),h=b[f],void 0===h&&(h=g.clone(),b[f]=h),g=h);g.visible=c.visible;g.wireframe=c.wireframe;
f=c.side;z.renderSingleSided&&f==THREE.DoubleSide&&(f=THREE.FrontSide);z.renderReverseSided&&(f===THREE.FrontSide?f=THREE.BackSide:f===THREE.BackSide&&(f=THREE.FrontSide));g.side=f;g.clipShadows=c.clipShadows;g.clippingPlanes=c.clippingPlanes;g.wireframeLinewidth=c.wireframeLinewidth;g.linewidth=c.linewidth;d&&void 0!==g.uniforms.lightPos&&g.uniforms.lightPos.value.copy(e);return g}function e(a,b,c){if(!1!==a.visible){a.layers.test(b.layers)&&(a instanceof THREE.Mesh||a instanceof THREE.Line||a instanceof
THREE.Points)&&a.castShadow&&(!1===a.frustumCulled||!0===h.intersectsObject(a))&&!0===a.material.visible&&(a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,a.matrixWorld),q.push(a));a=a.children;for(var d=0,f=a.length;d<f;d++)e(a[d],b,c)}}var f=a.context,g=a.state,h=new THREE.Frustum,k=new THREE.Matrix4,l=b.shadows,n=new THREE.Vector2,p=new THREE.Vector3,m=new THREE.Vector3,q=[],r=Array(4),s=Array(4),u={},x=[new THREE.Vector3(1,0,0),new THREE.Vector3(-1,0,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,
0,-1),new THREE.Vector3(0,1,0),new THREE.Vector3(0,-1,0)],v=[new THREE.Vector3(0,1,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,1,0),new THREE.Vector3(0,0,1),new THREE.Vector3(0,0,-1)],C=[new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4,new THREE.Vector4];b=new THREE.MeshDepthMaterial;b.depthPacking=THREE.RGBADepthPacking;b.clipping=!0;for(var w=THREE.ShaderLib.distanceRGBA,D=THREE.UniformsUtils.clone(w.uniforms),A=0;4!==A;++A){var y=
0!==(A&1),B=0!==(A&2),G=b.clone();G.morphTargets=y;G.skinning=B;r[A]=G;y=new THREE.ShaderMaterial({defines:{USE_SHADOWMAP:""},uniforms:D,vertexShader:w.vertexShader,fragmentShader:w.fragmentShader,morphTargets:y,skinning:B,clipping:!0});s[A]=y}var z=this;this.enabled=!1;this.autoUpdate=!0;this.needsUpdate=!1;this.type=THREE.PCFShadowMap;this.renderSingleSided=this.renderReverseSided=!0;this.render=function(b,r){if(!1!==z.enabled&&(!1!==z.autoUpdate||!1!==z.needsUpdate)&&0!==l.length){g.clearColor(1,
1,1,1);g.disable(f.BLEND);g.setDepthTest(!0);g.setScissorTest(!1);for(var s,u,w=0,y=l.length;w<y;w++){var A=l[w],L=A.shadow;if(void 0===L)console.warn("THREE.WebGLShadowMap:",A,"has no shadow.");else{var P=L.camera;n.copy(L.mapSize);if(A instanceof THREE.PointLight){s=6;u=!0;var B=n.x,D=n.y;C[0].set(2*B,D,B,D);C[1].set(0,D,B,D);C[2].set(3*B,D,B,D);C[3].set(B,D,B,D);C[4].set(3*B,0,B,D);C[5].set(B,0,B,D);n.x*=4;n.y*=2}else s=1,u=!1;null===L.map&&(L.map=new THREE.WebGLRenderTarget(n.x,n.y,{minFilter:THREE.NearestFilter,
magFilter:THREE.NearestFilter,format:THREE.RGBAFormat}),P.updateProjectionMatrix());L instanceof THREE.SpotLightShadow&&L.update(A);B=L.map;L=L.matrix;m.setFromMatrixPosition(A.matrixWorld);P.position.copy(m);a.setRenderTarget(B);a.clear();for(B=0;B<s;B++){u?(p.copy(P.position),p.add(x[B]),P.up.copy(v[B]),P.lookAt(p),g.viewport(C[B])):(p.setFromMatrixPosition(A.target.matrixWorld),P.lookAt(p));P.updateMatrixWorld();P.matrixWorldInverse.getInverse(P.matrixWorld);L.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,
0,0,0,1);L.multiply(P.projectionMatrix);L.multiply(P.matrixWorldInverse);k.multiplyMatrices(P.projectionMatrix,P.matrixWorldInverse);h.setFromMatrix(k);q.length=0;e(b,r,P);for(var D=0,F=q.length;D<F;D++){var G=q[D],U=c.update(G),Y=G.material;if(Y instanceof THREE.MultiMaterial)for(var W=U.groups,Y=Y.materials,fa=0,la=W.length;fa<la;fa++){var ga=W[fa],Z=Y[ga.materialIndex];!0===Z.visible&&(Z=d(G,Z,u,m),a.renderBufferDirect(P,null,U,Z,G,ga))}else Z=d(G,Y,u,m),a.renderBufferDirect(P,null,U,Z,G,null)}}}}s=
a.getClearColor();u=a.getClearAlpha();a.setClearColor(s,u);z.needsUpdate=!1}}};
THREE.WebGLState=function(a,b,c){function d(b,c,d){var e=new Uint8Array(3),f=a.createTexture();a.bindTexture(b,f);a.texParameteri(b,a.TEXTURE_MIN_FILTER,a.NEAREST);a.texParameteri(b,a.TEXTURE_MAG_FILTER,a.NEAREST);for(b=0;b<d;b++)a.texImage2D(c+b,0,a.RGB,1,1,0,a.RGB,a.UNSIGNED_BYTE,e);return f}var e=this;this.buffers={color:new THREE.WebGLColorBuffer(a,this),depth:new THREE.WebGLDepthBuffer(a,this),stencil:new THREE.WebGLStencilBuffer(a,this)};var f=a.getParameter(a.MAX_VERTEX_ATTRIBS),g=new Uint8Array(f),
h=new Uint8Array(f),k=new Uint8Array(f),l={},n=null,p=null,m=null,q=null,r=null,s=null,u=null,x=null,v=!1,C=null,w=null,D=null,A=null,y=null,B=null,G=a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),z=null,H={},M=new THREE.Vector4,O=new THREE.Vector4,N={};N[a.TEXTURE_2D]=d(a.TEXTURE_2D,a.TEXTURE_2D,1);N[a.TEXTURE_CUBE_MAP]=d(a.TEXTURE_CUBE_MAP,a.TEXTURE_CUBE_MAP_POSITIVE_X,6);this.init=function(){this.clearColor(0,0,0,1);this.clearDepth(1);this.clearStencil(0);this.enable(a.DEPTH_TEST);this.setDepthFunc(THREE.LessEqualDepth);
this.setFlipSided(!1);this.setCullFace(THREE.CullFaceBack);this.enable(a.CULL_FACE);this.enable(a.BLEND);this.setBlending(THREE.NormalBlending)};this.initAttributes=function(){for(var a=0,b=g.length;a<b;a++)g[a]=0};this.enableAttribute=function(c){g[c]=1;0===h[c]&&(a.enableVertexAttribArray(c),h[c]=1);0!==k[c]&&(b.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(c,0),k[c]=0)};this.enableAttributeAndDivisor=function(b,c,d){g[b]=1;0===h[b]&&(a.enableVertexAttribArray(b),h[b]=1);k[b]!==c&&(d.vertexAttribDivisorANGLE(b,
c),k[b]=c)};this.disableUnusedAttributes=function(){for(var b=0,c=h.length;b!==c;++b)h[b]!==g[b]&&(a.disableVertexAttribArray(b),h[b]=0)};this.enable=function(b){!0!==l[b]&&(a.enable(b),l[b]=!0)};this.disable=function(b){!1!==l[b]&&(a.disable(b),l[b]=!1)};this.getCompressedTextureFormats=function(){if(null===n&&(n=[],b.get("WEBGL_compressed_texture_pvrtc")||b.get("WEBGL_compressed_texture_s3tc")||b.get("WEBGL_compressed_texture_etc1")))for(var c=a.getParameter(a.COMPRESSED_TEXTURE_FORMATS),d=0;d<
c.length;d++)n.push(c[d]);return n};this.setBlending=function(b,d,e,f,g,h,k,l){if(b!==THREE.NoBlending){this.enable(a.BLEND);if(b!==p||l!==v)b===THREE.AdditiveBlending?l?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,a.ONE,a.ONE,a.ONE)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.SRC_ALPHA,a.ONE)):b===THREE.SubtractiveBlending?l?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.ZERO,a.ONE_MINUS_SRC_COLOR,a.ONE_MINUS_SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),
a.blendFunc(a.ZERO,a.ONE_MINUS_SRC_COLOR)):b===THREE.MultiplyBlending?l?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ZERO,a.SRC_COLOR,a.ZERO,a.SRC_ALPHA)):(a.blendEquation(a.FUNC_ADD),a.blendFunc(a.ZERO,a.SRC_COLOR)):l?(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.ONE,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA)):(a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(a.SRC_ALPHA,a.ONE_MINUS_SRC_ALPHA,a.ONE,a.ONE_MINUS_SRC_ALPHA)),
p=b,v=l;if(b===THREE.CustomBlending){g=g||d;h=h||e;k=k||f;if(d!==m||g!==s)a.blendEquationSeparate(c(d),c(g)),m=d,s=g;if(e!==q||f!==r||h!==u||k!==x)a.blendFuncSeparate(c(e),c(f),c(h),c(k)),q=e,r=f,u=h,x=k}else x=u=s=r=q=m=null}else this.disable(a.BLEND),p=b};this.setColorWrite=function(a){this.buffers.color.setMask(a)};this.setDepthTest=function(a){this.buffers.depth.setTest(a)};this.setDepthWrite=function(a){this.buffers.depth.setMask(a)};this.setDepthFunc=function(a){this.buffers.depth.setFunc(a)};
this.setStencilTest=function(a){this.buffers.stencil.setTest(a)};this.setStencilWrite=function(a){this.buffers.stencil.setMask(a)};this.setStencilFunc=function(a,b,c){this.buffers.stencil.setFunc(a,b,c)};this.setStencilOp=function(a,b,c){this.buffers.stencil.setOp(a,b,c)};this.setFlipSided=function(b){C!==b&&(b?a.frontFace(a.CW):a.frontFace(a.CCW),C=b)};this.setCullFace=function(b){b!==THREE.CullFaceNone?(this.enable(a.CULL_FACE),b!==w&&(b===THREE.CullFaceBack?a.cullFace(a.BACK):b===THREE.CullFaceFront?
a.cullFace(a.FRONT):a.cullFace(a.FRONT_AND_BACK))):this.disable(a.CULL_FACE);w=b};this.setLineWidth=function(b){b!==D&&(a.lineWidth(b),D=b)};this.setPolygonOffset=function(b,c,d){if(b){if(this.enable(a.POLYGON_OFFSET_FILL),A!==c||y!==d)a.polygonOffset(c,d),A=c,y=d}else this.disable(a.POLYGON_OFFSET_FILL)};this.getScissorTest=function(){return B};this.setScissorTest=function(b){(B=b)?this.enable(a.SCISSOR_TEST):this.disable(a.SCISSOR_TEST)};this.activeTexture=function(b){void 0===b&&(b=a.TEXTURE0+
G-1);z!==b&&(a.activeTexture(b),z=b)};this.bindTexture=function(b,c){null===z&&e.activeTexture();var d=H[z];void 0===d&&(d={type:void 0,texture:void 0},H[z]=d);if(d.type!==b||d.texture!==c)a.bindTexture(b,c||N[b]),d.type=b,d.texture=c};this.compressedTexImage2D=function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(b){console.error(b)}};this.texImage2D=function(){try{a.texImage2D.apply(a,arguments)}catch(b){console.error(b)}};this.clearColor=function(a,b,c,d){this.buffers.color.setClear(a,
b,c,d)};this.clearDepth=function(a){this.buffers.depth.setClear(a)};this.clearStencil=function(a){this.buffers.stencil.setClear(a)};this.scissor=function(b){!1===M.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),M.copy(b))};this.viewport=function(b){!1===O.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),O.copy(b))};this.reset=function(){for(var b=0;b<h.length;b++)1===h[b]&&(a.disableVertexAttribArray(b),h[b]=0);l={};z=n=null;H={};w=C=p=null;this.buffers.color.reset();this.buffers.depth.reset();this.buffers.stencil.reset()}};
THREE.WebGLColorBuffer=function(a,b){var c=!1,d=new THREE.Vector4,e=null,f=new THREE.Vector4;this.setMask=function(b){e===b||c||(a.colorMask(b,b,b,b),e=b)};this.setLocked=function(a){c=a};this.setClear=function(b,c,e,l){d.set(b,c,e,l);!1===f.equals(d)&&(a.clearColor(b,c,e,l),f.copy(d))};this.reset=function(){c=!1;e=null;f=new THREE.Vector4}};
THREE.WebGLDepthBuffer=function(a,b){var c=!1,d=null,e=null,f=null;this.setTest=function(c){c?b.enable(a.DEPTH_TEST):b.disable(a.DEPTH_TEST)};this.setMask=function(b){d===b||c||(a.depthMask(b),d=b)};this.setFunc=function(b){if(e!==b){if(b)switch(b){case THREE.NeverDepth:a.depthFunc(a.NEVER);break;case THREE.AlwaysDepth:a.depthFunc(a.ALWAYS);break;case THREE.LessDepth:a.depthFunc(a.LESS);break;case THREE.LessEqualDepth:a.depthFunc(a.LEQUAL);break;case THREE.EqualDepth:a.depthFunc(a.EQUAL);break;case THREE.GreaterEqualDepth:a.depthFunc(a.GEQUAL);
break;case THREE.GreaterDepth:a.depthFunc(a.GREATER);break;case THREE.NotEqualDepth:a.depthFunc(a.NOTEQUAL);break;default:a.depthFunc(a.LEQUAL)}else a.depthFunc(a.LEQUAL);e=b}};this.setLocked=function(a){c=a};this.setClear=function(b){f!==b&&(a.clearDepth(b),f=b)};this.reset=function(){c=!1;f=e=d=null}};
THREE.WebGLStencilBuffer=function(a,b){var c=!1,d=null,e=null,f=null,g=null,h=null,k=null,l=null,n=null;this.setTest=function(c){c?b.enable(a.STENCIL_TEST):b.disable(a.STENCIL_TEST)};this.setMask=function(b){d===b||c||(a.stencilMask(b),d=b)};this.setFunc=function(b,c,d){if(e!==b||f!==c||g!==d)a.stencilFunc(b,c,d),e=b,f=c,g=d};this.setOp=function(b,c,d){if(h!==b||k!==c||l!==d)a.stencilOp(b,c,d),h=b,k=c,l=d};this.setLocked=function(a){c=a};this.setClear=function(b){n!==b&&(a.clearStencil(b),n=b)};this.reset=
function(){c=!1;n=l=k=h=g=f=e=d=null}};
THREE.WebGLUniforms=function(){var a=[],b=[],c=function(b,c,d){var e=b[0];if(0>=e||0<e)return b;var f=c*d,g=a[f];void 0===g&&(g=new Float32Array(f),a[f]=g);if(0!==c)for(e.toArray(g,0),e=1,f=0;e!==c;++e)f+=d,b[e].toArray(g,f);return g},d=function(a,c){var d=b[c];void 0===d&&(d=new Int32Array(c),b[c]=d);for(var e=0;e!==c;++e)d[e]=a.allocTextureUnit();return d},e=function(a,b){a.uniform1f(this.addr,b)},f=function(a,b){a.uniform1i(this.addr,b)},g=function(a,b){void 0===b.x?a.uniform2fv(this.addr,b):a.uniform2f(this.addr,
b.x,b.y)},h=function(a,b){void 0!==b.x?a.uniform3f(this.addr,b.x,b.y,b.z):void 0!==b.r?a.uniform3f(this.addr,b.r,b.g,b.b):a.uniform3fv(this.addr,b)},k=function(a,b){void 0===b.x?a.uniform4fv(this.addr,b):a.uniform4f(this.addr,b.x,b.y,b.z,b.w)},l=function(a,b){a.uniformMatrix2fv(this.addr,!1,b.elements||b)},n=function(a,b){a.uniformMatrix3fv(this.addr,!1,b.elements||b)},p=function(a,b){a.uniformMatrix4fv(this.addr,!1,b.elements||b)},m=function(a,b,c){var d=c.allocTextureUnit();a.uniform1i(this.addr,
d);b&&c.setTexture2D(b,d)},q=function(a,b,c){var d=c.allocTextureUnit();a.uniform1i(this.addr,d);b&&c.setTextureCube(b,d)},r=function(a,b){a.uniform2iv(this.addr,b)},s=function(a,b){a.uniform3iv(this.addr,b)},u=function(a,b){a.uniform4iv(this.addr,b)},x=function(a){switch(a){case 5126:return e;case 35664:return g;case 35665:return h;case 35666:return k;case 35674:return l;case 35675:return n;case 35676:return p;case 35678:return m;case 35680:return q;case 5124:case 35670:return f;case 35667:case 35671:return r;
case 35668:case 35672:return s;case 35669:case 35673:return u}},v=function(a,b){a.uniform1fv(this.addr,b)},C=function(a,b){a.uniform1iv(this.addr,b)},w=function(a,b){a.uniform2fv(this.addr,c(b,this.size,2))},D=function(a,b){a.uniform3fv(this.addr,c(b,this.size,3))},A=function(a,b){a.uniform4fv(this.addr,c(b,this.size,4))},y=function(a,b){a.uniformMatrix2fv(this.addr,!1,c(b,this.size,4))},B=function(a,b){a.uniformMatrix3fv(this.addr,!1,c(b,this.size,9))},G=function(a,b){a.uniformMatrix4fv(this.addr,
!1,c(b,this.size,16))},z=function(a,b,c){var e=b.length,f=d(c,e);a.uniform1iv(this.addr,f);for(a=0;a!==e;++a){var g=b[a];g&&c.setTexture2D(g,f[a])}},H=function(a,b,c){var e=b.length,f=d(c,e);a.uniform1iv(this.addr,f);for(a=0;a!==e;++a){var g=b[a];g&&c.setTextureCube(g,f[a])}},M=function(a){switch(a){case 5126:return v;case 35664:return w;case 35665:return D;case 35666:return A;case 35674:return y;case 35675:return B;case 35676:return G;case 35678:return z;case 35680:return H;case 5124:case 35670:return C;
case 35667:case 35671:return r;case 35668:case 35672:return s;case 35669:case 35673:return u}},O=function(a,b,c){this.id=a;this.addr=c;this.setValue=x(b.type)},N=function(a,b,c){this.id=a;this.addr=c;this.size=b.size;this.setValue=M(b.type)},E=function(a){this.id=a;this.seq=[];this.map={}};E.prototype.setValue=function(a,b){for(var c=this.seq,d=0,e=c.length;d!==e;++d){var f=c[d];f.setValue(a,b[f.id])}};var K=/([\w\d_]+)(\])?(\[|\.)?/g,I=function(a,b,c){this.seq=[];this.map={};this.renderer=c;c=a.getProgramParameter(b,
a.ACTIVE_UNIFORMS);for(var d=0;d!==c;++d){var e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name),g=this,h=e.name,k=h.length;for(K.lastIndex=0;;){var m=K.exec(h),l=K.lastIndex,n=m[1],q=m[3];"]"===m[2]&&(n|=0);if(void 0===q||"["===q&&l+2===k){h=g;e=void 0===q?new O(n,e,f):new N(n,e,f);h.seq.push(e);h.map[e.id]=e;break}else q=g.map[n],void 0===q&&(q=new E(n),n=g,g=q,n.seq.push(g),n.map[g.id]=g),g=q}}};I.prototype.setValue=function(a,b,c){b=this.map[b];void 0!==b&&b.setValue(a,c,this.renderer)};
I.prototype.set=function(a,b,c){var d=this.map[c];void 0!==d&&d.setValue(a,b[c],this.renderer)};I.prototype.setOptional=function(a,b,c){b=b[c];void 0!==b&&this.setValue(a,c,b)};I.upload=function(a,b,c,d){for(var e=0,f=b.length;e!==f;++e){var g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}};I.seqWithValue=function(a,b){for(var c=[],d=0,e=a.length;d!==e;++d){var f=a[d];f.id in b&&c.push(f)}return c};I.splitDynamic=function(a,b){for(var c=null,d=a.length,e=0,f=0;f!==d;++f){var g=a[f],h=
b[g.id];h&&!0===h.dynamic?(null===c&&(c=[]),c.push(g)):(e<f&&(a[e]=g),++e)}e<d&&(a.length=e);return c};I.evalDynamic=function(a,b,c,d){for(var e=0,f=a.length;e!==f;++e){var g=b[a[e].id],h=g.onUpdateCallback;void 0!==h&&h.call(g,c,d)}};return I}();
THREE.LensFlarePlugin=function(a,b){var c,d,e,f,g,h,k,l,n,p,m=a.context,q=a.state,r,s,u,x,v,C;this.render=function(w,D,A){if(0!==b.length){w=new THREE.Vector3;var y=A.w/A.z,B=.5*A.z,G=.5*A.w,z=16/A.w,H=new THREE.Vector2(z*y,z),M=new THREE.Vector3(1,1,0),O=new THREE.Vector2(1,1),N=new THREE.Box2;N.min.set(0,0);N.max.set(A.z-16,A.w-16);if(void 0===x){var z=new Float32Array([-1,-1,0,0,1,-1,1,0,1,1,1,1,-1,1,0,1]),E=new Uint16Array([0,1,2,0,2,3]);r=m.createBuffer();s=m.createBuffer();m.bindBuffer(m.ARRAY_BUFFER,
r);m.bufferData(m.ARRAY_BUFFER,z,m.STATIC_DRAW);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,s);m.bufferData(m.ELEMENT_ARRAY_BUFFER,E,m.STATIC_DRAW);v=m.createTexture();C=m.createTexture();q.bindTexture(m.TEXTURE_2D,v);m.texImage2D(m.TEXTURE_2D,0,m.RGB,16,16,0,m.RGB,m.UNSIGNED_BYTE,null);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,
m.NEAREST);q.bindTexture(m.TEXTURE_2D,C);m.texImage2D(m.TEXTURE_2D,0,m.RGBA,16,16,0,m.RGBA,m.UNSIGNED_BYTE,null);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_S,m.CLAMP_TO_EDGE);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_WRAP_T,m.CLAMP_TO_EDGE);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MAG_FILTER,m.NEAREST);m.texParameteri(m.TEXTURE_2D,m.TEXTURE_MIN_FILTER,m.NEAREST);var z=u={vertexShader:"uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
fragmentShader:"uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"},E=m.createProgram(),K=m.createShader(m.FRAGMENT_SHADER),
I=m.createShader(m.VERTEX_SHADER),L="precision "+a.getPrecision()+" float;\n";m.shaderSource(K,L+z.fragmentShader);m.shaderSource(I,L+z.vertexShader);m.compileShader(K);m.compileShader(I);m.attachShader(E,K);m.attachShader(E,I);m.linkProgram(E);x=E;n=m.getAttribLocation(x,"position");p=m.getAttribLocation(x,"uv");c=m.getUniformLocation(x,"renderType");d=m.getUniformLocation(x,"map");e=m.getUniformLocation(x,"occlusionMap");f=m.getUniformLocation(x,"opacity");g=m.getUniformLocation(x,"color");h=m.getUniformLocation(x,
"scale");k=m.getUniformLocation(x,"rotation");l=m.getUniformLocation(x,"screenPosition")}m.useProgram(x);q.initAttributes();q.enableAttribute(n);q.enableAttribute(p);q.disableUnusedAttributes();m.uniform1i(e,0);m.uniform1i(d,1);m.bindBuffer(m.ARRAY_BUFFER,r);m.vertexAttribPointer(n,2,m.FLOAT,!1,16,0);m.vertexAttribPointer(p,2,m.FLOAT,!1,16,8);m.bindBuffer(m.ELEMENT_ARRAY_BUFFER,s);q.disable(m.CULL_FACE);q.setDepthWrite(!1);E=0;for(K=b.length;E<K;E++)if(z=16/A.w,H.set(z*y,z),I=b[E],w.set(I.matrixWorld.elements[12],
I.matrixWorld.elements[13],I.matrixWorld.elements[14]),w.applyMatrix4(D.matrixWorldInverse),w.applyProjection(D.projectionMatrix),M.copy(w),O.x=A.x+M.x*B+B-8,O.y=A.y+M.y*G+G-8,!0===N.containsPoint(O)){q.activeTexture(m.TEXTURE0);q.bindTexture(m.TEXTURE_2D,null);q.activeTexture(m.TEXTURE1);q.bindTexture(m.TEXTURE_2D,v);m.copyTexImage2D(m.TEXTURE_2D,0,m.RGB,O.x,O.y,16,16,0);m.uniform1i(c,0);m.uniform2f(h,H.x,H.y);m.uniform3f(l,M.x,M.y,M.z);q.disable(m.BLEND);q.enable(m.DEPTH_TEST);m.drawElements(m.TRIANGLES,
6,m.UNSIGNED_SHORT,0);q.activeTexture(m.TEXTURE0);q.bindTexture(m.TEXTURE_2D,C);m.copyTexImage2D(m.TEXTURE_2D,0,m.RGBA,O.x,O.y,16,16,0);m.uniform1i(c,1);q.disable(m.DEPTH_TEST);q.activeTexture(m.TEXTURE1);q.bindTexture(m.TEXTURE_2D,v);m.drawElements(m.TRIANGLES,6,m.UNSIGNED_SHORT,0);I.positionScreen.copy(M);I.customUpdateCallback?I.customUpdateCallback(I):I.updateLensFlares();m.uniform1i(c,2);q.enable(m.BLEND);for(var L=0,P=I.lensFlares.length;L<P;L++){var Q=I.lensFlares[L];.001<Q.opacity&&.001<Q.scale&&
(M.x=Q.x,M.y=Q.y,M.z=Q.z,z=Q.size*Q.scale/A.w,H.x=z*y,H.y=z,m.uniform3f(l,M.x,M.y,M.z),m.uniform2f(h,H.x,H.y),m.uniform1f(k,Q.rotation),m.uniform1f(f,Q.opacity),m.uniform3f(g,Q.color.r,Q.color.g,Q.color.b),q.setBlending(Q.blending,Q.blendEquation,Q.blendSrc,Q.blendDst),a.setTexture2D(Q.texture,1),m.drawElements(m.TRIANGLES,6,m.UNSIGNED_SHORT,0))}}q.enable(m.CULL_FACE);q.enable(m.DEPTH_TEST);q.setDepthWrite(!0);a.resetGLState()}}};
THREE.SpritePlugin=function(a,b){var c,d,e,f,g,h,k,l,n,p,m,q,r,s,u,x,v;function C(a,b){return a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:b.id-a.id}var w=a.context,D=a.state,A,y,B,G,z=new THREE.Vector3,H=new THREE.Quaternion,M=new THREE.Vector3;this.render=function(O,N){if(0!==b.length){if(void 0===B){var E=new Float32Array([-.5,-.5,0,0,.5,-.5,1,0,.5,.5,1,1,-.5,.5,0,1]),K=new Uint16Array([0,1,2,0,2,3]);A=w.createBuffer();y=w.createBuffer();w.bindBuffer(w.ARRAY_BUFFER,
A);w.bufferData(w.ARRAY_BUFFER,E,w.STATIC_DRAW);w.bindBuffer(w.ELEMENT_ARRAY_BUFFER,y);w.bufferData(w.ELEMENT_ARRAY_BUFFER,K,w.STATIC_DRAW);var E=w.createProgram(),K=w.createShader(w.VERTEX_SHADER),I=w.createShader(w.FRAGMENT_SHADER);w.shaderSource(K,["precision "+a.getPrecision()+" float;","uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
w.shaderSource(I,["precision "+a.getPrecision()+" float;","uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
w.compileShader(K);w.compileShader(I);w.attachShader(E,K);w.attachShader(E,I);w.linkProgram(E);B=E;x=w.getAttribLocation(B,"position");v=w.getAttribLocation(B,"uv");c=w.getUniformLocation(B,"uvOffset");d=w.getUniformLocation(B,"uvScale");e=w.getUniformLocation(B,"rotation");f=w.getUniformLocation(B,"scale");g=w.getUniformLocation(B,"color");h=w.getUniformLocation(B,"map");k=w.getUniformLocation(B,"opacity");l=w.getUniformLocation(B,"modelViewMatrix");n=w.getUniformLocation(B,"projectionMatrix");p=
w.getUniformLocation(B,"fogType");m=w.getUniformLocation(B,"fogDensity");q=w.getUniformLocation(B,"fogNear");r=w.getUniformLocation(B,"fogFar");s=w.getUniformLocation(B,"fogColor");u=w.getUniformLocation(B,"alphaTest");E=document.createElement("canvas");E.width=8;E.height=8;K=E.getContext("2d");K.fillStyle="white";K.fillRect(0,0,8,8);G=new THREE.Texture(E);G.needsUpdate=!0}w.useProgram(B);D.initAttributes();D.enableAttribute(x);D.enableAttribute(v);D.disableUnusedAttributes();D.disable(w.CULL_FACE);
D.enable(w.BLEND);w.bindBuffer(w.ARRAY_BUFFER,A);w.vertexAttribPointer(x,2,w.FLOAT,!1,16,0);w.vertexAttribPointer(v,2,w.FLOAT,!1,16,8);w.bindBuffer(w.ELEMENT_ARRAY_BUFFER,y);w.uniformMatrix4fv(n,!1,N.projectionMatrix.elements);D.activeTexture(w.TEXTURE0);w.uniform1i(h,0);K=E=0;(I=O.fog)?(w.uniform3f(s,I.color.r,I.color.g,I.color.b),I instanceof THREE.Fog?(w.uniform1f(q,I.near),w.uniform1f(r,I.far),w.uniform1i(p,1),K=E=1):I instanceof THREE.FogExp2&&(w.uniform1f(m,I.density),w.uniform1i(p,2),K=E=2)):
(w.uniform1i(p,0),K=E=0);for(var I=0,L=b.length;I<L;I++){var P=b[I];P.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,P.matrixWorld);P.z=-P.modelViewMatrix.elements[14]}b.sort(C);for(var Q=[],I=0,L=b.length;I<L;I++){var P=b[I],R=P.material;w.uniform1f(u,R.alphaTest);w.uniformMatrix4fv(l,!1,P.modelViewMatrix.elements);P.matrixWorld.decompose(z,H,M);Q[0]=M.x;Q[1]=M.y;P=0;O.fog&&R.fog&&(P=K);E!==P&&(w.uniform1i(p,P),E=P);null!==R.map?(w.uniform2f(c,R.map.offset.x,R.map.offset.y),w.uniform2f(d,
R.map.repeat.x,R.map.repeat.y)):(w.uniform2f(c,0,0),w.uniform2f(d,1,1));w.uniform1f(k,R.opacity);w.uniform3f(g,R.color.r,R.color.g,R.color.b);w.uniform1f(e,R.rotation);w.uniform2fv(f,Q);D.setBlending(R.blending,R.blendEquation,R.blendSrc,R.blendDst);D.setDepthTest(R.depthTest);D.setDepthWrite(R.depthWrite);R.map?a.setTexture2D(R.map,0):a.setTexture2D(G,0);w.drawElements(w.TRIANGLES,6,w.UNSIGNED_SHORT,0)}D.enable(w.CULL_FACE);a.resetGLState()}}};
Object.assign(THREE,{Face4:function(a,b,c,d,e,f,g){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new THREE.Face3(a,b,c,e,f,g)},LineStrip:0,LinePieces:1,MeshFaceMaterial:THREE.MultiMaterial,PointCloud:function(a,b){console.warn("THREE.PointCloud has been renamed to THREE.Points.");return new THREE.Points(a,b)},Particle:THREE.Sprite,ParticleSystem:function(a,b){console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");return new THREE.Points(a,
b)},PointCloudMaterial:function(a){console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");return new THREE.PointsMaterial(a)},ParticleBasicMaterial:function(a){console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");return new THREE.PointsMaterial(a)},ParticleSystemMaterial:function(a){console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");return new THREE.PointsMaterial(a)},Vertex:function(a,b,c){console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
return new THREE.Vector3(a,b,c)}});Object.assign(THREE.Box2.prototype,{empty:function(){console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)}});
Object.assign(THREE.Box3.prototype,{empty:function(){console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");return this.isEmpty()},isIntersectionBox:function(a){console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},isIntersectionSphere:function(a){console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(a)}});
Object.assign(THREE.Matrix3.prototype,{multiplyVector3:function(a){console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},multiplyVector3Array:function(a){console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");return this.applyToVector3Array(a)}});
Object.assign(THREE.Matrix4.prototype,{extractPosition:function(a){console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");return this.copyPosition(a)},setRotationFromQuaternion:function(a){console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");return this.makeRotationFromQuaternion(a)},multiplyVector3:function(a){console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
return a.applyProjection(this)},multiplyVector4:function(a){console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector3Array:function(a){console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");return this.applyToVector3Array(a)},rotateAxis:function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
a.transformDirection(this)},crossVector:function(a){console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},translate:function(a){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(a){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(a){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(a){console.error("THREE.Matrix4: .rotateZ() has been removed.")},
rotateByAxis:function(a,b){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")}});Object.assign(THREE.Plane.prototype,{isIntersectionLine:function(a){console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");return this.intersectsLine(a)}});Object.assign(THREE.Quaternion.prototype,{multiplyVector3:function(a){console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");return a.applyQuaternion(this)}});
Object.assign(THREE.Ray.prototype,{isIntersectionBox:function(a){console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");return this.intersectsBox(a)},isIntersectionPlane:function(a){console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");return this.intersectsPlane(a)},isIntersectionSphere:function(a){console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");return this.intersectsSphere(a)}});
Object.assign(THREE.Vector3.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(a){console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");return this.setFromMatrixPosition(a)},
getScaleFromMatrix:function(a){console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,b){console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");return this.setFromMatrixColumn(b,a)}});
Object.assign(THREE.Object3D.prototype,{getChildByName:function(a){console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(a)},renderDepth:function(a){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(a,b){console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");return this.translateOnAxis(b,a)}});
Object.defineProperties(THREE.Object3D.prototype,{eulerOrder:{get:function(){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");return this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(a){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});
Object.defineProperties(THREE.LOD.prototype,{objects:{get:function(){console.warn("THREE.LOD: .objects has been renamed to .levels.");return this.levels}}});THREE.PerspectiveCamera.prototype.setLens=function(a,b){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");void 0!==b&&(this.filmGauge=b);this.setFocalLength(a)};
Object.defineProperties(THREE.Light.prototype,{onlyShadow:{set:function(a){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
this.shadow.camera.far=a}},shadowCameraVisible:{set:function(a){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias.");this.shadow.bias=a}},shadowDarkness:{set:function(a){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");this.shadow.mapSize.height=a}}});Object.defineProperties(THREE.BufferAttribute.prototype,{length:{get:function(){console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");return this.array.length}}});
Object.assign(THREE.BufferGeometry.prototype,{addIndex:function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");this.setIndex(a)},addDrawCall:function(a,b,c){void 0!==c&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");this.addGroup(a,b)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");this.clearGroups()},
computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")}});Object.defineProperties(THREE.BufferGeometry.prototype,{drawcalls:{get:function(){console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");return this.groups}},offsets:{get:function(){console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");return this.groups}}});
Object.defineProperties(THREE.Material.prototype,{wrapAround:{get:function(){console.warn("THREE."+this.type+": .wrapAround has been removed.")},set:function(a){console.warn("THREE."+this.type+": .wrapAround has been removed.")}},wrapRGB:{get:function(){console.warn("THREE."+this.type+": .wrapRGB has been removed.");return new THREE.Color}}});
Object.defineProperties(THREE.MeshPhongMaterial.prototype,{metal:{get:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");return!1},set:function(a){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});
Object.defineProperties(THREE.ShaderMaterial.prototype,{derivatives:{get:function(){console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");return this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");this.extensions.derivatives=a}}});
THREE.EventDispatcher.prototype=Object.assign(Object.create({constructor:THREE.EventDispatcher,apply:function(a){console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in.");Object.assign(a,this)}}),THREE.EventDispatcher.prototype);
Object.assign(THREE.WebGLRenderer.prototype,{supportsFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");return this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");return this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
return this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");return this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");return this.extensions.get("WEBGL_compressed_texture_pvrtc")},
supportsBlendMinMax:function(){console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");return this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return this.capabilities.vertexTextures},supportsInstancedArrays:function(){console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");return this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
this.setScissorTest(a)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")}});
Object.defineProperties(THREE.WebGLRenderer.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");this.shadowMap.type=a}},shadowMapCullFace:{get:function(){return this.shadowMap.cullFace},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
this.shadowMap.cullFace=a}}});Object.defineProperties(THREE.WebGLShadowMap.prototype,{cullFace:{get:function(){return this.renderReverseSided?THREE.CullFaceFront:THREE.CullFaceBack},set:function(a){a=a!==THREE.CullFaceBack;console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to "+a+".");this.renderReverseSided=a}}});
Object.defineProperties(THREE.WebGLRenderTarget.prototype,{wrapS:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");return this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");this.texture.wrapS=a}},wrapT:{get:function(){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");return this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");this.texture.wrapT=
a}},magFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");return this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");this.texture.magFilter=a}},minFilter:{get:function(){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");return this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");this.texture.minFilter=
a}},anisotropy:{get:function(){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");return this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");this.texture.anisotropy=a}},offset:{get:function(){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");return this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");this.texture.offset=
a}},repeat:{get:function(){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");return this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");this.texture.repeat=a}},format:{get:function(){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");return this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");this.texture.format=a}},type:{get:function(){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
return this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");this.texture.type=a}},generateMipmaps:{get:function(){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");return this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");this.texture.generateMipmaps=a}}});
Object.assign(THREE.Audio.prototype,{load:function(a){console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");var b=this;(new THREE.AudioLoader).load(a,function(a){b.setBuffer(a)});return this}});Object.assign(THREE.AudioAnalyser.prototype,{getData:function(a){console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");return this.getFrequencyData()}});
THREE.GeometryUtils={merge:function(a,b,c){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");var d;b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,b=b.geometry);a.merge(b,d,c)},center:function(a){console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");return a.center()}};
THREE.ImageUtils={crossOrigin:void 0,loadTexture:function(a,b,c,d){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");var e=new THREE.TextureLoader;e.setCrossOrigin(this.crossOrigin);a=e.load(a,c,void 0,d);b&&(a.mapping=b);return a},loadTextureCube:function(a,b,c,d){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");var e=new THREE.CubeTextureLoader;e.setCrossOrigin(this.crossOrigin);a=e.load(a,
c,void 0,d);b&&(a.mapping=b);return a},loadCompressedTexture:function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},loadCompressedTextureCube:function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")}};
THREE.Projector=function(){console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");this.projectVector=function(a,b){console.warn("THREE.Projector: .projectVector() is now vector.project().");a.project(b)};this.unprojectVector=function(a,b){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");a.unproject(b)};this.pickingRay=function(a,b){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")}};
THREE.CanvasRenderer=function(){console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");this.domElement=document.createElement("canvas");this.clear=function(){};this.render=function(){};this.setClearColor=function(){};this.setSize=function(){}};
THREE.CurveUtils={tangentQuadraticBezier:function(a,b,c,d){return 2*(1-a)*(c-b)+2*a*(d-c)},tangentCubicBezier:function(a,b,c,d,e){return-3*b*(1-a)*(1-a)+3*c*(1-a)*(1-a)-6*a*c*(1-a)+6*a*d*(1-a)-3*a*a*d+3*a*a*e},tangentSpline:function(a,b,c,d,e){return 6*a*a-6*a+(3*a*a-4*a+1)+(-6*a*a+6*a)+(3*a*a-2*a)},interpolate:function(a,b,c,d,e){a=.5*(c-a);d=.5*(d-b);var f=e*e;return(2*b-2*c+a+d)*e*f+(-3*b+3*c-2*a-d)*f+a*e+b}};
THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Group,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};
THREE.ShapeUtils={area:function(a){for(var b=a.length,c=0,d=b-1,e=0;e<b;d=e++)c+=a[d].x*a[e].y-a[e].x*a[d].y;return.5*c},triangulate:function(){return function(a,b){var c=a.length;if(3>c)return null;var d=[],e=[],f=[],g,h,k;if(0<THREE.ShapeUtils.area(a))for(h=0;h<c;h++)e[h]=h;else for(h=0;h<c;h++)e[h]=c-1-h;var l=2*c;for(h=c-1;2<c;){if(0>=l--){console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");break}g=h;c<=g&&(g=0);h=g+1;c<=h&&(h=0);k=h+1;c<=k&&(k=0);var n;a:{var p=
n=void 0,m=void 0,q=void 0,r=void 0,s=void 0,u=void 0,x=void 0,v=void 0,p=a[e[g]].x,m=a[e[g]].y,q=a[e[h]].x,r=a[e[h]].y,s=a[e[k]].x,u=a[e[k]].y;if(Number.EPSILON>(q-p)*(u-m)-(r-m)*(s-p))n=!1;else{var C=void 0,w=void 0,D=void 0,A=void 0,y=void 0,B=void 0,G=void 0,z=void 0,H=void 0,M=void 0,H=z=G=v=x=void 0,C=s-q,w=u-r,D=p-s,A=m-u,y=q-p,B=r-m;for(n=0;n<c;n++)if(x=a[e[n]].x,v=a[e[n]].y,!(x===p&&v===m||x===q&&v===r||x===s&&v===u)&&(G=x-p,z=v-m,H=x-q,M=v-r,x-=s,v-=u,H=C*M-w*H,G=y*z-B*G,z=D*v-A*x,H>=-Number.EPSILON&&
z>=-Number.EPSILON&&G>=-Number.EPSILON)){n=!1;break a}n=!0}}if(n){d.push([a[e[g]],a[e[h]],a[e[k]]]);f.push([e[g],e[h],e[k]]);g=h;for(k=h+1;k<c;g++,k++)e[g]=e[k];c--;l=2*c}}return b?f:d}}(),triangulateShape:function(a,b){function c(a,b,c){return a.x!==b.x?a.x<b.x?a.x<=c.x&&c.x<=b.x:b.x<=c.x&&c.x<=a.x:a.y<b.y?a.y<=c.y&&c.y<=b.y:b.y<=c.y&&c.y<=a.y}function d(a,b,d,e,f){var g=b.x-a.x,h=b.y-a.y,k=e.x-d.x,l=e.y-d.y,n=a.x-d.x,p=a.y-d.y,y=h*k-g*l,B=h*n-g*p;if(Math.abs(y)>Number.EPSILON){if(0<y){if(0>B||B>
y)return[];k=l*n-k*p;if(0>k||k>y)return[]}else{if(0<B||B<y)return[];k=l*n-k*p;if(0<k||k<y)return[]}if(0===k)return!f||0!==B&&B!==y?[a]:[];if(k===y)return!f||0!==B&&B!==y?[b]:[];if(0===B)return[d];if(B===y)return[e];f=k/y;return[{x:a.x+f*g,y:a.y+f*h}]}if(0!==B||l*n!==k*p)return[];h=0===g&&0===h;k=0===k&&0===l;if(h&&k)return a.x!==d.x||a.y!==d.y?[]:[a];if(h)return c(d,e,a)?[a]:[];if(k)return c(a,b,d)?[d]:[];0!==g?(a.x<b.x?(g=a,k=a.x,h=b,a=b.x):(g=b,k=b.x,h=a,a=a.x),d.x<e.x?(b=d,y=d.x,l=e,d=e.x):(b=
e,y=e.x,l=d,d=d.x)):(a.y<b.y?(g=a,k=a.y,h=b,a=b.y):(g=b,k=b.y,h=a,a=a.y),d.y<e.y?(b=d,y=d.y,l=e,d=e.y):(b=e,y=e.y,l=d,d=d.y));return k<=y?a<y?[]:a===y?f?[]:[b]:a<=d?[b,h]:[b,l]:k>d?[]:k===d?f?[]:[g]:a<=d?[g,h]:[g,l]}function e(a,b,c,d){var e=b.x-a.x,f=b.y-a.y;b=c.x-a.x;c=c.y-a.y;var g=d.x-a.x;d=d.y-a.y;a=e*c-f*b;e=e*d-f*g;return Math.abs(a)>Number.EPSILON?(b=g*c-d*b,0<a?0<=e&&0<=b:0<=e||0<=b):0<e}var f,g,h,k,l,n={};h=a.concat();f=0;for(g=b.length;f<g;f++)Array.prototype.push.apply(h,b[f]);f=0;for(g=
h.length;f<g;f++)l=h[f].x+":"+h[f].y,void 0!==n[l]&&console.warn("THREE.Shape: Duplicate point",l),n[l]=f;f=function(a,b){function c(a,b){var d=h.length-1,f=a-1;0>f&&(f=d);var g=a+1;g>d&&(g=0);d=e(h[a],h[f],h[g],k[b]);if(!d)return!1;d=k.length-1;f=b-1;0>f&&(f=d);g=b+1;g>d&&(g=0);return(d=e(k[b],k[f],k[g],h[a]))?!0:!1}function f(a,b){var c,e;for(c=0;c<h.length;c++)if(e=c+1,e%=h.length,e=d(a,b,h[c],h[e],!0),0<e.length)return!0;return!1}function g(a,c){var e,f,h,k;for(e=0;e<l.length;e++)for(f=b[l[e]],
h=0;h<f.length;h++)if(k=h+1,k%=f.length,k=d(a,c,f[h],f[k],!0),0<k.length)return!0;return!1}var h=a.concat(),k,l=[],n,p,A,y,B,G=[],z,H,M,O=0;for(n=b.length;O<n;O++)l.push(O);z=0;for(var N=2*l.length;0<l.length;){N--;if(0>N){console.log("Infinite Loop! Holes left:"+l.length+", Probably Hole outside Shape!");break}for(p=z;p<h.length;p++){A=h[p];n=-1;for(O=0;O<l.length;O++)if(y=l[O],B=A.x+":"+A.y+":"+y,void 0===G[B]){k=b[y];for(H=0;H<k.length;H++)if(y=k[H],c(p,H)&&!f(A,y)&&!g(A,y)){n=H;l.splice(O,1);
z=h.slice(0,p+1);y=h.slice(p);H=k.slice(n);M=k.slice(0,n+1);h=z.concat(H).concat(M).concat(y);z=p;break}if(0<=n)break;G[B]=!0}if(0<=n)break}}return h}(a,b);var p=THREE.ShapeUtils.triangulate(f,!1);f=0;for(g=p.length;f<g;f++)for(k=p[f],h=0;3>h;h++)l=k[h].x+":"+k[h].y,l=n[l],void 0!==l&&(k[h]=l);return p.concat()},isClockWise:function(a){return 0>THREE.ShapeUtils.area(a)},b2:function(){return function(a,b,c,d){var e=1-a;return e*e*b+2*(1-a)*a*c+a*a*d}}(),b3:function(){return function(a,b,c,d,e){var f=
1-a,g=1-a;return f*f*f*b+3*g*g*a*c+3*(1-a)*a*a*d+a*a*a*e}}()};THREE.Curve=function(){};
THREE.Curve.prototype={constructor:THREE.Curve,getPoint:function(a){console.warn("THREE.Curve: Warning, getPoint() not implemented!");return null},getPointAt:function(a){a=this.getUtoTmapping(a);return this.getPoint(a)},getPoints:function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPoint(b/a));return c},getSpacedPoints:function(a){a||(a=5);var b,c=[];for(b=0;b<=a;b++)c.push(this.getPointAt(b/a));return c},getLength:function(){var a=this.getLengths();return a[a.length-1]},getLengths:function(a){a||
(a=this.__arcLengthDivisions?this.__arcLengthDivisions:200);if(this.cacheArcLengths&&this.cacheArcLengths.length===a+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;var b=[],c,d=this.getPoint(0),e,f=0;b.push(0);for(e=1;e<=a;e++)c=this.getPoint(e/a),f+=c.distanceTo(d),b.push(f),d=c;return this.cacheArcLengths=b},updateArcLengths:function(){this.needsUpdate=!0;this.getLengths()},getUtoTmapping:function(a,b){var c=this.getLengths(),d=0,e=c.length,f;f=b?b:a*c[e-1];for(var g=0,h=e-
1,k;g<=h;)if(d=Math.floor(g+(h-g)/2),k=c[d]-f,0>k)g=d+1;else if(0<k)h=d-1;else{h=d;break}d=h;if(c[d]===f)return d/(e-1);g=c[d];return c=(d+(f-g)/(c[d+1]-g))/(e-1)},getTangent:function(a){var b=a-1E-4;a+=1E-4;0>b&&(b=0);1<a&&(a=1);b=this.getPoint(b);return this.getPoint(a).clone().sub(b).normalize()},getTangentAt:function(a){a=this.getUtoTmapping(a);return this.getTangent(a)}};
THREE.Curve.create=function(a,b){a.prototype=Object.create(THREE.Curve.prototype);a.prototype.constructor=a;a.prototype.getPoint=b;return a};THREE.CurvePath=function(){this.curves=[];this.autoClose=!1};
THREE.CurvePath.prototype=Object.assign(Object.create(THREE.Curve.prototype),{constructor:THREE.CurvePath,add:function(a){this.curves.push(a)},closePath:function(){var a=this.curves[0].getPoint(0),b=this.curves[this.curves.length-1].getPoint(1);a.equals(b)||this.curves.push(new THREE.LineCurve(b,a))},getPoint:function(a){for(var b=a*this.getLength(),c=this.getCurveLengths(),d=0;d<c.length;){if(c[d]>=b)return a=this.curves[d],b=1-(c[d]-b)/a.getLength(),a.getPointAt(b);d++}return null},getLength:function(){var a=
this.getCurveLengths();return a[a.length-1]},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;for(var a=[],b=0,c=0,d=this.curves.length;c<d;c++)b+=this.curves[c].getLength(),a.push(b);return this.cacheLengths=a},createPointsGeometry:function(a){a=this.getPoints(a);return this.createGeometry(a)},createSpacedPointsGeometry:function(a){a=this.getSpacedPoints(a);return this.createGeometry(a)},createGeometry:function(a){for(var b=new THREE.Geometry,
c=0,d=a.length;c<d;c++){var e=a[c];b.vertices.push(new THREE.Vector3(e.x,e.y,e.z||0))}return b}});THREE.Font=function(a){this.data=a};
Object.assign(THREE.Font.prototype,{generateShapes:function(a,b,c){void 0===b&&(b=100);void 0===c&&(c=4);var d=this.data;a=String(a).split("");var e=b/d.resolution,f=0;b=[];for(var g=0;g<a.length;g++){var h;h=e;var k=f,l=d.glyphs[a[g]]||d.glyphs["?"];if(l){var n=new THREE.Path,p=[],m=THREE.ShapeUtils.b2,q=THREE.ShapeUtils.b3,r=void 0,s=void 0,u=s=r=void 0,x=void 0,v=void 0,C=void 0,w=void 0,D=void 0,x=void 0;if(l.o)for(var A=l._cachedOutline||(l._cachedOutline=l.o.split(" ")),y=0,B=A.length;y<B;)switch(A[y++]){case "m":r=
A[y++]*h+k;s=A[y++]*h;n.moveTo(r,s);break;case "l":r=A[y++]*h+k;s=A[y++]*h;n.lineTo(r,s);break;case "q":r=A[y++]*h+k;s=A[y++]*h;v=A[y++]*h+k;C=A[y++]*h;n.quadraticCurveTo(v,C,r,s);if(x=p[p.length-1])for(var u=x.x,x=x.y,G=1;G<=c;G++){var z=G/c;m(z,u,v,r);m(z,x,C,s)}break;case "b":if(r=A[y++]*h+k,s=A[y++]*h,v=A[y++]*h+k,C=A[y++]*h,w=A[y++]*h+k,D=A[y++]*h,n.bezierCurveTo(v,C,w,D,r,s),x=p[p.length-1])for(u=x.x,x=x.y,G=1;G<=c;G++)z=G/c,q(z,u,v,w,r),q(z,x,C,D,s)}h={offset:l.ha*h,path:n}}else h=void 0;f+=
h.offset;b.push(h.path)}c=[];d=0;for(a=b.length;d<a;d++)Array.prototype.push.apply(c,b[d].toShapes());return c}});THREE.Path=function(a){THREE.CurvePath.call(this);this.actions=[];a&&this.fromPoints(a)};
THREE.Path.prototype=Object.assign(Object.create(THREE.CurvePath.prototype),{constructor:THREE.Path,fromPoints:function(a){this.moveTo(a[0].x,a[0].y);for(var b=1,c=a.length;b<c;b++)this.lineTo(a[b].x,a[b].y)},moveTo:function(a,b){this.actions.push({action:"moveTo",args:[a,b]})},lineTo:function(a,b){var c=this.actions[this.actions.length-1].args,c=new THREE.LineCurve(new THREE.Vector2(c[c.length-2],c[c.length-1]),new THREE.Vector2(a,b));this.curves.push(c);this.actions.push({action:"lineTo",args:[a,
b]})},quadraticCurveTo:function(a,b,c,d){var e=this.actions[this.actions.length-1].args,e=new THREE.QuadraticBezierCurve(new THREE.Vector2(e[e.length-2],e[e.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d));this.curves.push(e);this.actions.push({action:"quadraticCurveTo",args:[a,b,c,d]})},bezierCurveTo:function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args,g=new THREE.CubicBezierCurve(new THREE.Vector2(g[g.length-2],g[g.length-1]),new THREE.Vector2(a,b),new THREE.Vector2(c,d),
new THREE.Vector2(e,f));this.curves.push(g);this.actions.push({action:"bezierCurveTo",args:[a,b,c,d,e,f]})},splineThru:function(a){var b=Array.prototype.slice.call(arguments),c=this.actions[this.actions.length-1].args,c=[new THREE.Vector2(c[c.length-2],c[c.length-1])];Array.prototype.push.apply(c,a);c=new THREE.SplineCurve(c);this.curves.push(c);this.actions.push({action:"splineThru",args:b})},arc:function(a,b,c,d,e,f){var g=this.actions[this.actions.length-1].args;this.absarc(a+g[g.length-2],b+g[g.length-
1],c,d,e,f)},absarc:function(a,b,c,d,e,f){this.absellipse(a,b,c,c,d,e,f)},ellipse:function(a,b,c,d,e,f,g,h){var k=this.actions[this.actions.length-1].args;this.absellipse(a+k[k.length-2],b+k[k.length-1],c,d,e,f,g,h)},absellipse:function(a,b,c,d,e,f,g,h){var k=[a,b,c,d,e,f,g,h||0];a=new THREE.EllipseCurve(a,b,c,d,e,f,g,h);this.curves.push(a);a=a.getPoint(1);k.push(a.x);k.push(a.y);this.actions.push({action:"ellipse",args:k})},getSpacedPoints:function(a){a||(a=40);for(var b=[],c=0;c<a;c++)b.push(this.getPoint(c/
a));this.autoClose&&b.push(b[0]);return b},getPoints:function(a){a=a||12;for(var b=THREE.ShapeUtils.b2,c=THREE.ShapeUtils.b3,d=[],e,f,g,h,k,l,n,p,m,q,r=0,s=this.actions.length;r<s;r++){m=this.actions[r];var u=m.args;switch(m.action){case "moveTo":d.push(new THREE.Vector2(u[0],u[1]));break;case "lineTo":d.push(new THREE.Vector2(u[0],u[1]));break;case "quadraticCurveTo":e=u[2];f=u[3];k=u[0];l=u[1];0<d.length?(m=d[d.length-1],n=m.x,p=m.y):(m=this.actions[r-1].args,n=m[m.length-2],p=m[m.length-1]);for(u=
1;u<=a;u++)q=u/a,m=b(q,n,k,e),q=b(q,p,l,f),d.push(new THREE.Vector2(m,q));break;case "bezierCurveTo":e=u[4];f=u[5];k=u[0];l=u[1];g=u[2];h=u[3];0<d.length?(m=d[d.length-1],n=m.x,p=m.y):(m=this.actions[r-1].args,n=m[m.length-2],p=m[m.length-1]);for(u=1;u<=a;u++)q=u/a,m=c(q,n,k,g,e),q=c(q,p,l,h,f),d.push(new THREE.Vector2(m,q));break;case "splineThru":m=this.actions[r-1].args;q=[new THREE.Vector2(m[m.length-2],m[m.length-1])];m=a*u[0].length;q=q.concat(u[0]);q=new THREE.SplineCurve(q);for(u=1;u<=m;u++)d.push(q.getPointAt(u/
m));break;case "arc":e=u[0];f=u[1];l=u[2];g=u[3];m=u[4];k=!!u[5];n=m-g;p=2*a;for(u=1;u<=p;u++)q=u/p,k||(q=1-q),q=g+q*n,m=e+l*Math.cos(q),q=f+l*Math.sin(q),d.push(new THREE.Vector2(m,q));break;case "ellipse":e=u[0];f=u[1];l=u[2];h=u[3];g=u[4];m=u[5];k=!!u[6];var x=u[7];n=m-g;p=2*a;var v,C;0!==x&&(v=Math.cos(x),C=Math.sin(x));for(u=1;u<=p;u++){q=u/p;k||(q=1-q);q=g+q*n;m=e+l*Math.cos(q);q=f+h*Math.sin(q);if(0!==x){var w=m;m=(w-e)*v-(q-f)*C+e;q=(w-e)*C+(q-f)*v+f}d.push(new THREE.Vector2(m,q))}}}a=d[d.length-
1];Math.abs(a.x-d[0].x)<Number.EPSILON&&Math.abs(a.y-d[0].y)<Number.EPSILON&&d.splice(d.length-1,1);this.autoClose&&d.push(d[0]);return d},toShapes:function(a,b){function c(a){for(var b=[],c=0,d=a.length;c<d;c++){var e=a[c],f=new THREE.Shape;f.actions=e.actions;f.curves=e.curves;b.push(f)}return b}function d(a,b){for(var c=b.length,d=!1,e=c-1,f=0;f<c;e=f++){var g=b[e],h=b[f],k=h.x-g.x,l=h.y-g.y;if(Math.abs(l)>Number.EPSILON){if(0>l&&(g=b[f],k=-k,h=b[e],l=-l),!(a.y<g.y||a.y>h.y))if(a.y===g.y){if(a.x===
g.x)return!0}else{e=l*(a.x-g.x)-k*(a.y-g.y);if(0===e)return!0;0>e||(d=!d)}}else if(a.y===g.y&&(h.x<=a.x&&a.x<=g.x||g.x<=a.x&&a.x<=h.x))return!0}return d}var e=THREE.ShapeUtils.isClockWise,f=function(a){for(var b=[],c=new THREE.Path,d=0,e=a.length;d<e;d++){var f=a[d],g=f.args,f=f.action;"moveTo"===f&&0!==c.actions.length&&(b.push(c),c=new THREE.Path);c[f].apply(c,g)}0!==c.actions.length&&b.push(c);return b}(this.actions);if(0===f.length)return[];if(!0===b)return c(f);var g,h,k,l=[];if(1===f.length)return h=
f[0],k=new THREE.Shape,k.actions=h.actions,k.curves=h.curves,l.push(k),l;var n=!e(f[0].getPoints()),n=a?!n:n;k=[];var p=[],m=[],q=0,r;p[q]=void 0;m[q]=[];for(var s=0,u=f.length;s<u;s++)h=f[s],r=h.getPoints(),g=e(r),(g=a?!g:g)?(!n&&p[q]&&q++,p[q]={s:new THREE.Shape,p:r},p[q].s.actions=h.actions,p[q].s.curves=h.curves,n&&q++,m[q]=[]):m[q].push({h:h,p:r[0]});if(!p[0])return c(f);if(1<p.length){s=!1;h=[];e=0;for(f=p.length;e<f;e++)k[e]=[];e=0;for(f=p.length;e<f;e++)for(g=m[e],n=0;n<g.length;n++){q=g[n];
r=!0;for(u=0;u<p.length;u++)d(q.p,p[u].p)&&(e!==u&&h.push({froms:e,tos:u,hole:n}),r?(r=!1,k[u].push(q)):s=!0);r&&k[e].push(q)}0<h.length&&(s||(m=k))}s=0;for(e=p.length;s<e;s++)for(k=p[s].s,l.push(k),h=m[s],f=0,g=h.length;f<g;f++)k.holes.push(h[f].h);return l}});THREE.Shape=function(){THREE.Path.apply(this,arguments);this.holes=[]};
THREE.Shape.prototype=Object.assign(Object.create(THREE.Path.prototype),{constructor:THREE.Shape,extrude:function(a){return new THREE.ExtrudeGeometry(this,a)},makeGeometry:function(a){return new THREE.ShapeGeometry(this,a)},getPointsHoles:function(a){for(var b=[],c=0,d=this.holes.length;c<d;c++)b[c]=this.holes[c].getPoints(a);return b},extractAllPoints:function(a){return{shape:this.getPoints(a),holes:this.getPointsHoles(a)}},extractPoints:function(a){return this.extractAllPoints(a)}});
THREE.LineCurve=function(a,b){this.v1=a;this.v2=b};THREE.LineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.LineCurve.prototype.constructor=THREE.LineCurve;THREE.LineCurve.prototype.getPoint=function(a){var b=this.v2.clone().sub(this.v1);b.multiplyScalar(a).add(this.v1);return b};THREE.LineCurve.prototype.getPointAt=function(a){return this.getPoint(a)};THREE.LineCurve.prototype.getTangent=function(a){return this.v2.clone().sub(this.v1).normalize()};
THREE.QuadraticBezierCurve=function(a,b,c){this.v0=a;this.v1=b;this.v2=c};THREE.QuadraticBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.QuadraticBezierCurve.prototype.constructor=THREE.QuadraticBezierCurve;THREE.QuadraticBezierCurve.prototype.getPoint=function(a){var b=THREE.ShapeUtils.b2;return new THREE.Vector2(b(a,this.v0.x,this.v1.x,this.v2.x),b(a,this.v0.y,this.v1.y,this.v2.y))};
THREE.QuadraticBezierCurve.prototype.getTangent=function(a){var b=THREE.CurveUtils.tangentQuadraticBezier;return(new THREE.Vector2(b(a,this.v0.x,this.v1.x,this.v2.x),b(a,this.v0.y,this.v1.y,this.v2.y))).normalize()};THREE.CubicBezierCurve=function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d};THREE.CubicBezierCurve.prototype=Object.create(THREE.Curve.prototype);THREE.CubicBezierCurve.prototype.constructor=THREE.CubicBezierCurve;
THREE.CubicBezierCurve.prototype.getPoint=function(a){var b=THREE.ShapeUtils.b3;return new THREE.Vector2(b(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x),b(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y))};THREE.CubicBezierCurve.prototype.getTangent=function(a){var b=THREE.CurveUtils.tangentCubicBezier;return(new THREE.Vector2(b(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x),b(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y))).normalize()};THREE.SplineCurve=function(a){this.points=void 0==a?[]:a};
THREE.SplineCurve.prototype=Object.create(THREE.Curve.prototype);THREE.SplineCurve.prototype.constructor=THREE.SplineCurve;THREE.SplineCurve.prototype.getPoint=function(a){var b=this.points;a*=b.length-1;var c=Math.floor(a);a-=c;var d=b[0===c?c:c-1],e=b[c],f=b[c>b.length-2?b.length-1:c+1],b=b[c>b.length-3?b.length-1:c+2],c=THREE.CurveUtils.interpolate;return new THREE.Vector2(c(d.x,e.x,f.x,b.x,a),c(d.y,e.y,f.y,b.y,a))};
THREE.EllipseCurve=function(a,b,c,d,e,f,g,h){this.aX=a;this.aY=b;this.xRadius=c;this.yRadius=d;this.aStartAngle=e;this.aEndAngle=f;this.aClockwise=g;this.aRotation=h||0};THREE.EllipseCurve.prototype=Object.create(THREE.Curve.prototype);THREE.EllipseCurve.prototype.constructor=THREE.EllipseCurve;
THREE.EllipseCurve.prototype.getPoint=function(a){var b=this.aEndAngle-this.aStartAngle;0>b&&(b+=2*Math.PI);b>2*Math.PI&&(b-=2*Math.PI);b=!0===this.aClockwise?this.aEndAngle+(1-a)*(2*Math.PI-b):this.aStartAngle+a*b;a=this.aX+this.xRadius*Math.cos(b);var c=this.aY+this.yRadius*Math.sin(b);if(0!==this.aRotation){var b=Math.cos(this.aRotation),d=Math.sin(this.aRotation),e=a;a=(e-this.aX)*b-(c-this.aY)*d+this.aX;c=(e-this.aX)*d+(c-this.aY)*b+this.aY}return new THREE.Vector2(a,c)};
THREE.ArcCurve=function(a,b,c,d,e,f){THREE.EllipseCurve.call(this,a,b,c,c,d,e,f)};THREE.ArcCurve.prototype=Object.create(THREE.EllipseCurve.prototype);THREE.ArcCurve.prototype.constructor=THREE.ArcCurve;THREE.LineCurve3=THREE.Curve.create(function(a,b){this.v1=a;this.v2=b},function(a){var b=new THREE.Vector3;b.subVectors(this.v2,this.v1);b.multiplyScalar(a);b.add(this.v1);return b});
THREE.QuadraticBezierCurve3=THREE.Curve.create(function(a,b,c){this.v0=a;this.v1=b;this.v2=c},function(a){var b=THREE.ShapeUtils.b2;return new THREE.Vector3(b(a,this.v0.x,this.v1.x,this.v2.x),b(a,this.v0.y,this.v1.y,this.v2.y),b(a,this.v0.z,this.v1.z,this.v2.z))});
THREE.CubicBezierCurve3=THREE.Curve.create(function(a,b,c,d){this.v0=a;this.v1=b;this.v2=c;this.v3=d},function(a){var b=THREE.ShapeUtils.b3;return new THREE.Vector3(b(a,this.v0.x,this.v1.x,this.v2.x,this.v3.x),b(a,this.v0.y,this.v1.y,this.v2.y,this.v3.y),b(a,this.v0.z,this.v1.z,this.v2.z,this.v3.z))});
THREE.SplineCurve3=THREE.Curve.create(function(a){console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3");this.points=void 0==a?[]:a},function(a){var b=this.points;a*=b.length-1;var c=Math.floor(a);a-=c;var d=b[0==c?c:c-1],e=b[c],f=b[c>b.length-2?b.length-1:c+1],b=b[c>b.length-3?b.length-1:c+2],c=THREE.CurveUtils.interpolate;return new THREE.Vector3(c(d.x,e.x,f.x,b.x,a),c(d.y,e.y,f.y,b.y,a),c(d.z,e.z,f.z,b.z,a))});
THREE.CatmullRomCurve3=function(){function a(){}var b=new THREE.Vector3,c=new a,d=new a,e=new a;a.prototype.init=function(a,b,c,d){this.c0=a;this.c1=c;this.c2=-3*a+3*b-2*c-d;this.c3=2*a-2*b+c+d};a.prototype.initNonuniformCatmullRom=function(a,b,c,d,e,n,p){a=((b-a)/e-(c-a)/(e+n)+(c-b)/n)*n;d=((c-b)/n-(d-b)/(n+p)+(d-c)/p)*n;this.init(b,c,a,d)};a.prototype.initCatmullRom=function(a,b,c,d,e){this.init(b,c,e*(c-a),e*(d-b))};a.prototype.calc=function(a){var b=a*a;return this.c0+this.c1*a+this.c2*b+this.c3*
b*a};return THREE.Curve.create(function(a){this.points=a||[];this.closed=!1},function(a){var g=this.points,h,k;k=g.length;2>k&&console.log("duh, you need at least 2 points");a*=k-(this.closed?0:1);h=Math.floor(a);a-=h;this.closed?h+=0<h?0:(Math.floor(Math.abs(h)/g.length)+1)*g.length:0===a&&h===k-1&&(h=k-2,a=1);var l,n,p;this.closed||0<h?l=g[(h-1)%k]:(b.subVectors(g[0],g[1]).add(g[0]),l=b);n=g[h%k];p=g[(h+1)%k];this.closed||h+2<k?g=g[(h+2)%k]:(b.subVectors(g[k-1],g[k-2]).add(g[k-1]),g=b);if(void 0===
this.type||"centripetal"===this.type||"chordal"===this.type){var m="chordal"===this.type?.5:.25;k=Math.pow(l.distanceToSquared(n),m);h=Math.pow(n.distanceToSquared(p),m);m=Math.pow(p.distanceToSquared(g),m);1E-4>h&&(h=1);1E-4>k&&(k=h);1E-4>m&&(m=h);c.initNonuniformCatmullRom(l.x,n.x,p.x,g.x,k,h,m);d.initNonuniformCatmullRom(l.y,n.y,p.y,g.y,k,h,m);e.initNonuniformCatmullRom(l.z,n.z,p.z,g.z,k,h,m)}else"catmullrom"===this.type&&(k=void 0!==this.tension?this.tension:.5,c.initCatmullRom(l.x,n.x,p.x,g.x,
k),d.initCatmullRom(l.y,n.y,p.y,g.y,k),e.initCatmullRom(l.z,n.z,p.z,g.z,k));return new THREE.Vector3(c.calc(a),d.calc(a),e.calc(a))})}();THREE.ClosedSplineCurve3=function(a){console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.");THREE.CatmullRomCurve3.call(this,a);this.type="catmullrom";this.closed=!0};THREE.ClosedSplineCurve3.prototype=Object.create(THREE.CatmullRomCurve3.prototype);
THREE.BoxGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.type="BoxGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.fromBufferGeometry(new THREE.BoxBufferGeometry(a,b,c,d,e,f));this.mergeVertices()};THREE.BoxGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.BoxGeometry.prototype.constructor=THREE.BoxGeometry;THREE.CubeGeometry=THREE.BoxGeometry;
THREE.BoxBufferGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,k,l,M,O){var N=f/l,E=g/M,K=f/2,I=g/2,L=k/2;g=l+1;for(var P=M+1,Q=f=0,R=new THREE.Vector3,F=0;F<P;F++)for(var da=F*E-I,U=0;U<g;U++)R[a]=(U*N-K)*d,R[b]=da*e,R[c]=L,p[r]=R.x,p[r+1]=R.y,p[r+2]=R.z,R[a]=0,R[b]=0,R[c]=0<k?1:-1,m[r]=R.x,m[r+1]=R.y,m[r+2]=R.z,q[s]=U/l,q[s+1]=1-F/M,r+=3,s+=2,f+=1;for(F=0;F<M;F++)for(U=0;U<l;U++)a=x+U+g*(F+1),b=x+(U+1)+g*(F+1),c=x+(U+1)+g*F,n[u]=x+U+g*F,n[u+1]=a,n[u+2]=c,n[u+3]=a,n[u+4]=b,n[u+5]=c,u+=6,
Q+=6;h.addGroup(v,Q,O);v+=Q;x+=f}THREE.BufferGeometry.call(this);this.type="BoxBufferGeometry";this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};var h=this;d=Math.floor(d)||1;e=Math.floor(e)||1;f=Math.floor(f)||1;var k=function(a,b,c){a=0+(a+1)*(b+1)*2+(a+1)*(c+1)*2;return a+=(c+1)*(b+1)*2}(d,e,f),l=function(a,b,c){a=0+a*b*2+a*c*2;a+=c*b*2;return 6*a}(d,e,f),n=new (65535<l?Uint32Array:Uint16Array)(l),p=new Float32Array(3*k),m=new Float32Array(3*k),q=new Float32Array(2*
k),r=0,s=0,u=0,x=0,v=0;g("z","y","x",-1,-1,c,b,a,f,e,0);g("z","y","x",1,-1,c,b,-a,f,e,1);g("x","z","y",1,1,a,c,b,d,f,2);g("x","z","y",1,-1,a,c,-b,d,f,3);g("x","y","z",1,-1,a,b,c,d,e,4);g("x","y","z",-1,-1,a,b,-c,d,e,5);this.setIndex(new THREE.BufferAttribute(n,1));this.addAttribute("position",new THREE.BufferAttribute(p,3));this.addAttribute("normal",new THREE.BufferAttribute(m,3));this.addAttribute("uv",new THREE.BufferAttribute(q,2))};THREE.BoxBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
THREE.BoxBufferGeometry.prototype.constructor=THREE.BoxBufferGeometry;THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.type="CircleGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};this.fromBufferGeometry(new THREE.CircleBufferGeometry(a,b,c,d))};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CircleGeometry.prototype.constructor=THREE.CircleGeometry;
THREE.CircleBufferGeometry=function(a,b,c,d){THREE.BufferGeometry.call(this);this.type="CircleBufferGeometry";this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};a=a||50;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e=b+2,f=new Float32Array(3*e),g=new Float32Array(3*e),e=new Float32Array(2*e);g[2]=1;e[0]=.5;e[1]=.5;for(var h=0,k=3,l=2;h<=b;h++,k+=3,l+=2){var n=c+h/b*d;f[k]=a*Math.cos(n);f[k+1]=a*Math.sin(n);g[k+2]=1;e[l]=(f[k]/a+1)/2;e[l+1]=(f[k+1]/a+1)/2}c=
[];for(k=1;k<=b;k++)c.push(k,k+1,0);this.setIndex(new THREE.BufferAttribute(new Uint16Array(c),1));this.addAttribute("position",new THREE.BufferAttribute(f,3));this.addAttribute("normal",new THREE.BufferAttribute(g,3));this.addAttribute("uv",new THREE.BufferAttribute(e,2));this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.CircleBufferGeometry.prototype.constructor=THREE.CircleBufferGeometry;
THREE.CylinderBufferGeometry=function(a,b,c,d,e,f,g,h){function k(c){var e,f,k,m=new THREE.Vector2,n=new THREE.Vector3,p=0,C=!0===c?a:b,N=!0===c?1:-1;f=x;for(e=1;e<=d;e++)r.setXYZ(x,0,w*N,0),s.setXYZ(x,0,N,0),m.x=.5,m.y=.5,u.setXY(x,m.x,m.y),x++;k=x;for(e=0;e<=d;e++){var E=e/d*h+g,K=Math.cos(E),E=Math.sin(E);n.x=C*E;n.y=w*N;n.z=C*K;r.setXYZ(x,n.x,n.y,n.z);s.setXYZ(x,0,N,0);m.x=.5*K+.5;m.y=.5*E*N+.5;u.setXY(x,m.x,m.y);x++}for(e=0;e<d;e++)m=f+e,n=k+e,!0===c?(q.setX(v,n),v++,q.setX(v,n+1)):(q.setX(v,
n+1),v++,q.setX(v,n)),v++,q.setX(v,m),v++,p+=3;l.addGroup(D,p,!0===c?1:2);D+=p}THREE.BufferGeometry.call(this);this.type="CylinderBufferGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};var l=this;a=void 0!==a?a:20;b=void 0!==b?b:20;c=void 0!==c?c:100;d=Math.floor(d)||8;e=Math.floor(e)||1;f=void 0!==f?f:!1;g=void 0!==g?g:0;h=void 0!==h?h:2*Math.PI;var n=0;!1===f&&(0<a&&n++,0<b&&n++);var p=function(){var a=(d+1)*
(e+1);!1===f&&(a+=(d+1)*n+d*n);return a}(),m=function(){var a=d*e*6;!1===f&&(a+=d*n*3);return a}(),q=new THREE.BufferAttribute(new (65535<m?Uint32Array:Uint16Array)(m),1),r=new THREE.BufferAttribute(new Float32Array(3*p),3),s=new THREE.BufferAttribute(new Float32Array(3*p),3),u=new THREE.BufferAttribute(new Float32Array(2*p),2),x=0,v=0,C=[],w=c/2,D=0;(function(){var f,k,m=new THREE.Vector3,n=new THREE.Vector3,p=0,H=(b-a)/c;for(k=0;k<=e;k++){var M=[],O=k/e,N=O*(b-a)+a;for(f=0;f<=d;f++){var E=f/d;n.x=
N*Math.sin(E*h+g);n.y=-O*c+w;n.z=N*Math.cos(E*h+g);r.setXYZ(x,n.x,n.y,n.z);m.copy(n);if(0===a&&0===k||0===b&&k===e)m.x=Math.sin(E*h+g),m.z=Math.cos(E*h+g);m.setY(Math.sqrt(m.x*m.x+m.z*m.z)*H).normalize();s.setXYZ(x,m.x,m.y,m.z);u.setXY(x,E,1-O);M.push(x);x++}C.push(M)}for(f=0;f<d;f++)for(k=0;k<e;k++)m=C[k+1][f],n=C[k+1][f+1],H=C[k][f+1],q.setX(v,C[k][f]),v++,q.setX(v,m),v++,q.setX(v,H),v++,q.setX(v,m),v++,q.setX(v,n),v++,q.setX(v,H),v++,p+=6;l.addGroup(D,p,0);D+=p})();!1===f&&(0<a&&k(!0),0<b&&k(!1));
this.setIndex(q);this.addAttribute("position",r);this.addAttribute("normal",s);this.addAttribute("uv",u)};THREE.CylinderBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.CylinderBufferGeometry.prototype.constructor=THREE.CylinderBufferGeometry;
THREE.CylinderGeometry=function(a,b,c,d,e,f,g,h){THREE.Geometry.call(this);this.type="CylinderGeometry";this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f,thetaStart:g,thetaLength:h};this.fromBufferGeometry(new THREE.CylinderBufferGeometry(a,b,c,d,e,f,g,h));this.mergeVertices()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CylinderGeometry.prototype.constructor=THREE.CylinderGeometry;
THREE.ConeBufferGeometry=function(a,b,c,d,e,f,g){THREE.CylinderBufferGeometry.call(this,0,a,b,c,d,e,f,g);this.type="ConeBufferGeometry";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,thetaStart:f,thetaLength:g}};THREE.ConeBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.ConeBufferGeometry.prototype.constructor=THREE.ConeBufferGeometry;
THREE.ConeGeometry=function(a,b,c,d,e,f,g){THREE.CylinderGeometry.call(this,0,a,b,c,d,e,f,g);this.type="ConeGeometry";this.parameters={radius:a,height:b,radialSegments:c,heightSegments:d,openEnded:e,thetaStart:f,thetaLength:g}};THREE.ConeGeometry.prototype=Object.create(THREE.CylinderGeometry.prototype);THREE.ConeGeometry.prototype.constructor=THREE.ConeGeometry;
THREE.EdgesGeometry=function(a,b){function c(a,b){return a-b}THREE.BufferGeometry.call(this);var d=Math.cos(THREE.Math.DEG2RAD*(void 0!==b?b:1)),e=[0,0],f={},g=["a","b","c"],h;a instanceof THREE.BufferGeometry?(h=new THREE.Geometry,h.fromBufferGeometry(a)):h=a.clone();h.mergeVertices();h.computeFaceNormals();var k=h.vertices;h=h.faces;for(var l=0,n=h.length;l<n;l++)for(var p=h[l],m=0;3>m;m++){e[0]=p[g[m]];e[1]=p[g[(m+1)%3]];e.sort(c);var q=e.toString();void 0===f[q]?f[q]={vert1:e[0],vert2:e[1],face1:l,
face2:void 0}:f[q].face2=l}e=[];for(q in f)if(g=f[q],void 0===g.face2||h[g.face1].normal.dot(h[g.face2].normal)<=d)l=k[g.vert1],e.push(l.x),e.push(l.y),e.push(l.z),l=k[g.vert2],e.push(l.x),e.push(l.y),e.push(l.z);this.addAttribute("position",new THREE.BufferAttribute(new Float32Array(e),3))};THREE.EdgesGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.EdgesGeometry.prototype.constructor=THREE.EdgesGeometry;
THREE.ExtrudeGeometry=function(a,b){"undefined"!==typeof a&&(THREE.Geometry.call(this),this.type="ExtrudeGeometry",a=Array.isArray(a)?a:[a],this.addShapeList(a,b),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.constructor=THREE.ExtrudeGeometry;THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};
THREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.error("THREE.ExtrudeGeometry: vec does not exist");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=1,d=a.x-b.x,e=a.y-b.y,f=c.x-a.x,g=c.y-a.y,h=d*d+e*e;if(Math.abs(d*g-e*f)>Number.EPSILON){var k=Math.sqrt(h),l=Math.sqrt(f*f+g*g),h=b.x-e/k;b=b.y+d/k;f=((c.x-g/l-h)*g-(c.y+f/l-b)*f)/(d*g-e*f);c=h+d*f-a.x;a=b+e*f-a.y;d=c*c+a*a;if(2>=d)return new THREE.Vector2(c,a);d=Math.sqrt(d/2)}else a=!1,d>Number.EPSILON?
f>Number.EPSILON&&(a=!0):d<-Number.EPSILON?f<-Number.EPSILON&&(a=!0):Math.sign(e)===Math.sign(g)&&(a=!0),a?(c=-e,a=d,d=Math.sqrt(h)):(c=d,a=e,d=Math.sqrt(h/2));return new THREE.Vector2(c/d,a/d)}function e(a,b){var c,d;for(F=a.length;0<=--F;){c=F;d=F-1;0>d&&(d=a.length-1);for(var e=0,f=q+2*n,e=0;e<f;e++){var g=P*e,h=P*(e+1),k=b+c+g,g=b+d+g,l=b+d+h,h=b+c+h,k=k+z,g=g+z,l=l+z,h=h+z;G.faces.push(new THREE.Face3(k,g,h,null,null,1));G.faces.push(new THREE.Face3(g,l,h,null,null,1));k=x.generateSideWallUV(G,
k,g,l,h);G.faceVertexUvs[0].push([k[0],k[1],k[3]]);G.faceVertexUvs[0].push([k[1],k[2],k[3]])}}}function f(a,b,c){G.vertices.push(new THREE.Vector3(a,b,c))}function g(a,b,c){a+=z;b+=z;c+=z;G.faces.push(new THREE.Face3(a,b,c,null,null,0));a=x.generateTopUV(G,a,b,c);G.faceVertexUvs[0].push(a)}var h=void 0!==b.amount?b.amount:100,k=void 0!==b.bevelThickness?b.bevelThickness:6,l=void 0!==b.bevelSize?b.bevelSize:k-2,n=void 0!==b.bevelSegments?b.bevelSegments:3,p=void 0!==b.bevelEnabled?b.bevelEnabled:!0,
m=void 0!==b.curveSegments?b.curveSegments:12,q=void 0!==b.steps?b.steps:1,r=b.extrudePath,s,u=!1,x=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,v,C,w,D;r&&(s=r.getSpacedPoints(q),u=!0,p=!1,v=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(r,q,!1),C=new THREE.Vector3,w=new THREE.Vector3,D=new THREE.Vector3);p||(l=k=n=0);var A,y,B,G=this,z=this.vertices.length,r=a.extractPoints(m),m=r.shape,H=r.holes;if(r=!THREE.ShapeUtils.isClockWise(m)){m=m.reverse();
y=0;for(B=H.length;y<B;y++)A=H[y],THREE.ShapeUtils.isClockWise(A)&&(H[y]=A.reverse());r=!1}var M=THREE.ShapeUtils.triangulateShape(m,H),O=m;y=0;for(B=H.length;y<B;y++)A=H[y],m=m.concat(A);var N,E,K,I,L,P=m.length,Q,R=M.length,r=[],F=0;K=O.length;N=K-1;for(E=F+1;F<K;F++,N++,E++)N===K&&(N=0),E===K&&(E=0),r[F]=d(O[F],O[N],O[E]);var da=[],U,Y=r.concat();y=0;for(B=H.length;y<B;y++){A=H[y];U=[];F=0;K=A.length;N=K-1;for(E=F+1;F<K;F++,N++,E++)N===K&&(N=0),E===K&&(E=0),U[F]=d(A[F],A[N],A[E]);da.push(U);Y=
Y.concat(U)}for(N=0;N<n;N++){K=N/n;I=k*(1-K);E=l*Math.sin(K*Math.PI/2);F=0;for(K=O.length;F<K;F++)L=c(O[F],r[F],E),f(L.x,L.y,-I);y=0;for(B=H.length;y<B;y++)for(A=H[y],U=da[y],F=0,K=A.length;F<K;F++)L=c(A[F],U[F],E),f(L.x,L.y,-I)}E=l;for(F=0;F<P;F++)L=p?c(m[F],Y[F],E):m[F],u?(w.copy(v.normals[0]).multiplyScalar(L.x),C.copy(v.binormals[0]).multiplyScalar(L.y),D.copy(s[0]).add(w).add(C),f(D.x,D.y,D.z)):f(L.x,L.y,0);for(K=1;K<=q;K++)for(F=0;F<P;F++)L=p?c(m[F],Y[F],E):m[F],u?(w.copy(v.normals[K]).multiplyScalar(L.x),
C.copy(v.binormals[K]).multiplyScalar(L.y),D.copy(s[K]).add(w).add(C),f(D.x,D.y,D.z)):f(L.x,L.y,h/q*K);for(N=n-1;0<=N;N--){K=N/n;I=k*(1-K);E=l*Math.sin(K*Math.PI/2);F=0;for(K=O.length;F<K;F++)L=c(O[F],r[F],E),f(L.x,L.y,h+I);y=0;for(B=H.length;y<B;y++)for(A=H[y],U=da[y],F=0,K=A.length;F<K;F++)L=c(A[F],U[F],E),u?f(L.x,L.y+s[q-1].y,s[q-1].x+I):f(L.x,L.y,h+I)}(function(){if(p){var a;a=0*P;for(F=0;F<R;F++)Q=M[F],g(Q[2]+a,Q[1]+a,Q[0]+a);a=q+2*n;a*=P;for(F=0;F<R;F++)Q=M[F],g(Q[0]+a,Q[1]+a,Q[2]+a)}else{for(F=
0;F<R;F++)Q=M[F],g(Q[2],Q[1],Q[0]);for(F=0;F<R;F++)Q=M[F],g(Q[0]+P*q,Q[1]+P*q,Q[2]+P*q)}})();(function(){var a=0;e(O,a);a+=O.length;y=0;for(B=H.length;y<B;y++)A=H[y],e(A,a),a+=A.length})()};
THREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d){a=a.vertices;b=a[b];c=a[c];d=a[d];return[new THREE.Vector2(b.x,b.y),new THREE.Vector2(c.x,c.y),new THREE.Vector2(d.x,d.y)]},generateSideWallUV:function(a,b,c,d,e){a=a.vertices;b=a[b];c=a[c];d=a[d];e=a[e];return.01>Math.abs(b.y-c.y)?[new THREE.Vector2(b.x,1-b.z),new THREE.Vector2(c.x,1-c.z),new THREE.Vector2(d.x,1-d.z),new THREE.Vector2(e.x,1-e.z)]:[new THREE.Vector2(b.y,1-b.z),new THREE.Vector2(c.y,1-c.z),new THREE.Vector2(d.y,
1-d.z),new THREE.Vector2(e.y,1-e.z)]}};THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);this.type="ShapeGeometry";!1===Array.isArray(a)&&(a=[a]);this.addShapeList(a,b);this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.constructor=THREE.ShapeGeometry;THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};
THREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var k=e.shape,l=e.holes;if(!THREE.ShapeUtils.isClockWise(k))for(k=k.reverse(),e=0,f=l.length;e<f;e++)g=l[e],THREE.ShapeUtils.isClockWise(g)&&(l[e]=g.reverse());var n=THREE.ShapeUtils.triangulateShape(k,l);e=0;for(f=l.length;e<f;e++)g=l[e],k=k.concat(g);
l=k.length;f=n.length;for(e=0;e<l;e++)g=k[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)l=n[e],k=l[0]+h,g=l[1]+h,l=l[2]+h,this.faces.push(new THREE.Face3(k,g,l,null,null,c)),this.faceVertexUvs[0].push(d.generateTopUV(this,k,g,l))};
THREE.LatheBufferGeometry=function(a,b,c,d){THREE.BufferGeometry.call(this);this.type="LatheBufferGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};b=Math.floor(b)||12;c=c||0;d=d||2*Math.PI;d=THREE.Math.clamp(d,0,2*Math.PI);for(var e=(b+1)*a.length,f=b*a.length*6,g=new THREE.BufferAttribute(new (65535<f?Uint32Array:Uint16Array)(f),1),h=new THREE.BufferAttribute(new Float32Array(3*e),3),k=new THREE.BufferAttribute(new Float32Array(2*e),2),l=0,n=0,p=1/b,m=new THREE.Vector3,q=new THREE.Vector2,
e=0;e<=b;e++)for(var f=c+e*p*d,r=Math.sin(f),s=Math.cos(f),f=0;f<=a.length-1;f++)m.x=a[f].x*r,m.y=a[f].y,m.z=a[f].x*s,h.setXYZ(l,m.x,m.y,m.z),q.x=e/b,q.y=f/(a.length-1),k.setXY(l,q.x,q.y),l++;for(e=0;e<b;e++)for(f=0;f<a.length-1;f++)c=f+e*a.length,l=c+a.length,p=c+a.length+1,m=c+1,g.setX(n,c),n++,g.setX(n,l),n++,g.setX(n,m),n++,g.setX(n,l),n++,g.setX(n,p),n++,g.setX(n,m),n++;this.setIndex(g);this.addAttribute("position",h);this.addAttribute("uv",k);this.computeVertexNormals();if(d===2*Math.PI)for(d=
this.attributes.normal.array,g=new THREE.Vector3,h=new THREE.Vector3,k=new THREE.Vector3,c=b*a.length*3,f=e=0;e<a.length;e++,f+=3)g.x=d[f+0],g.y=d[f+1],g.z=d[f+2],h.x=d[c+f+0],h.y=d[c+f+1],h.z=d[c+f+2],k.addVectors(g,h).normalize(),d[f+0]=d[c+f+0]=k.x,d[f+1]=d[c+f+1]=k.y,d[f+2]=d[c+f+2]=k.z};THREE.LatheBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.LatheBufferGeometry.prototype.constructor=THREE.LatheBufferGeometry;
THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.type="LatheGeometry";this.parameters={points:a,segments:b,phiStart:c,phiLength:d};this.fromBufferGeometry(new THREE.LatheBufferGeometry(a,b,c,d));this.mergeVertices()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.LatheGeometry.prototype.constructor=THREE.LatheGeometry;
THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.type="PlaneGeometry";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a,b,c,d))};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PlaneGeometry.prototype.constructor=THREE.PlaneGeometry;
THREE.PlaneBufferGeometry=function(a,b,c,d){THREE.BufferGeometry.call(this);this.type="PlaneBufferGeometry";this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};var e=a/2,f=b/2;c=Math.floor(c)||1;d=Math.floor(d)||1;var g=c+1,h=d+1,k=a/c,l=b/d;b=new Float32Array(g*h*3);a=new Float32Array(g*h*3);for(var n=new Float32Array(g*h*2),p=0,m=0,q=0;q<h;q++)for(var r=q*l-f,s=0;s<g;s++)b[p]=s*k-e,b[p+1]=-r,a[p+2]=1,n[m]=s/c,n[m+1]=1-q/d,p+=3,m+=2;p=0;e=new (65535<b.length/3?Uint32Array:Uint16Array)(c*
d*6);for(q=0;q<d;q++)for(s=0;s<c;s++)f=s+g*(q+1),h=s+1+g*(q+1),k=s+1+g*q,e[p]=s+g*q,e[p+1]=f,e[p+2]=k,e[p+3]=f,e[p+4]=h,e[p+5]=k,p+=6;this.setIndex(new THREE.BufferAttribute(e,1));this.addAttribute("position",new THREE.BufferAttribute(b,3));this.addAttribute("normal",new THREE.BufferAttribute(a,3));this.addAttribute("uv",new THREE.BufferAttribute(n,2))};THREE.PlaneBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.PlaneBufferGeometry.prototype.constructor=THREE.PlaneBufferGeometry;
THREE.RingBufferGeometry=function(a,b,c,d,e,f){THREE.BufferGeometry.call(this);this.type="RingBufferGeometry";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};a=a||20;b=b||50;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):1;var g=(c+1)*(d+1),h=c*d*6,h=new THREE.BufferAttribute(new (65535<h?Uint32Array:Uint16Array)(h),1),k=new THREE.BufferAttribute(new Float32Array(3*g),3),l=new THREE.BufferAttribute(new Float32Array(3*
g),3),g=new THREE.BufferAttribute(new Float32Array(2*g),2),n=0,p=0,m,q=a,r=(b-a)/d,s=new THREE.Vector3,u=new THREE.Vector2,x;for(a=0;a<=d;a++){for(x=0;x<=c;x++)m=e+x/c*f,s.x=q*Math.cos(m),s.y=q*Math.sin(m),k.setXYZ(n,s.x,s.y,s.z),l.setXYZ(n,0,0,1),u.x=(s.x/b+1)/2,u.y=(s.y/b+1)/2,g.setXY(n,u.x,u.y),n++;q+=r}for(a=0;a<d;a++)for(b=a*(c+1),x=0;x<c;x++)e=m=x+b,f=m+c+1,n=m+c+2,m+=1,h.setX(p,e),p++,h.setX(p,f),p++,h.setX(p,n),p++,h.setX(p,e),p++,h.setX(p,n),p++,h.setX(p,m),p++;this.setIndex(h);this.addAttribute("position",
k);this.addAttribute("normal",l);this.addAttribute("uv",g)};THREE.RingBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.RingBufferGeometry.prototype.constructor=THREE.RingBufferGeometry;THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.type="RingGeometry";this.parameters={innerRadius:a,outerRadius:b,thetaSegments:c,phiSegments:d,thetaStart:e,thetaLength:f};this.fromBufferGeometry(new THREE.RingBufferGeometry(a,b,c,d,e,f))};
THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.RingGeometry.prototype.constructor=THREE.RingGeometry;THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.type="SphereGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};this.fromBufferGeometry(new THREE.SphereBufferGeometry(a,b,c,d,e,f,g))};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry.prototype.constructor=THREE.SphereGeometry;
THREE.SphereBufferGeometry=function(a,b,c,d,e,f,g){THREE.BufferGeometry.call(this);this.type="SphereBufferGeometry";this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||50;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;for(var h=f+g,k=(b+1)*(c+1),l=new THREE.BufferAttribute(new Float32Array(3*k),3),n=new THREE.BufferAttribute(new Float32Array(3*
k),3),k=new THREE.BufferAttribute(new Float32Array(2*k),2),p=0,m=[],q=new THREE.Vector3,r=0;r<=c;r++){for(var s=[],u=r/c,x=0;x<=b;x++){var v=x/b,C=-a*Math.cos(d+v*e)*Math.sin(f+u*g),w=a*Math.cos(f+u*g),D=a*Math.sin(d+v*e)*Math.sin(f+u*g);q.set(C,w,D).normalize();l.setXYZ(p,C,w,D);n.setXYZ(p,q.x,q.y,q.z);k.setXY(p,v,1-u);s.push(p);p++}m.push(s)}d=[];for(r=0;r<c;r++)for(x=0;x<b;x++)e=m[r][x+1],g=m[r][x],p=m[r+1][x],q=m[r+1][x+1],(0!==r||0<f)&&d.push(e,g,q),(r!==c-1||h<Math.PI)&&d.push(g,p,q);this.setIndex(new (65535<
l.count?THREE.Uint32Attribute:THREE.Uint16Attribute)(d,1));this.addAttribute("position",l);this.addAttribute("normal",n);this.addAttribute("uv",k);this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.SphereBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.SphereBufferGeometry.prototype.constructor=THREE.SphereBufferGeometry;
THREE.TextGeometry=function(a,b){b=b||{};var c=b.font;if(!1===c instanceof THREE.Font)return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),new THREE.Geometry;c=c.generateShapes(a,b.size,b.curveSegments);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b);this.type="TextGeometry"};
THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);THREE.TextGeometry.prototype.constructor=THREE.TextGeometry;
THREE.TorusBufferGeometry=function(a,b,c,d,e){THREE.BufferGeometry.call(this);this.type="TorusBufferGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};a=a||100;b=b||40;c=Math.floor(c)||8;d=Math.floor(d)||6;e=e||2*Math.PI;var f=(c+1)*(d+1),g=c*d*6,g=new (65535<g?Uint32Array:Uint16Array)(g),h=new Float32Array(3*f),k=new Float32Array(3*f),f=new Float32Array(2*f),l=0,n=0,p=0,m=new THREE.Vector3,q=new THREE.Vector3,r=new THREE.Vector3,s,u;for(s=0;s<=c;s++)for(u=0;u<=d;u++){var x=
u/d*e,v=s/c*Math.PI*2;q.x=(a+b*Math.cos(v))*Math.cos(x);q.y=(a+b*Math.cos(v))*Math.sin(x);q.z=b*Math.sin(v);h[l]=q.x;h[l+1]=q.y;h[l+2]=q.z;m.x=a*Math.cos(x);m.y=a*Math.sin(x);r.subVectors(q,m).normalize();k[l]=r.x;k[l+1]=r.y;k[l+2]=r.z;f[n]=u/d;f[n+1]=s/c;l+=3;n+=2}for(s=1;s<=c;s++)for(u=1;u<=d;u++)a=(d+1)*(s-1)+u-1,b=(d+1)*(s-1)+u,e=(d+1)*s+u,g[p]=(d+1)*s+u-1,g[p+1]=a,g[p+2]=e,g[p+3]=a,g[p+4]=b,g[p+5]=e,p+=6;this.setIndex(new THREE.BufferAttribute(g,1));this.addAttribute("position",new THREE.BufferAttribute(h,
3));this.addAttribute("normal",new THREE.BufferAttribute(k,3));this.addAttribute("uv",new THREE.BufferAttribute(f,2))};THREE.TorusBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.TorusBufferGeometry.prototype.constructor=THREE.TorusBufferGeometry;
THREE.TorusGeometry=function(a,b,c,d,e){THREE.Geometry.call(this);this.type="TorusGeometry";this.parameters={radius:a,tube:b,radialSegments:c,tubularSegments:d,arc:e};this.fromBufferGeometry(new THREE.TorusBufferGeometry(a,b,c,d,e))};THREE.TorusGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TorusGeometry.prototype.constructor=THREE.TorusGeometry;
THREE.TorusKnotBufferGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e){var f=Math.cos(a),g=Math.sin(a);a*=c/b;b=Math.cos(a);e.x=d*(2+b)*.5*f;e.y=d*(2+b)*g*.5;e.z=d*Math.sin(a)*.5}THREE.BufferGeometry.call(this);this.type="TorusKnotBufferGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};a=a||100;b=b||40;c=Math.floor(c)||64;d=Math.floor(d)||8;e=e||2;f=f||3;var h=(d+1)*(c+1),k=d*c*6,k=new THREE.BufferAttribute(new (65535<k?Uint32Array:Uint16Array)(k),1),l=new THREE.BufferAttribute(new Float32Array(3*
h),3),n=new THREE.BufferAttribute(new Float32Array(3*h),3),h=new THREE.BufferAttribute(new Float32Array(2*h),2),p,m,q=0,r=0,s=new THREE.Vector3,u=new THREE.Vector3,x=new THREE.Vector2,v=new THREE.Vector3,C=new THREE.Vector3,w=new THREE.Vector3,D=new THREE.Vector3,A=new THREE.Vector3;for(p=0;p<=c;++p)for(m=p/c*e*Math.PI*2,g(m,e,f,a,v),g(m+.01,e,f,a,C),D.subVectors(C,v),A.addVectors(C,v),w.crossVectors(D,A),A.crossVectors(w,D),w.normalize(),A.normalize(),m=0;m<=d;++m){var y=m/d*Math.PI*2,B=-b*Math.cos(y),
y=b*Math.sin(y);s.x=v.x+(B*A.x+y*w.x);s.y=v.y+(B*A.y+y*w.y);s.z=v.z+(B*A.z+y*w.z);l.setXYZ(q,s.x,s.y,s.z);u.subVectors(s,v).normalize();n.setXYZ(q,u.x,u.y,u.z);x.x=p/c;x.y=m/d;h.setXY(q,x.x,x.y);q++}for(m=1;m<=c;m++)for(p=1;p<=d;p++)a=(d+1)*m+(p-1),b=(d+1)*m+p,e=(d+1)*(m-1)+p,k.setX(r,(d+1)*(m-1)+(p-1)),r++,k.setX(r,a),r++,k.setX(r,e),r++,k.setX(r,a),r++,k.setX(r,b),r++,k.setX(r,e),r++;this.setIndex(k);this.addAttribute("position",l);this.addAttribute("normal",n);this.addAttribute("uv",h)};
THREE.TorusKnotBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);THREE.TorusKnotBufferGeometry.prototype.constructor=THREE.TorusKnotBufferGeometry;
THREE.TorusKnotGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.type="TorusKnotGeometry";this.parameters={radius:a,tube:b,tubularSegments:c,radialSegments:d,p:e,q:f};void 0!==g&&console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(a,b,c,d,e,f));this.mergeVertices()};THREE.TorusKnotGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry.prototype.constructor=THREE.TorusKnotGeometry;
THREE.TubeGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.type="TubeGeometry";this.parameters={path:a,segments:b,radius:c,radialSegments:d,closed:e,taper:f};b=b||64;c=c||1;d=d||8;e=e||!1;f=f||THREE.TubeGeometry.NoTaper;var g=[],h,k,l=b+1,n,p,m,q,r,s=new THREE.Vector3,u,x,v;u=new THREE.TubeGeometry.FrenetFrames(a,b,e);x=u.normals;v=u.binormals;this.tangents=u.tangents;this.normals=x;this.binormals=v;for(u=0;u<l;u++)for(g[u]=[],n=u/(l-1),r=a.getPointAt(n),h=x[u],k=v[u],m=c*f(n),n=0;n<
d;n++)p=n/d*2*Math.PI,q=-m*Math.cos(p),p=m*Math.sin(p),s.copy(r),s.x+=q*h.x+p*k.x,s.y+=q*h.y+p*k.y,s.z+=q*h.z+p*k.z,g[u][n]=this.vertices.push(new THREE.Vector3(s.x,s.y,s.z))-1;for(u=0;u<b;u++)for(n=0;n<d;n++)f=e?(u+1)%b:u+1,l=(n+1)%d,a=g[u][n],c=g[f][n],f=g[f][l],l=g[u][l],s=new THREE.Vector2(u/b,n/d),x=new THREE.Vector2((u+1)/b,n/d),v=new THREE.Vector2((u+1)/b,(n+1)/d),h=new THREE.Vector2(u/b,(n+1)/d),this.faces.push(new THREE.Face3(a,c,l)),this.faceVertexUvs[0].push([s,x,h]),this.faces.push(new THREE.Face3(c,
f,l)),this.faceVertexUvs[0].push([x.clone(),v,h.clone()]);this.computeFaceNormals();this.computeVertexNormals()};THREE.TubeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TubeGeometry.prototype.constructor=THREE.TubeGeometry;THREE.TubeGeometry.NoTaper=function(a){return 1};THREE.TubeGeometry.SinusoidalTaper=function(a){return Math.sin(Math.PI*a)};
THREE.TubeGeometry.FrenetFrames=function(a,b,c){var d=new THREE.Vector3,e=[],f=[],g=[],h=new THREE.Vector3,k=new THREE.Matrix4;b+=1;var l,n,p;this.tangents=e;this.normals=f;this.binormals=g;for(l=0;l<b;l++)n=l/(b-1),e[l]=a.getTangentAt(n),e[l].normalize();f[0]=new THREE.Vector3;g[0]=new THREE.Vector3;a=Number.MAX_VALUE;l=Math.abs(e[0].x);n=Math.abs(e[0].y);p=Math.abs(e[0].z);l<=a&&(a=l,d.set(1,0,0));n<=a&&(a=n,d.set(0,1,0));p<=a&&d.set(0,0,1);h.crossVectors(e[0],d).normalize();f[0].crossVectors(e[0],
h);g[0].crossVectors(e[0],f[0]);for(l=1;l<b;l++)f[l]=f[l-1].clone(),g[l]=g[l-1].clone(),h.crossVectors(e[l-1],e[l]),h.length()>Number.EPSILON&&(h.normalize(),d=Math.acos(THREE.Math.clamp(e[l-1].dot(e[l]),-1,1)),f[l].applyMatrix4(k.makeRotationAxis(h,d))),g[l].crossVectors(e[l],f[l]);if(c)for(d=Math.acos(THREE.Math.clamp(f[0].dot(f[b-1]),-1,1)),d/=b-1,0<e[0].dot(h.crossVectors(f[0],f[b-1]))&&(d=-d),l=1;l<b;l++)f[l].applyMatrix4(k.makeRotationAxis(e[l],d*l)),g[l].crossVectors(e[l],f[l])};
THREE.PolyhedronGeometry=function(a,b,c,d){function e(a){var b=a.normalize().clone();b.index=k.vertices.push(b)-1;var c=Math.atan2(a.z,-a.x)/2/Math.PI+.5;a=Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))/Math.PI+.5;b.uv=new THREE.Vector2(c,1-a);return b}function f(a,b,c,d){d=new THREE.Face3(a.index,b.index,c.index,[a.clone(),b.clone(),c.clone()],void 0,d);k.faces.push(d);u.copy(a).add(b).add(c).divideScalar(3);d=Math.atan2(u.z,-u.x);k.faceVertexUvs[0].push([h(a.uv,a,d),h(b.uv,b,d),h(c.uv,c,d)])}function g(a,
b){for(var c=Math.pow(2,b),d=e(k.vertices[a.a]),g=e(k.vertices[a.b]),h=e(k.vertices[a.c]),l=[],m=a.materialIndex,n=0;n<=c;n++){l[n]=[];for(var p=e(d.clone().lerp(h,n/c)),q=e(g.clone().lerp(h,n/c)),r=c-n,s=0;s<=r;s++)l[n][s]=0===s&&n===c?p:e(p.clone().lerp(q,s/r))}for(n=0;n<c;n++)for(s=0;s<2*(c-n)-1;s++)d=Math.floor(s/2),0===s%2?f(l[n][d+1],l[n+1][d],l[n][d],m):f(l[n][d+1],l[n+1][d+1],l[n+1][d],m)}function h(a,b,c){0>c&&1===a.x&&(a=new THREE.Vector2(a.x-1,a.y));0===b.x&&0===b.z&&(a=new THREE.Vector2(c/
2/Math.PI+.5,a.y));return a.clone()}THREE.Geometry.call(this);this.type="PolyhedronGeometry";this.parameters={vertices:a,indices:b,radius:c,detail:d};c=c||1;d=d||0;for(var k=this,l=0,n=a.length;l<n;l+=3)e(new THREE.Vector3(a[l],a[l+1],a[l+2]));a=this.vertices;for(var p=[],m=l=0,n=b.length;l<n;l+=3,m++){var q=a[b[l]],r=a[b[l+1]],s=a[b[l+2]];p[m]=new THREE.Face3(q.index,r.index,s.index,[q.clone(),r.clone(),s.clone()],void 0,m)}for(var u=new THREE.Vector3,l=0,n=p.length;l<n;l++)g(p[l],d);l=0;for(n=this.faceVertexUvs[0].length;l<
n;l++)b=this.faceVertexUvs[0][l],d=b[0].x,a=b[1].x,p=b[2].x,m=Math.max(d,a,p),q=Math.min(d,a,p),.9<m&&.1>q&&(.2>d&&(b[0].x+=1),.2>a&&(b[1].x+=1),.2>p&&(b[2].x+=1));l=0;for(n=this.vertices.length;l<n;l++)this.vertices[l].multiplyScalar(c);this.mergeVertices();this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,c)};THREE.PolyhedronGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.PolyhedronGeometry.prototype.constructor=THREE.PolyhedronGeometry;
THREE.DodecahedronGeometry=function(a,b){var c=(1+Math.sqrt(5))/2,d=1/c;THREE.PolyhedronGeometry.call(this,[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-d,-c,0,-d,c,0,d,-c,0,d,c,-d,-c,0,-d,c,0,d,-c,0,d,c,0,-c,0,-d,c,0,-d,-c,0,d,c,0,d],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,
12,14,1,14,5,1,5,9],a,b);this.type="DodecahedronGeometry";this.parameters={radius:a,detail:b}};THREE.DodecahedronGeometry.prototype=Object.create(THREE.PolyhedronGeometry.prototype);THREE.DodecahedronGeometry.prototype.constructor=THREE.DodecahedronGeometry;
THREE.IcosahedronGeometry=function(a,b){var c=(1+Math.sqrt(5))/2;THREE.PolyhedronGeometry.call(this,[-1,c,0,1,c,0,-1,-c,0,1,-c,0,0,-1,c,0,1,c,0,-1,-c,0,1,-c,c,0,-1,c,0,1,-c,0,-1,-c,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],a,b);this.type="IcosahedronGeometry";this.parameters={radius:a,detail:b}};THREE.IcosahedronGeometry.prototype=Object.create(THREE.PolyhedronGeometry.prototype);
THREE.IcosahedronGeometry.prototype.constructor=THREE.IcosahedronGeometry;THREE.OctahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],a,b);this.type="OctahedronGeometry";this.parameters={radius:a,detail:b}};THREE.OctahedronGeometry.prototype=Object.create(THREE.PolyhedronGeometry.prototype);THREE.OctahedronGeometry.prototype.constructor=THREE.OctahedronGeometry;
THREE.TetrahedronGeometry=function(a,b){THREE.PolyhedronGeometry.call(this,[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],a,b);this.type="TetrahedronGeometry";this.parameters={radius:a,detail:b}};THREE.TetrahedronGeometry.prototype=Object.create(THREE.PolyhedronGeometry.prototype);THREE.TetrahedronGeometry.prototype.constructor=THREE.TetrahedronGeometry;
THREE.ParametricGeometry=function(a,b,c){THREE.Geometry.call(this);this.type="ParametricGeometry";this.parameters={func:a,slices:b,stacks:c};var d=this.vertices,e=this.faces,f=this.faceVertexUvs[0],g,h,k,l,n=b+1;for(g=0;g<=c;g++)for(l=g/c,h=0;h<=b;h++)k=h/b,k=a(k,l),d.push(k);var p,m,q,r;for(g=0;g<c;g++)for(h=0;h<b;h++)a=g*n+h,d=g*n+h+1,l=(g+1)*n+h+1,k=(g+1)*n+h,p=new THREE.Vector2(h/b,g/c),m=new THREE.Vector2((h+1)/b,g/c),q=new THREE.Vector2((h+1)/b,(g+1)/c),r=new THREE.Vector2(h/b,(g+1)/c),e.push(new THREE.Face3(a,
d,k)),f.push([p,m,r]),e.push(new THREE.Face3(d,l,k)),f.push([m.clone(),q,r.clone()]);this.computeFaceNormals();this.computeVertexNormals()};THREE.ParametricGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ParametricGeometry.prototype.constructor=THREE.ParametricGeometry;
THREE.WireframeGeometry=function(a){function b(a,b){return a-b}THREE.BufferGeometry.call(this);var c=[0,0],d={},e=["a","b","c"];if(a instanceof THREE.Geometry){var f=a.vertices,g=a.faces,h=0,k=new Uint32Array(6*g.length);a=0;for(var l=g.length;a<l;a++)for(var n=g[a],p=0;3>p;p++){c[0]=n[e[p]];c[1]=n[e[(p+1)%3]];c.sort(b);var m=c.toString();void 0===d[m]&&(k[2*h]=c[0],k[2*h+1]=c[1],d[m]=!0,h++)}c=new Float32Array(6*h);a=0;for(l=h;a<l;a++)for(p=0;2>p;p++)d=f[k[2*a+p]],h=6*a+3*p,c[h+0]=d.x,c[h+1]=d.y,
c[h+2]=d.z;this.addAttribute("position",new THREE.BufferAttribute(c,3))}else if(a instanceof THREE.BufferGeometry){if(null!==a.index){l=a.index.array;f=a.attributes.position;e=a.groups;h=0;0===e.length&&a.addGroup(0,l.length);k=new Uint32Array(2*l.length);g=0;for(n=e.length;g<n;++g){a=e[g];p=a.start;m=a.count;a=p;for(var q=p+m;a<q;a+=3)for(p=0;3>p;p++)c[0]=l[a+p],c[1]=l[a+(p+1)%3],c.sort(b),m=c.toString(),void 0===d[m]&&(k[2*h]=c[0],k[2*h+1]=c[1],d[m]=!0,h++)}c=new Float32Array(6*h);a=0;for(l=h;a<
l;a++)for(p=0;2>p;p++)h=6*a+3*p,d=k[2*a+p],c[h+0]=f.getX(d),c[h+1]=f.getY(d),c[h+2]=f.getZ(d)}else for(f=a.attributes.position.array,h=f.length/3,k=h/3,c=new Float32Array(6*h),a=0,l=k;a<l;a++)for(p=0;3>p;p++)h=18*a+6*p,k=9*a+3*p,c[h+0]=f[k],c[h+1]=f[k+1],c[h+2]=f[k+2],d=9*a+(p+1)%3*3,c[h+3]=f[d],c[h+4]=f[d+1],c[h+5]=f[d+2];this.addAttribute("position",new THREE.BufferAttribute(c,3))}};THREE.WireframeGeometry.prototype=Object.create(THREE.BufferGeometry.prototype);
THREE.WireframeGeometry.prototype.constructor=THREE.WireframeGeometry;THREE.AxisHelper=function(a){a=a||1;var b=new Float32Array([0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a]),c=new Float32Array([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1]);a=new THREE.BufferGeometry;a.addAttribute("position",new THREE.BufferAttribute(b,3));a.addAttribute("color",new THREE.BufferAttribute(c,3));b=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.LineSegments.call(this,a,b)};THREE.AxisHelper.prototype=Object.create(THREE.LineSegments.prototype);
THREE.AxisHelper.prototype.constructor=THREE.AxisHelper;
THREE.ArrowHelper=function(){var a=new THREE.BufferGeometry;a.addAttribute("position",new THREE.Float32Attribute([0,0,0,0,1,0],3));var b=new THREE.CylinderBufferGeometry(0,.5,1,5,1);b.translate(0,-.5,0);return function(c,d,e,f,g,h){THREE.Object3D.call(this);void 0===f&&(f=16776960);void 0===e&&(e=1);void 0===g&&(g=.2*e);void 0===h&&(h=.2*g);this.position.copy(d);this.line=new THREE.Line(a,new THREE.LineBasicMaterial({color:f}));this.line.matrixAutoUpdate=!1;this.add(this.line);this.cone=new THREE.Mesh(b,
new THREE.MeshBasicMaterial({color:f}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(c);this.setLength(e,g,h)}}();THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.constructor=THREE.ArrowHelper;
THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){.99999<c.y?this.quaternion.set(0,0,0,1):-.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();THREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=.2*a);void 0===c&&(c=.2*b);this.line.scale.set(1,Math.max(0,a-b),1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};
THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.copy(a);this.cone.material.color.copy(a)};THREE.BoxHelper=function(a){var b=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),c=new Float32Array(24),d=new THREE.BufferGeometry;d.setIndex(new THREE.BufferAttribute(b,1));d.addAttribute("position",new THREE.BufferAttribute(c,3));THREE.LineSegments.call(this,d,new THREE.LineBasicMaterial({color:16776960}));void 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.LineSegments.prototype);
THREE.BoxHelper.prototype.constructor=THREE.BoxHelper;
THREE.BoxHelper.prototype.update=function(){var a=new THREE.Box3;return function(b){b instanceof THREE.Box3?a.copy(b):a.setFromObject(b);if(!a.isEmpty()){b=a.min;var c=a.max,d=this.geometry.attributes.position,e=d.array;e[0]=c.x;e[1]=c.y;e[2]=c.z;e[3]=b.x;e[4]=c.y;e[5]=c.z;e[6]=b.x;e[7]=b.y;e[8]=c.z;e[9]=c.x;e[10]=b.y;e[11]=c.z;e[12]=c.x;e[13]=c.y;e[14]=b.z;e[15]=b.x;e[16]=c.y;e[17]=b.z;e[18]=b.x;e[19]=b.y;e[20]=b.z;e[21]=c.x;e[22]=b.y;e[23]=b.z;d.needsUpdate=!0;this.geometry.computeBoundingSphere()}}}();
THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.constructor=THREE.BoundingBoxHelper;THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};
THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b("n1","n2",16755200);b("n2","n4",16755200);b("n4","n3",16755200);b("n3","n1",16755200);b("f1","f2",16755200);b("f2","f4",16755200);b("f4","f3",16755200);b("f3","f1",16755200);b("n1","f1",16755200);
b("n2","f2",16755200);b("n3","f3",16755200);b("n4","f4",16755200);b("p","n1",16711680);b("p","n2",16711680);b("p","n3",16711680);b("p","n4",16711680);b("u1","u2",43775);b("u2","u3",43775);b("u3","u1",43775);b("c","t",16777215);b("p","c",3355443);b("cn1","cn2",3355443);b("cn3","cn4",3355443);b("cf1","cf2",3355443);b("cf3","cf4",3355443);THREE.LineSegments.call(this,d,e);this.camera=a;this.camera.updateProjectionMatrix();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};
THREE.CameraHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.CameraHelper.prototype.constructor=THREE.CameraHelper;
THREE.CameraHelper.prototype.update=function(){function a(a,g,h,k){d.set(g,h,k).unproject(e);a=c[a];if(void 0!==a)for(g=0,h=a.length;g<h;g++)b.vertices[a[g]].copy(d)}var b,c,d=new THREE.Vector3,e=new THREE.Camera;return function(){b=this.geometry;c=this.pointMap;e.projectionMatrix.copy(this.camera.projectionMatrix);a("c",0,0,-1);a("t",0,0,1);a("n1",-1,-1,-1);a("n2",1,-1,-1);a("n3",-1,1,-1);a("n4",1,1,-1);a("f1",-1,-1,1);a("f2",1,-1,1);a("f3",-1,1,1);a("f4",1,1,1);a("u1",.7,1.1,-1);a("u2",-.7,1.1,
-1);a("u3",0,2,-1);a("cf1",-1,0,1);a("cf2",1,0,1);a("cf3",0,-1,1);a("cf4",0,1,1);a("cn1",-1,0,-1);a("cn2",1,0,-1);a("cn3",0,-1,-1);a("cn4",0,1,-1);b.verticesNeedUpdate=!0}}();
THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;void 0===b&&(b=1);var c=new THREE.BufferGeometry;c.addAttribute("position",new THREE.Float32Attribute([-b,b,0,b,b,0,b,-b,0,-b,-b,0,-b,b,0],3));var d=new THREE.LineBasicMaterial({fog:!1});this.add(new THREE.Line(c,d));c=new THREE.BufferGeometry;c.addAttribute("position",new THREE.Float32Attribute([0,0,0,0,0,1],3));this.add(new THREE.Line(c,
d));this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.DirectionalLightHelper.prototype.constructor=THREE.DirectionalLightHelper;THREE.DirectionalLightHelper.prototype.dispose=function(){var a=this.children[0],b=this.children[1];a.geometry.dispose();a.material.dispose();b.geometry.dispose();b.material.dispose()};
THREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);var d=this.children[0],e=this.children[1];d.lookAt(c);d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);e.lookAt(c);e.scale.z=c.length()}}();
THREE.EdgesHelper=function(a,b,c){b=void 0!==b?b:16777215;THREE.LineSegments.call(this,new THREE.EdgesGeometry(a.geometry,c),new THREE.LineBasicMaterial({color:b}));this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1};THREE.EdgesHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.EdgesHelper.prototype.constructor=THREE.EdgesHelper;
THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=0;c=this.object.geometry;c instanceof THREE.Geometry?b=c.faces.length:console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");c=new THREE.BufferGeometry;b=new THREE.Float32Attribute(6*b,3);c.addAttribute("position",b);THREE.LineSegments.call(this,c,new THREE.LineBasicMaterial({color:a,linewidth:d}));this.matrixAutoUpdate=
!1;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.FaceNormalsHelper.prototype.constructor=THREE.FaceNormalsHelper;
THREE.FaceNormalsHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(){this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);for(var d=this.object.matrixWorld,e=this.geometry.attributes.position,f=this.object.geometry,g=f.vertices,f=f.faces,h=0,k=0,l=f.length;k<l;k++){var n=f[k],p=n.normal;a.copy(g[n.a]).add(g[n.b]).add(g[n.c]).divideScalar(3).applyMatrix4(d);b.copy(p).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
e.setXYZ(h,a.x,a.y,a.z);h+=1;e.setXYZ(h,b.x,b.y,b.z);h+=1}e.needsUpdate=!0;return this}}();
THREE.GridHelper=function(a,b,c,d){c=new THREE.Color(void 0!==c?c:4473924);d=new THREE.Color(void 0!==d?d:8947848);for(var e=[],f=[],g=-a,h=0;g<=a;g+=b){e.push(-a,0,g,a,0,g);e.push(g,0,-a,g,0,a);var k=0===g?c:d;k.toArray(f,h);h+=3;k.toArray(f,h);h+=3;k.toArray(f,h);h+=3;k.toArray(f,h);h+=3}a=new THREE.BufferGeometry;a.addAttribute("position",new THREE.Float32Attribute(e,3));a.addAttribute("color",new THREE.Float32Attribute(f,3));e=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.LineSegments.call(this,
a,e)};THREE.GridHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.GridHelper.prototype.constructor=THREE.GridHelper;THREE.GridHelper.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};
THREE.HemisphereLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;this.colors=[new THREE.Color,new THREE.Color];var c=new THREE.SphereGeometry(b,4,2);c.rotateX(-Math.PI/2);for(var d=0;8>d;d++)c.faces[d].color=this.colors[4>d?0:1];d=new THREE.MeshBasicMaterial({vertexColors:THREE.FaceColors,wireframe:!0});this.lightSphere=new THREE.Mesh(c,d);this.add(this.lightSphere);this.update()};
THREE.HemisphereLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.HemisphereLightHelper.prototype.constructor=THREE.HemisphereLightHelper;THREE.HemisphereLightHelper.prototype.dispose=function(){this.lightSphere.geometry.dispose();this.lightSphere.material.dispose()};
THREE.HemisphereLightHelper.prototype.update=function(){var a=new THREE.Vector3;return function(){this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());this.lightSphere.geometry.colorsNeedUpdate=!0}}();
THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereBufferGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.PointLightHelper.prototype.constructor=THREE.PointLightHelper;
THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};THREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};
THREE.SkeletonHelper=function(a){this.bones=this.getBoneList(a);for(var b=new THREE.Geometry,c=0;c<this.bones.length;c++)this.bones[c].parent instanceof THREE.Bone&&(b.vertices.push(new THREE.Vector3),b.vertices.push(new THREE.Vector3),b.colors.push(new THREE.Color(0,0,1)),b.colors.push(new THREE.Color(0,1,0)));b.dynamic=!0;c=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors,depthTest:!1,depthWrite:!1,transparent:!0});THREE.LineSegments.call(this,b,c);this.root=a;this.matrix=a.matrixWorld;
this.matrixAutoUpdate=!1;this.update()};THREE.SkeletonHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.SkeletonHelper.prototype.constructor=THREE.SkeletonHelper;THREE.SkeletonHelper.prototype.getBoneList=function(a){var b=[];a instanceof THREE.Bone&&b.push(a);for(var c=0;c<a.children.length;c++)b.push.apply(b,this.getBoneList(a.children[c]));return b};
THREE.SkeletonHelper.prototype.update=function(){for(var a=this.geometry,b=(new THREE.Matrix4).getInverse(this.root.matrixWorld),c=new THREE.Matrix4,d=0,e=0;e<this.bones.length;e++){var f=this.bones[e];f.parent instanceof THREE.Bone&&(c.multiplyMatrices(b,f.matrixWorld),a.vertices[d].setFromMatrixPosition(c),c.multiplyMatrices(b,f.parent.matrixWorld),a.vertices[d+1].setFromMatrixPosition(c),d+=2)}a.verticesNeedUpdate=!0;a.computeBoundingSphere()};
THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.BufferGeometry;for(var b=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1],c=0,d=1;32>c;c++,d++){var e=c/32*Math.PI*2,f=d/32*Math.PI*2;b.push(Math.cos(e),Math.sin(e),1,Math.cos(f),Math.sin(f),1)}a.addAttribute("position",new THREE.Float32Attribute(b,3));b=new THREE.LineBasicMaterial({fog:!1});this.cone=new THREE.LineSegments(a,
b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.SpotLightHelper.prototype.constructor=THREE.SpotLightHelper;THREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};
THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E3,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();
THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16711680;d=void 0!==d?d:1;b=0;c=this.object.geometry;c instanceof THREE.Geometry?b=3*c.faces.length:c instanceof THREE.BufferGeometry&&(b=c.attributes.normal.count);c=new THREE.BufferGeometry;b=new THREE.Float32Attribute(6*b,3);c.addAttribute("position",b);THREE.LineSegments.call(this,c,new THREE.LineBasicMaterial({color:a,linewidth:d}));this.matrixAutoUpdate=!1;this.update()};
THREE.VertexNormalsHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.VertexNormalsHelper.prototype.constructor=THREE.VertexNormalsHelper;
THREE.VertexNormalsHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(){var d=["a","b","c"];this.object.updateMatrixWorld(!0);c.getNormalMatrix(this.object.matrixWorld);var e=this.object.matrixWorld,f=this.geometry.attributes.position,g=this.object.geometry;if(g instanceof THREE.Geometry)for(var h=g.vertices,k=g.faces,l=g=0,n=k.length;l<n;l++)for(var p=k[l],m=0,q=p.vertexNormals.length;m<q;m++){var r=p.vertexNormals[m];a.copy(h[p[d[m]]]).applyMatrix4(e);
b.copy(r).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);f.setXYZ(g,a.x,a.y,a.z);g+=1;f.setXYZ(g,b.x,b.y,b.z);g+=1}else if(g instanceof THREE.BufferGeometry)for(d=g.attributes.position,h=g.attributes.normal,m=g=0,q=d.count;m<q;m++)a.set(d.getX(m),d.getY(m),d.getZ(m)).applyMatrix4(e),b.set(h.getX(m),h.getY(m),h.getZ(m)),b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a),f.setXYZ(g,a.x,a.y,a.z),g+=1,f.setXYZ(g,b.x,b.y,b.z),g+=1;f.needsUpdate=!0;return this}}();
THREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215;THREE.LineSegments.call(this,new THREE.WireframeGeometry(a.geometry),new THREE.LineBasicMaterial({color:c}));this.matrix=a.matrixWorld;this.matrixAutoUpdate=!1};THREE.WireframeHelper.prototype=Object.create(THREE.LineSegments.prototype);THREE.WireframeHelper.prototype.constructor=THREE.WireframeHelper;THREE.ImmediateRenderObject=function(a){THREE.Object3D.call(this);this.material=a;this.render=function(a){}};
THREE.ImmediateRenderObject.prototype=Object.create(THREE.Object3D.prototype);THREE.ImmediateRenderObject.prototype.constructor=THREE.ImmediateRenderObject;THREE.MorphBlendMesh=function(a,b){THREE.Mesh.call(this,a,b);this.animationsMap={};this.animationsList=[];var c=this.geometry.morphTargets.length;this.createAnimation("__default",0,c-1,c/1);this.setAnimationWeight("__default",1)};THREE.MorphBlendMesh.prototype=Object.create(THREE.Mesh.prototype);THREE.MorphBlendMesh.prototype.constructor=THREE.MorphBlendMesh;
THREE.MorphBlendMesh.prototype.createAnimation=function(a,b,c,d){b={start:b,end:c,length:c-b+1,fps:d,duration:(c-b)/d,lastFrame:0,currentFrame:0,active:!1,time:0,direction:1,weight:1,directionBackwards:!1,mirroredLoop:!1};this.animationsMap[a]=b;this.animationsList.push(b)};
THREE.MorphBlendMesh.prototype.autoCreateAnimations=function(a){for(var b=/([a-z]+)_?(\d+)/i,c,d={},e=this.geometry,f=0,g=e.morphTargets.length;f<g;f++){var h=e.morphTargets[f].name.match(b);if(h&&1<h.length){var k=h[1];d[k]||(d[k]={start:Infinity,end:-Infinity});h=d[k];f<h.start&&(h.start=f);f>h.end&&(h.end=f);c||(c=k)}}for(k in d)h=d[k],this.createAnimation(k,h.start,h.end,a);this.firstAnimation=c};
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward=function(a){if(a=this.animationsMap[a])a.direction=1,a.directionBackwards=!1};THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward=function(a){if(a=this.animationsMap[a])a.direction=-1,a.directionBackwards=!0};THREE.MorphBlendMesh.prototype.setAnimationFPS=function(a,b){var c=this.animationsMap[a];c&&(c.fps=b,c.duration=(c.end-c.start)/c.fps)};
THREE.MorphBlendMesh.prototype.setAnimationDuration=function(a,b){var c=this.animationsMap[a];c&&(c.duration=b,c.fps=(c.end-c.start)/c.duration)};THREE.MorphBlendMesh.prototype.setAnimationWeight=function(a,b){var c=this.animationsMap[a];c&&(c.weight=b)};THREE.MorphBlendMesh.prototype.setAnimationTime=function(a,b){var c=this.animationsMap[a];c&&(c.time=b)};THREE.MorphBlendMesh.prototype.getAnimationTime=function(a){var b=0;if(a=this.animationsMap[a])b=a.time;return b};
THREE.MorphBlendMesh.prototype.getAnimationDuration=function(a){var b=-1;if(a=this.animationsMap[a])b=a.duration;return b};THREE.MorphBlendMesh.prototype.playAnimation=function(a){var b=this.animationsMap[a];b?(b.time=0,b.active=!0):console.warn("THREE.MorphBlendMesh: animation["+a+"] undefined in .playAnimation()")};THREE.MorphBlendMesh.prototype.stopAnimation=function(a){if(a=this.animationsMap[a])a.active=!1};
THREE.MorphBlendMesh.prototype.update=function(a){for(var b=0,c=this.animationsList.length;b<c;b++){var d=this.animationsList[b];if(d.active){var e=d.duration/d.length;d.time+=d.direction*a;if(d.mirroredLoop){if(d.time>d.duration||0>d.time)d.direction*=-1,d.time>d.duration&&(d.time=d.duration,d.directionBackwards=!0),0>d.time&&(d.time=0,d.directionBackwards=!1)}else d.time%=d.duration,0>d.time&&(d.time+=d.duration);var f=d.start+THREE.Math.clamp(Math.floor(d.time/e),0,d.length-1),g=d.weight;f!==d.currentFrame&&
(this.morphTargetInfluences[d.lastFrame]=0,this.morphTargetInfluences[d.currentFrame]=1*g,this.morphTargetInfluences[f]=0,d.lastFrame=d.currentFrame,d.currentFrame=f);e=d.time%e/e;d.directionBackwards&&(e=1-e);d.currentFrame!==d.lastFrame?(this.morphTargetInfluences[d.currentFrame]=e*g,this.morphTargetInfluences[d.lastFrame]=(1-e)*g):this.morphTargetInfluences[d.currentFrame]=g}}};
var FluxViewport = (function (THREE) {
        'use strict';

        THREE = 'default' in THREE ? THREE['default'] : THREE;

        var __commonjs_global = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this;
        function __commonjs(fn, module) { return module = { exports: {} }, fn(module, module.exports, __commonjs_global), module.exports; }

        /**
         * Whether to draw edges on front and back faces.
         * Values are NONE, FRONT, BACK, BOTH.
         */
        EdgesHelper.EDGES_MODES = {
            NONE: 0,
            FRONT: 1,
            BACK: 2,
            BOTH: 3
        };

        /**
         * Create an object to render the edges of a mesh
         * @private
         * @param  {Three.Mesh} mesh            The mesh to convert
         * @param  {Three.Material} material    The material on the mesh
         * @return {Three.EdgesHelper}          The edges object
         */
        var _createEdges = function(mesh, material) {
            var helper = new THREE.EdgesHelper(mesh);
            helper.material = material;
            helper.matrixAutoUpdate = false;
            helper.matrix = mesh.matrix;
            return helper;
        };

        /**
         * Create an object to render a mesh as edges
         * @class EdgesHelper
         * @param {Three.Object3D} model The mesh
         */
        function EdgesHelper(model) {
            THREE.Object3D.call( this );
            this.type = 'EdgesHelper';

            this.frontMaterial = new THREE.LineBasicMaterial({color: 0x000000});
            this.frontMaterial.depthFunc = THREE.LessEqualDepth;

            this.backMaterial = new THREE.LineBasicMaterial({color: 0x000000});
            this.backMaterial.transparent = true;
            this.backMaterial.depthFunc = THREE.GreaterDepth;
            this.backMaterial.opacity = 0.25;

            var _this = this;
            model.traverse(function(child) {
                if (child instanceof THREE.Mesh) {
                    // create edge helper for front and back edges
                    _this.add(
                        _createEdges(child, _this.frontMaterial)
                    );
                    _this.add(
                        _createEdges(child, _this.backMaterial)
                    );
                }
            });
        }

        EdgesHelper.prototype = Object.create( THREE.Object3D.prototype );
        EdgesHelper.prototype.constructor = EdgesHelper;

        /**
         * Create the edges geometry for a model
         * @param {THREE.Object3D} newModel The model with edges
         * @param {EdgesHelper.EDGES_MODES} edgesMode Whether to draw edges enumeration
         * @return {EdgesHelper} The edges object
         */
        EdgesHelper.AddEdges = function(newModel, edgesMode) {
            if (edgesMode === EdgesHelper.EDGES_MODES.NONE) return null;

            newModel.edgesHelper = new EdgesHelper(newModel);

            newModel.edgesHelper.frontMaterial.visible = false;
            if (edgesMode === EdgesHelper.EDGES_MODES.FRONT || edgesMode === EdgesHelper.EDGES_MODES.BOTH) {
                newModel.edgesHelper.frontMaterial.visible = true;
            }

            newModel.edgesHelper.backMaterial.visible = false;
            if (edgesMode === EdgesHelper.EDGES_MODES.BACK || edgesMode === EdgesHelper.EDGES_MODES.BOTH) {
                newModel.edgesHelper.backMaterial.visible = true;
            }
            return newModel.edgesHelper;
        };

        /**
         * Class for managing multiple cameras used in a viewport.
         * @class  FluxCameras
         * @param {Number} width  Width of the viewport
         * @param {Number} height Height of the viewport
         */
        function FluxCameras(width, height) {
            // Initialize default cameras and frustums.
            this._perspCamera = new THREE.PerspectiveCamera(30, width/height, 0.1, 100000);
            // Flux is Z up
            this._perspCamera.up = new THREE.Vector3( 0, 0, 1 );

            this._orthoCamera = new THREE.OrthographicCamera(100, -100, 100, -100, -1000, 1000);

            this.setView(FluxCameras.VIEWS.perspective);
            this.updateCamera(width, height);
        }

        /**
         * Enumeration of all possible views for the camera.
         * Values are perspective, top, bottom, front, back, right, left.
         * @type {Object}
         */
        FluxCameras.VIEWS = {
            perspective:  0,
            top:    1,
            bottom: 2,
            front:  3,
            back:   4,
            right:  5,
            left:   6,
            END:   7
        };

        /**
         * Get the current camera object
         * @return {THREE.Camera} The current camera
         */
        FluxCameras.prototype.getCamera = function () {
            if (this._view === FluxCameras.VIEWS.perspective) {
                return this._perspCamera;
            }
            return this._orthoCamera;
        };

        FluxCameras.DEFAULT_POSITIONS = [
            [2500000, 1000000, 1300000], // perspective
            [0, 0, -100], // top
            [0, 0, 100], // bottom
            [0, 0, 0], // front
            [0, 0, 0], // back
            [0, 0, 0], // right
            [0, 0, 0] // left
        ];

        FluxCameras.DEFAULT_ROTATIONS = [
            [0, 0, 0], // perspective
            [0, 0, 0], // top
            [0, Math.PI, 0], // bottom
            [Math.PI/2, 0, 0], // front
            [Math.PI/2, Math.PI, 0], // back
            [Math.PI/2, Math.PI/2, 0], // right
            [Math.PI/2, -Math.PI/2, 0] // left
        ];

        FluxCameras.isValidView = function (view) {
            return view != null && view.constructor === Number && view > -1 && view < FluxCameras.VIEWS.END;
        };

        /**
         * Set the camera to the default coordinates for the given view.
         * @param {FluxCameras.VIEWS} view The new view
         */
        FluxCameras.prototype.setView = function (view) {
            if (!FluxCameras.isValidView(view)) return;
            this._view = view;

            var camera = this.getCamera();
            camera.position.set(FluxCameras.DEFAULT_POSITIONS[view][0],
                                FluxCameras.DEFAULT_POSITIONS[view][1],
                                FluxCameras.DEFAULT_POSITIONS[view][2]);

            camera.rotation.set(FluxCameras.DEFAULT_ROTATIONS[view][0],
                                FluxCameras.DEFAULT_ROTATIONS[view][1],
                                FluxCameras.DEFAULT_ROTATIONS[view][2]);
        };

        /**
         * Recompute derived state when the camera is changed.
         * @param  {Number} width  Width of the viewport (used to calculate aspect ratio)
         * @param  {Number} height Height of the viewport (used to calculate aspect ratio)
         */
        FluxCameras.prototype.updateCamera = function(width, height) {
            this._perspCamera.aspect = width / height;
            this._perspCamera.updateProjectionMatrix();

            var a = width / height;
            var h = this._orthoCamera.top - this._orthoCamera.bottom;
            this._orthoCamera.top = h / 2;
            this._orthoCamera.bottom = - h / 2;
            this._orthoCamera.right = h / 2 * a;
            this._orthoCamera.left = - h / 2 * a;
            this._orthoCamera.updateProjectionMatrix();
        };

        /**
         * Extract only relevant properties from a camera
         * @param  {THREE.Camera} camera The camera source
         * @return {Object}        The camera data
         */
        FluxCameras.cameraToJSON = function(camera) {
            var serializableCamera = {
                px: camera.position.x,
                py: camera.position.y,
                pz: camera.position.z,
                rx: camera.rotation.x,
                ry: camera.rotation.y,
                rz: camera.rotation.z,
                near: camera.near,
                far: camera.far
            };
            // Handle extra OrthographicCamera properties
            if (camera instanceof THREE.OrthographicCamera) {
                serializableCamera.top = camera.top;
                serializableCamera.right = camera.right;
                serializableCamera.bottom = camera.bottom;
                serializableCamera.left = camera.left;
                serializableCamera.type = 'orthographic';
            } else {
                serializableCamera.type = 'perspective';
            }
            return serializableCamera;
        };

        /**
         * Check if something is anumber
         * @param {Number} num The value
         * @returns {boolean} True for numbers
         * @private
         */
        function _isNumber(num) {
            return num != null && num.constructor === Number;
        }

        /**
         * Check whether a set of properties are valid numbers
         * @param {Array.<string>} schema The list of properties
         * @param {Object} data The object with properties
         * @returns {boolean} True if all numbers
         * @private
         */
        function _checkNumbers(schema, data) {
            // Make sure all the properties are valid and exist
            for (var i=0;i<schema.length;i++) {
                if (!_isNumber(data[schema[i]])) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Rehydrate camera instance from an object property tree.
         * @param  {THREE.camera} camera The camera to receive data
         * @param  {Object} data   The data to parse and apply
         */
        FluxCameras.cameraFromJSON = function(camera, data) {
            var schema = ['px', 'py', 'pz', 'rx', 'ry', 'rz', 'near', 'far'];
            if (!_checkNumbers(schema, data)) return;
            camera.position.x = data.px;
            camera.position.y = data.py;
            camera.position.z = data.pz;
            camera.rotation.x = data.rx;
            camera.rotation.y = data.ry;
            camera.rotation.z = data.rz;
            camera.near = data.near;
            camera.far = data.far;

            // Handle extra OrthographicCamera properties
            if (camera.constructor === THREE.OrthographicCamera) {
                schema = ['top', 'right', 'bottom', 'left'];
                if (!_checkNumbers(schema, data)) return;
                camera.top = data.top;
                camera.right = data.right;
                camera.bottom = data.bottom;
                camera.left = data.left;
            }
        };

        /**
         * Make serializable by pruning all references and building an object property tree
         * @return {Object} The simplified model
         */
        FluxCameras.prototype.toJSON = function() {
            var serializableCameras = {
                perspective: FluxCameras.cameraToJSON(this._perspCamera),
                orthographic: FluxCameras.cameraToJSON(this._orthoCamera),
                view: this._view
            };
            return serializableCameras;
        };

        /**
        * Update the corresponding cameras in this object from a serialized object.
        * @param  {Object} serializableCameras The camera data to use.
        */
        FluxCameras.prototype.fromJSON = function(serializableCameras) {
            this.setView(serializableCameras.view);
            FluxCameras.cameraFromJSON(this._perspCamera, serializableCameras.perspective);
            FluxCameras.cameraFromJSON(this._orthoCamera, serializableCameras.orthographic);
        };

        // TODO(aki): allow longer labels. Only one letter currently supported

        function LabelHelper ( label, size, color ) {
            if (!color) {
                color = new THREE.Color( 0xff0000 );
            }
            var canvas, geometry, ctx, texture, material;

            geometry = new THREE.Geometry();
            geometry.vertices.push( new THREE.Vector3() );

            canvas = document.createElement( 'canvas' );
            canvas.width = size;
            canvas.height = size;

            ctx = canvas.getContext( '2d' );
            if (ctx) {
                ctx.font = size + 'px sans-serif';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText( label, size / 2, size / 2 );
            }

            texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.premultiplyAlpha = true;
            texture.generateMipmaps = false;
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            if (canvas.width) {
                material = new THREE.PointsMaterial(
                    { size: size, sizeAttenuation: false, map: texture, transparent: true, color: color } );
            }
            else {
                material = new THREE.PointsMaterial( { transparent: true, color: color } );
            }
            material.blendSrc = THREE.OneFactor;
            material.blending = THREE.CustomBlending;

            THREE.Points.call( this, geometry, material );
        }

        LabelHelper.prototype = Object.create( THREE.Points.prototype );
        LabelHelper.prototype.constructor = LabelHelper;

        function AxisHelper ( size, labelSize ) {

            THREE.Object3D.call( this );

            size = size || 1;
            labelSize = labelSize || 16;

            var vertices = new Float32Array( [
                0, 0, 0,  size, 0, 0,
                0, 0, 0,  0, size, 0,
                0, 0, 0,  0, 0, size
            ] );

            var colors = new Float32Array( [
                1, 0, 0,  1, 0, 0,
                0, 1, 0,  0, 1, 0,
                0, 0, 1,  0, 0, 1
            ] );

            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
            geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

            var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

            var axes = new THREE.LineSegments( geometry, material );
            this.add( axes );

            var red = new THREE.Color( 0xff0000 );
            var labelX = new LabelHelper( 'x', labelSize, red );
            labelX.position.set( size, 0, 0 );
            axes.add( labelX );

            var green = new THREE.Color( 0x00ff00 );
            var labelY = new LabelHelper( 'y', labelSize, green);
            labelY.position.set( 0, size, 0 );
            axes.add( labelY );

            var blue = new THREE.Color( 0x0000ff );
            var labelZ = new LabelHelper( 'z', labelSize, blue );
            labelZ.position.set( 0, 0, size );
            axes.add( labelZ );

        }

        AxisHelper.prototype = Object.create( THREE.Object3D.prototype );
        AxisHelper.prototype.constructor = AxisHelper;

        /**
         * Manages reference objects that render in the scene.
         * Geometry in this object has depth write disabled since it is meant to be
         * layered onto the scene as a second pass. This allows the text on the labels
         * to render correctly and prevents flickering from z-fighting between the grid
         * and the axis lines.
         */
        function FluxHelpers() {
            THREE.Object3D.call( this );
            this.type = 'FluxHelpers';

            this._grid = this._setupGrid(10, 10, 0x111111, 0xaaaaaa);
            this.setView(FluxCameras.VIEWS.perspective);
            this.add(this._grid);

            this._axis = this._setupAxis();
            this.add(this._axis);
        }

        FluxHelpers.prototype = Object.create( THREE.Object3D.prototype );
        FluxHelpers.prototype.constructor = FluxHelpers;

        /**
         * Create a grid of lines to give the user a sense of scale.
         * This is also referred to as a construction plane.
         * @param  {Number} size   Size of grid spacing
         * @param  {Number} width  Width of grid spacing
         * @param  {Number|String} color1 Color specification for primary grid color
         * @param  {Number|String} color2 Color specification for secondary grid color
         * @return {Object3D}        The grid object
         */
        FluxHelpers.prototype._setupGrid = function(size, width, color1, color2) {
            var grid = new THREE.GridHelper(size * width, size, new THREE.Color(color1), new THREE.Color(color2));
            grid.material.transparent = true;
            grid.material.opacity = 0.5;
            grid.material.depthWrite = false;
            return grid;
        };

        /**
         * Setup the coordinate axis with xyz labels
         * @return {THREE.Object3D} The axis object
         */
        FluxHelpers.prototype._setupAxis = function() {
            var axis = new AxisHelper(10);
            axis.traverse(function(child) {
                if (child.material ) {
                    child.material.depthWrite = false;
                }
            });
            return axis;
        };

        /**
         * Adjust the orientation of the grid to match the camera.
         * This keeps it aligned to screen space.
         * @param {FluxCameras.VIEWS} view Which view to orient to
         */
        FluxHelpers.prototype.setView = function(view) {
          switch (view) {
            case FluxCameras.VIEWS.perspective:
            case FluxCameras.VIEWS.top:
            case FluxCameras.VIEWS.bottom:
                // facing Z
                this._grid.rotation.set(Math.PI / 2, 0, 0);
                break;
            case FluxCameras.VIEWS.right:
            case FluxCameras.VIEWS.left:
                // facing X
                this._grid.rotation.set(0, 0, Math.PI / 2);
                break;
            case FluxCameras.VIEWS.front:
            case FluxCameras.VIEWS.back:
                // facing Y
                this._grid.rotation.set(0, 0, 0);
                break;
          }
        };

        /**
        * Class to represent a WebGL context which can render for multiple viewports
        * @class  FluxRenderContext
        */
        function FluxRenderContext () {
            /**
            * Pointer to the shared THREE.js renderer
            */
            try {
                this._hasWebGL = true;
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    preserveDrawingBuffer: true,
                    alpha: false
                });
                this.renderer.autoClear = false;
                this.renderer.autoClearStencil = false;
                this.renderer.gammaInput = false;
                this.renderer.gammaOutput = false;
                // Allow interactive canvas to overlap other canvas
                this.renderer.domElement.style.position = "absolute";
            } catch (err) {
                // Replace renderer with mock renderer for tests
                this.renderer = {
                    render: function () {},
                    setSize: function () {},
                    clear: function () {},
                    setViewport: function () {},
                    setClearColor: function () {},
                    getSize: function () { return {width: 100, height: 100}; },
                    getPixelRatio: function () { return 1; },
                    domElement: document.createElement('div')
                };
                this._hasWebGL = false;
            }
            // Pointer to the three-viewport-renderer instance that is currently being rendered.
            this.currentHost = null;
        }

        /**
        * Maximum number of WebGL contexts allowed.
        * Should be less than or equal to 16, the limit on recent systems.
        */
        FluxRenderContext.MAX_CONTEXTS = 16;

        // List of all render contexts shared globally
        FluxRenderContext.contexts = [];

        // Counter so new viewports know which context to create or reuse.
        FluxRenderContext.nextContext = 0;

        /**
        * Each viewport uses the next available render context defined by this function
        * @return {FluxRenderContext} The context instance
        */
        FluxRenderContext.getNextContext = function () {
            var i = FluxRenderContext.nextContext;
            FluxRenderContext.nextContext += 1;
            FluxRenderContext.nextContext = FluxRenderContext.nextContext % FluxRenderContext.MAX_CONTEXTS;
            return FluxRenderContext.contexts[i];
        };

        FluxRenderContext.getNewContext = function () {
            var context;
            if (FluxRenderContext.contexts.length >= FluxRenderContext.MAX_CONTEXTS) {
                context = FluxRenderContext.getNextContext();
            } else {
                context = new FluxRenderContext();
                FluxRenderContext.contexts.push(context);
            }
            return context;
        };

        FluxRenderContext.prototype.hasWebGL = function() {
            return this._hasWebGL;
        };

        function EditorControls( object, domElement, center ) {

        	domElement = ( domElement !== undefined ) ? domElement : document;

        	// API

        	this.enabled = true;
        	this.center = center = center || new THREE.Vector3();

        	// internals

        	var scope = this;
        	var vector = new THREE.Vector3();
        	var matrix = new THREE.Matrix3();

        	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2 };
        	var state = STATE.NONE;
        	var parentRect = null;

        	// pointer data

        	var touches = [];

        	// pointers are expressed in -1 to 1 coordinate space relative to domElement.

        	var pointers = [ new THREE.Vector2(), new THREE.Vector2() ];
        	var pointersOld = [ new THREE.Vector2(), new THREE.Vector2() ];
        	var pointersDelta = [ new THREE.Vector2(), new THREE.Vector2() ];

        	// events

        	var changeEvent = { type: 'change' };

        	var ORTHO_FRUSTUM_WIDTH = 1e6;
        	var PERSP_FRUSTUM_WIDTH = 1e3;
        	var ZOOM_MAX_EXTENTS = 1e18;
        	var MIN_FOCUS_SIZE = 1e-3;
        	var EPS = 1e-6;
        	var CAMERA_PADDING = 1.2;

        	// hepler functions

        	var getClosestPoint = function( point, pointArray ) {

        		if ( pointArray[ 0 ].distanceTo( point) < pointArray[ 1 ].distanceTo( point) ) {

        			return pointArray[ 0 ];

        		}

        		return pointArray[ 1 ];

        	};

        	var setPointers = function( event ) {

        		// Set pointes from mouse/touch events and convert to -1 to 1 coordinate space.
        		if (!parentRect || event.type === 'mousedown') {
        			// Cache the parent rect at the beginning of a drag event sequence
        			parentRect = event.target.getBoundingClientRect();
        		}
        		// Filter touches that originate from the same element as the event.

        		touches.length = 0;

        		if ( event.touches ) {
        			for ( var i = 0; i < event.touches.length; i++ ) {
        				if ( event.touches[ i ].target === event.target ) {
        					touches.push( event.touches[ i ] );
        				}
        			}
        		}

        		// Set pointer[0] from mouse event.clientX/Y

        		if ( touches.length === 0 ) {
        			// Compute the position on the page with a relative scale from the element
        			pointers[ 0 ].set(
        				( event.pageX - parentRect.left ) / parentRect.width * 2 - 1,
        				( event.pageY - parentRect.top ) / parentRect.height * 2 - 1
        			);

        		// Set both pointer[0] and pointer[1] from a single touch.

        		} else if ( touches.length == 1 ) {

        			pointers[ 0 ].set(
        				( touches[ 0 ].pageX - parentRect.left ) / parentRect.width * 2 - 1,
        				( touches[ 0 ].pageY - parentRect.top ) / parentRect.height * 2 - 1
        			);
        			pointers[ 1 ].copy( pointers[ 0 ] );

        		// Set pointer[0] and pointer[1] from two touches.

        		} else if ( touches.length == 2 ) {

        			pointers[ 0 ].set(
        				( touches[ 0 ].pageX - parentRect.left ) / parentRect.width * 2 - 1,
        				( touches[ 0 ].pageY - parentRect.top ) / parentRect.height * 2 - 1
        			);
        			pointers[ 1 ].set(
        				( touches[ 1 ].pageX - parentRect.left ) / parentRect.width * 2 - 1,
        				( touches[ 1 ].pageY - parentRect.top) / parentRect.height * 2 - 1
        			);

        		}

        		// Clear the cached bounds at the end of a drag event sequence
        		if (parentRect && event.type === 'mouseup') {
        			parentRect = null;
        		}
        	};

        	/**
        	 * Update camera clipping planes based on size of scene
        	 * @param  {THREE.camera} camera Perspective camera object
        	 * @param  {Number} radius Size of the scene
        	 */
        	this.updateClippingPersp = function updateClippingPersp (camera, radius) {
        		var factor = PERSP_FRUSTUM_WIDTH;
        		camera.near = radius / factor;
        		camera.far = radius * factor + factor;
        	};

        	/**
        	 * Update camera clipping planes based on size of scene
        	 * @param  {THREE.camera} camera Orthographic camera object
        	 * @param  {Number} radius Size of the scene
        	 */
        	this.updateClippingOrtho = function updateClippingOrtho (camera, radius) {
        		var nearFarDistance = ORTHO_FRUSTUM_WIDTH;
        		var factor = Math.max(2*radius,nearFarDistance);
        		camera.near = -1 * factor;
        		camera.far = factor;
        	};


        	this.focus = function focus ( target, frame ) {
        		// Collection of all centers and radii in the hierarchy of the target.

        		var targets = [];

        		// Bounding box (minCenter/maxCenter) encompassing all centers in hierarchy.

        		var minCenter;
        		var maxCenter;

        		target.traverse( function( child ) {

        			if (child.visible) {

        				child.updateMatrixWorld( true );

        				var center = new THREE.Vector3();
        				var scale = new THREE.Vector3();
        				var radius = 0;

        				child.matrixWorld.decompose( center, new THREE.Quaternion(), scale );
        				scale = ( scale.x + scale.y + scale.z ) / 3;

        				//TODO: make work with non-uniform scale

        				if ( child.geometry ) {

        					child.geometry.computeBoundingSphere();
        					center.copy( child.geometry.boundingSphere.center.clone()
        								.applyMatrix4(child.matrixWorld) );
        					radius = child.geometry.boundingSphere.radius * scale;

        				}

        				if ( !frame || child.geometry ) {

        					targets.push( { center: center, radius: radius } );

        					if ( !minCenter ) minCenter = center.clone();
        					if ( !maxCenter ) maxCenter = center.clone();

        					minCenter.min( center );
        					maxCenter.max( center );

        				}


        			}


        		} );

        		// Bail if there is not visible geometry
        		if (!minCenter || !maxCenter) return;

        		// Center of the bounding box.

        		var cumulativeCenter = minCenter.clone().add( maxCenter ).multiplyScalar( 0.5 );

        		// Furthest ( center distance + radius ) from CumulativeCenter.

        		var cumulativeRadius = 0;

        		targets.forEach( function( child ) {

        			var radius = cumulativeCenter.distanceTo( child.center ) + child.radius;
        			cumulativeRadius = Math.max( cumulativeRadius, radius );

        		} );

        		// When the radius is nearly zero fall back to a reasonable view size
        		// This works well for single points which have a minimum pixel size
        		// so they will still be visible, even though they are very small relative to the focus size
        		if (cumulativeRadius < EPS) {
        			cumulativeRadius = MIN_FOCUS_SIZE;
        		}

        		if ( object instanceof THREE.PerspectiveCamera ) {

        			// Look towards cumulativeCenter

        			center.copy( cumulativeCenter );
        			object.lookAt( center );

        			if ( frame && cumulativeRadius ) {

        				// Adjust distance to frame cumulativeRadius

        				var fovFactor = Math.tan( ( object.fov / 2 ) * Math.PI / 180.0 );
        				var pos = object.position.clone().sub( center ).normalize().multiplyScalar( CAMERA_PADDING * cumulativeRadius  / fovFactor );

        				object.position.copy( center ).add( pos );
        				this.updateClippingPersp(object, cumulativeRadius);
        			}

        		} else if ( object instanceof THREE.OrthographicCamera ) {

        			// Align camera center with cumulativeCenter
        			center.copy( cumulativeCenter );
        			object.position.copy( center );

        			if ( frame && cumulativeRadius ) {
        				// Offset camera by radius along camera axis so it's outside the object
        				// If camera is too close to geometry, point distance attenuation looks bad
        				var z = new THREE.Vector3(0,0,1);
        				z.applyQuaternion(object.quaternion);
        				z.multiplyScalar(2*cumulativeRadius+1);
        				object.position.sub(z);

        				// Adjust camera boundaries to frame cumulativeRadius

        				var cw = object.right - object.left;
        				var ch = object.top - object.bottom;
        				var aspect = Math.abs(cw / ch);
        				var radius = CAMERA_PADDING * cumulativeRadius;
        				if ( aspect < 1 ) {

        					object.top = Math.sign(object.top) * radius / aspect;
        					object.right = Math.sign(object.right) * radius;
        					object.bottom = Math.sign(object.bottom) * radius / aspect;
        					object.left = Math.sign(object.left) * radius;

        				} else {

        					object.top = Math.sign(object.top) * radius;
        					object.right = Math.sign(object.right) * radius * aspect;
        					object.bottom = Math.sign(object.bottom) * radius;
        					object.left = Math.sign(object.left) * radius * aspect;

        				}
        				this.updateClippingOrtho(object, cumulativeRadius);

        			}

        		}

        		scope.dispatchEvent( changeEvent );

        	};

        	this.pan = function ( delta ) {

        		var distance = object.position.distanceTo( center );

        		vector.set( -delta.x, delta.y, 0 );

        		if ( object instanceof THREE.PerspectiveCamera ) {

        			var fovFactor = distance * Math.tan( ( object.fov / 2 ) * Math.PI / 180.0 );
        			vector.multiplyScalar( fovFactor );
        			vector.x *= object.aspect;

        		} else if ( object instanceof THREE.OrthographicCamera ) {

        			vector.x *= ( object.right - object.left ) / 2;
        			vector.y *= ( object.top - object.bottom ) / 2;

        		}

        		vector.applyMatrix3( matrix.getNormalMatrix( object.matrix ) );
        		object.position.add( vector );
        		center.add( vector );

        		scope.dispatchEvent( changeEvent );

        	};

        	this.zoom = function ( delta ) {

        		if ( object instanceof THREE.PerspectiveCamera ) {

        			var distance = object.position.distanceTo( center );

        			vector.set( 0, 0, delta.y );

        			vector.multiplyScalar( distance );

        			vector.applyMatrix3( matrix.getNormalMatrix( object.matrix ) );

        			// Clamp the length to not be too big
        			vector.setLength(Math.min(vector.length(), distance*0.5));

        			var newDistance = object.position.clone().add(vector).distanceTo( center );
        			// check if we should be moving closer but are going to pass the target or
        			// we are moving farther, but way too far away
        			if ( (delta.y < 0 && newDistance >= distance) || (delta.y > 0 && newDistance > ZOOM_MAX_EXTENTS)) {
        				return;
        			}
        			object.position.add( vector );
        			this.updateClippingPersp(object, newDistance);

        		} else if ( object instanceof THREE.OrthographicCamera ) {
        			// Prevent crazy fast zoom, and never scale by a negative number!
        			var dy = Math.min(2,Math.max(0.5,1+delta.y));
        			object.top *= dy;
        			object.right *= dy;
        			object.bottom *= dy;
        			object.left *= dy;

        		}

        		scope.dispatchEvent( changeEvent );

        	};

        	this.rotate = function ( delta ) {

        		vector.copy( object.position ).sub( center );

        		var theta = Math.atan2( vector.x, vector.y );
        		var phi = Math.atan2( Math.sqrt( vector.x * vector.x + vector.y * vector.y ), vector.z );

        		theta += delta.x;
        		phi -= delta.y;

        		phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );

        		var radius = vector.length();

        		vector.x = radius * Math.sin( phi ) * Math.sin( theta );
        		vector.y = radius * Math.sin( phi ) * Math.cos( theta );
        		vector.z = radius * Math.cos( phi );

        		object.position.copy( center ).add( vector );

        		object.lookAt( center );

        		scope.dispatchEvent( changeEvent );

        	};

        	// export center so it can be restored later
        	this.toJSON = function () {
        		return {
        			cx: center.x,
        			cy: center.y,
        			cz: center.z
        		};
        	};

        	// restore the center point from previous data
        	this.fromJSON = function (data) {
        		this.center.x = data.cx;
        		this.center.y = data.cy;
        		this.center.z = data.cz;
        	};

        	// mouse

        	function onMouseDown( event ) {

        		if ( scope.enabled === false ) return;

        		if ( event.button === 0 ) {

        			state = STATE.ROTATE;

        			if ( object instanceof THREE.OrthographicCamera ) {

        				state = STATE.PAN;

        			}

        		} else if ( event.button === 1 ) {

        			state = STATE.ZOOM;

        		} else if ( event.button === 2 ) {

        			state = STATE.PAN;

        		}

        		setPointers( event );

        		pointersOld[ 0 ].copy( pointers[ 0 ] );

        		// Camera navigation continues while the user drags anywhere on the page
        		document.addEventListener( 'mousemove', onMouseMove, false );
        		document.addEventListener( 'mouseup', onMouseUp, false );
        		document.addEventListener( 'dblclick', onMouseUp, false );

        	}

        	function onMouseMove( event ) {

        		if ( scope.enabled === false ) return;

        		setPointers( event );

        		pointersDelta[ 0 ].subVectors( pointers[ 0 ], pointersOld[ 0 ] );
        		pointersOld[ 0 ].copy( pointers[ 0 ] );

        		if ( state === STATE.ROTATE ) {

        			scope.rotate( pointersDelta[ 0 ] );

        		} else if ( state === STATE.ZOOM ) {

        			scope.zoom( pointersDelta[ 0 ] );

        		} else if ( state === STATE.PAN ) {

        			scope.pan( pointersDelta[ 0 ] );

        		}

        	}

        	function onMouseUp( ) {
        		// Make sure to catch the end of the drag even outside the viewport
        		document.removeEventListener( 'mousemove', onMouseMove, false );
        		document.removeEventListener( 'mouseup', onMouseUp, false );
        		document.removeEventListener( 'dblclick', onMouseUp, false );

        		state = STATE.NONE;

        	}

        	function onMouseWheel( event ) {

        		if ( scope.enabled === false ) return;

        		event.preventDefault();

        		var delta = 0;

        		if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

        			delta = - event.wheelDelta;

        		} else if ( event.detail ) { // Firefox

        			delta = event.detail * 10;

        		}

        		scope.zoom( new THREE.Vector2( 0, delta / 1000 ) );

        	}

        	// Camera navigation begins when the user clicks inside the dom element
        	domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
        	domElement.addEventListener( 'mousedown', onMouseDown, false );
        	domElement.addEventListener( 'mousewheel', onMouseWheel, false );
        	domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); // firefox

        	function touchStart( event ) {

        		event.preventDefault();

        		if ( scope.enabled === false ) return;

        		setPointers( event );

        		pointersOld[ 0 ].copy( pointers[ 0 ] );
        		pointersOld[ 1 ].copy( pointers[ 1 ] );

        	}


        	function touchMove( event ) {

        		event.preventDefault();

        		if ( scope.enabled === false ) return;

        		setPointers( event );

        		switch ( touches.length ) {

        			case 1:
        				pointersDelta[ 0 ].subVectors( pointers[ 0 ], getClosestPoint( pointers[ 0 ], pointersOld ) );
        				pointersDelta[ 1 ].subVectors( pointers[ 1 ], getClosestPoint( pointers[ 1 ], pointersOld ) );

        				if ( object instanceof THREE.PerspectiveCamera ) {

        					scope.rotate( pointersDelta[ 0 ] );

        				} else if ( object instanceof THREE.OrthographicCamera ) {

        					scope.pan( pointersDelta[ 0 ] );

        				}
        				break;

        			case 2:
        				pointersDelta[ 0 ].subVectors( pointers[ 0 ], getClosestPoint( pointers[ 0 ], pointersOld ) );
        				pointersDelta[ 1 ].subVectors( pointers[ 1 ], getClosestPoint( pointers[ 1 ], pointersOld ) );

        				var prevDistance = pointersOld[ 0 ].distanceTo( pointersOld[ 1 ] );
        				var distance = pointers[ 0 ].distanceTo( pointers[ 1 ] );

        				if ( prevDistance ) {

        					scope.zoom( new THREE.Vector2(0, prevDistance - distance ) );
        					scope.pan( pointersDelta[ 0 ].clone().add( pointersDelta[ 1 ] ).multiplyScalar(0.5) );

        				}
        				break;
        		}

        		pointersOld[ 0 ].copy( pointers[ 0 ] );
        		pointersOld[ 1 ].copy( pointers[ 1 ] );

        	}

        	function touchEnd( event ) {
        		event.preventDefault();
        	}

        	domElement.addEventListener( 'touchstart', touchStart, false );
        	domElement.addEventListener( 'touchmove', touchMove, false );
        	domElement.addEventListener( 'touchend', touchEnd, false );

        }

        EditorControls.prototype = Object.create( THREE.EventDispatcher.prototype );
        EditorControls.prototype.constructor = EditorControls;

        function ClearMaskPass () {

            this.enabled = true;

        }

        ClearMaskPass.prototype = {

            render: function ( renderer ) {

                var context = renderer.context;

                context.disable( context.STENCIL_TEST );

            }

        };

        function ClearStencilPass () {

            this.enabled = true;

        }

        ClearStencilPass.prototype = {

            render: function ( renderer ) {

                var context = renderer.context;

                context.disable( context.STENCIL_TEST );
                renderer.clear(false, false, true);

            }

        };

        function MaskPass ( scene, camera ) {

        	this.scene = scene;
        	this.camera = camera;

        	this.enabled = true;
        	this.clear = true;
        	this.needsSwap = false;

        	this.inverse = false;

        }

        MaskPass.prototype = {

        	render: function ( renderer, writeBuffer, readBuffer ) {

        		var context = renderer.context;

        		// don't update color or depth

        		context.colorMask( false, false, false, false );
        		context.depthMask( false );

        		// set up stencil

        		var writeValue, clearValue;

        		if ( this.inverse ) {

        			writeValue = 0;
        			clearValue = 1;

        		} else {

        			writeValue = 1;
        			clearValue = 0;

        		}

        		context.enable( context.STENCIL_TEST );
        		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
        		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
        		context.clearStencil( clearValue );

        		// draw into the stencil buffer

        		renderer.render( this.scene, this.camera, readBuffer, this.clear );
        		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

        		// re-enable update of color and depth

        		context.colorMask( true, true, true, true );
        		context.depthMask( true );

        		// only render where stencil is set to 1

        		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
        		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

        	}

        };

        function RenderPass ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

        	this.scene = scene;
        	this.camera = camera;

        	this.overrideMaterial = overrideMaterial;

        	this.clearColor = clearColor;
        	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

        	this.oldClearColor = new THREE.Color();
        	this.oldClearAlpha = 1;

        	this.enabled = true;
        	this.clear = true;
        	this.needsSwap = false;
        	this.writeDepth = true;

        }

        RenderPass.prototype = {

        	render: function ( renderer, writeBuffer, readBuffer ) {

        		// enable or disable depth writing based on writeDepth
        		if (!this.writeDepth) {
        			renderer.context.depthMask( false );
        			renderer.context.disable(renderer.context.DEPTH_TEST);
        		} else {
        			renderer.context.depthMask( true );
        			renderer.context.enable(renderer.context.DEPTH_TEST);
        		}

        		this.scene.overrideMaterial = this.overrideMaterial;

        		if ( this.clearColor ) {

        			this.oldClearColor.copy( renderer.getClearColor() );
        			this.oldClearAlpha = renderer.getClearAlpha();

        			renderer.setClearColor( this.clearColor, this.clearAlpha );

        		}

        		renderer.render( this.scene, this.camera, readBuffer, this.clear );

        		if ( this.clearColor ) {

        			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

        		}

        		this.scene.overrideMaterial = null;
        		// reset depth mask
        		renderer.context.depthMask( true );
        		renderer.context.enable(renderer.context.DEPTH_TEST);

        	}

        };

        function ShaderPass ( shader, textureID ) {

        	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

        	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

        	this.material = new THREE.ShaderMaterial( {

        		defines: shader.defines || {},
        		uniforms: this.uniforms,
        		vertexShader: shader.vertexShader,
        		fragmentShader: shader.fragmentShader

        	} );

        	this.renderToScreen = false;

        	this.enabled = true;
        	this.needsSwap = true;
        	this.clear = false;
        	// variable to control whether this pass modifies the depth buffer
        	this.writeDepth = false;

        	this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );
        	this.scene  = new THREE.Scene();

        	this.quad = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), null );
        	this.scene.add( this.quad );

        }

        ShaderPass.prototype = {

        	render: function ( renderer, writeBuffer, readBuffer ) {

        		// enable or disable depth writing based on writeDepth
        		if (!this.writeDepth) {
        			renderer.context.depthMask( false );
        			renderer.context.disable(renderer.context.DEPTH_TEST);
        		} else {
        			renderer.context.depthMask( true );
        			renderer.context.enable(renderer.context.DEPTH_TEST);
        		}

        		if ( this.uniforms[ this.textureID ] ) {

        			this.uniforms[ this.textureID ].value = readBuffer;

        		}

        		this.quad.material = this.material;

        		if ( this.renderToScreen ) {

        			renderer.render( this.scene, this.camera );

        		} else {

        			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

        		}

        		// reset depth mask
        		renderer.context.depthMask( true );
        		renderer.context.enable(renderer.context.DEPTH_TEST);

        	}

        };

        function StencilPass ( scene, camera ) {

        	this.scene = scene;
        	this.camera = camera;

        	this.enabled = true;
        	this.clear = true;
        	this.needsSwap = false;

        	this.inverse = false;

        }

        StencilPass.prototype = {

        	render: function ( renderer, writeBuffer, readBuffer ) {

        		var context = renderer.context;

        		// enable both front and back facing polygons
        		context.disable(context.CULL_FACE);

        		// enable depth test, pass for value < depth
        		context.enable(context.DEPTH_TEST);
        		context.depthFunc(context.LESS);

        		// don't update color or depth mask
        		context.colorMask( false, false, false, false );
        		context.depthMask( false );
        		context.stencilMask( 255 );

        		// enable stencil test, clear buffer
        		context.enable( context.STENCIL_TEST );
        		context.clearStencil( 0 );
        		context.stencilFunc( context.ALWAYS, 1, 0xffffffff );

        		// deccrease stencil buffer for back-facing polygons on z fail
        		context.stencilOpSeparate(context.BACK, context.KEEP, context.DECR_WRAP, context.KEEP);
        		// increase stencil buffer for front-facing polygons on z fail
        		context.stencilOpSeparate(context.FRONT, context.KEEP, context.INCR_WRAP, context.KEEP);

        		// offset polygons to avoid self shadowing artifacts
        		// TODO check if flickering at large distances can be improved with dynamic camera planes
        		context.enable(context.POLYGON_OFFSET_FILL);
        		context.polygonOffset(-0.01, 0.0);

        		// draw into the stencil buffer
        		renderer.render( this.scene, this.camera, readBuffer, this.clear );
        		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

        		context.disable(context.POLYGON_OFFSET_FILL);

        		// re-enable update of color and depth
        		context.colorMask( true, true, true, true );
        		context.depthMask( true );

        		// only render where stencil is not zero
        		context.stencilFunc( context.NOTEQUAL, 0, 0xffffffff );  // draw if != 0

        		// keep stencilbuffer
        		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );
        	}

        };

        var CopyShader = {

        	uniforms: {

        		"tDiffuse": { type: "t", value: null },
        		"opacity":  { type: "f", value: 1.0 }

        	},

        	vertexShader: [

        		"varying vec2 vUv;",

        		"void main() {",

        			"vUv = uv;",
        			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        		"}"

        	].join("\n"),

        	fragmentShader: [

        		"uniform float opacity;",

        		"uniform sampler2D tDiffuse;",

        		"varying vec2 vUv;",

        		"void main() {",

        			"vec4 texel = texture2D( tDiffuse, vUv );",
        			"gl_FragColor = opacity * texel;",

        		"}"

        	].join("\n")

        };

        var DarkenShader = {

        	uniforms: {

        		"tDiffuse":       { type: "t",  value: null },
        		"alpha":          { type: "f",  value: 0.25 },
                "color":          { type: "v3", value: new THREE.Vector3(0.0, 0.0, 0.0) }
        	},

        	vertexShader: [

                "varying vec2 vUv;",

                "void main(void) {",

                    "vUv = uv;",

                    "vec4 p = modelViewMatrix * vec4( position, 1.0 );",
                    "gl_Position = projectionMatrix * p;",
                "}"

        	].join("\n"),

        	fragmentShader: [

                "uniform sampler2D tDiffuse;",
                "uniform float alpha;",
                "uniform vec3 color;",

        		"varying vec2 vUv;",

                "void main(void) {",
                    "vec4 shadow = vec4(alpha) * vec4(color, 1.0) + vec4(1.0 - alpha);",
                    "gl_FragColor = texture2D(tDiffuse, vUv) * shadow;",
                "}"

        	].join("\n")

        };

        var FXAAShader = {

        	uniforms: {

        		"tDiffuse":   { type: "t", value: null },
        		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

        	},

        	vertexShader: [

        		"void main() {",

        			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        		"}"

        	].join("\n"),

        	fragmentShader: [

        		"uniform sampler2D tDiffuse;",
        		"uniform vec2 resolution;",

        		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
        		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
        		"#define FXAA_SPAN_MAX     8.0",

        		"void main() {",

        			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
        			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
        			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
        			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
        			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
        			"vec3 rgbM  = rgbaM.xyz;",
        			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

        			"float lumaNW = dot( rgbNW, luma );",
        			"float lumaNE = dot( rgbNE, luma );",
        			"float lumaSW = dot( rgbSW, luma );",
        			"float lumaSE = dot( rgbSE, luma );",
        			"float lumaM  = dot( rgbM,  luma );",
        			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
        			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

        			"vec2 dir;",
        			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
        			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

        			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

        			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
        			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
        					"max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
        						"dir * rcpDirMin)) * resolution;",
        			"vec4 rgbA = (1.0/2.0) * (",
        			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (1.0/3.0 - 0.5)) +",
        			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (2.0/3.0 - 0.5)));",
        			"vec4 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (",
        			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (0.0/3.0 - 0.5)) +",
        			"texture2D(tDiffuse,  gl_FragCoord.xy  * resolution + dir * (3.0/3.0 - 0.5)));",
        			"float lumaB = dot(rgbB, vec4(luma, 0.0));",

        			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

        				"gl_FragColor = rgbA;",

        			"} else {",
        				"gl_FragColor = rgbB;",

        			"}",

        		"}"

        	].join("\n")

        };

        var SAOShader = {

            uniforms: {

                // info from previous passes
                "tDiffuse":     { type: "t", value: null },
                "tDepth":       { type: "t", value: null },
                "tNorm":        { type: "t", value: null },
                "size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },

                // camera parameters
                "projInv":      { type: "m4", value: null },
                "near":         { type: "f", value: 1 },
                "far":          { type: "f", value: 600 },

                // occlsuion parameters
                "radius":       { type: "f", value: 2.0 },
                "bias":         { type: "f", value: 0.001 },
                "noise":        { type: "f", value: 0.05 },
                "intensity":    { type: "f", value: 7.5 },
                "sigma":        { type: "f", value: 0.05 },
                "projScale":    { type: "f", value: 0.03 },

                // which falloff function to use
                "variation":    { type: "i", value: 2 },

                // display only diffuse
                "onlyDiffuse":  { type: "i", value: 0 },
                // display only AO
                "onlyAO":       { type: "i", value: 0 }

            },

            // pass-through vertex shader
            vertexShader: [

                "varying vec2 vUv;",
                "varying mat3 viewInv;",

                "void main() {",
                    "vUv = uv;",
                    "viewInv = normalMatrix;",
                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"

            ].join("\n"),

            fragmentShader: [

                //"#extension GL_OES_standard_derivatives : enable", // TODO uncomment for THREE js r72

                "uniform sampler2D tDepth;",      // Depth texture
                "uniform sampler2D tNorm;",      // Normals texture
                "uniform sampler2D tDiffuse;",  // Diffuse rendering
                "uniform vec2 size;",

                // Camera parameters
                "uniform mat4 projInv;",          // Inverse of projection matrix
                "uniform float near;",            // Camera near plane
                "uniform float far;",            // Camera far plane

                // Occlusion parameters
                "uniform float radius;",        // World space sample radius
                "uniform float bias;",            // Bias to ignore AO in smooth corners
                "uniform float noise;",            // Amount of noise to use
                "uniform float intensity;",        // Intensity of AO
                "uniform float sigma;",            // Chosen for aesthetics
                "uniform float projScale;",        // A scale factor on the radius

                "uniform int variation;",        // Falloff function to use
                "uniform bool onlyAO;",          // Display only AO
                "uniform bool onlyDiffuse;",          // Display only diffuse

                "varying mat3 viewInv;",        // Inverse of view matrix
                "varying vec2 vUv;",

                "const int NUM_SAMPLES = 16;",
                "const int NUM_SPIRAL_TURNS = 7;",
                "const float PI = 3.14159;",

                /**
                 * Pesudo random number generator
                 *
                 * @param  {vec2} coord     uv coordinates
                 * @return {float}             random float between 0 and 1
                 */
                "float rand( const vec2 coord ) {",
                    "return fract(sin(dot(coord.xy ,vec2(12.9898,78.233))) * 43758.5453);",
                "}",

                /**
                 * Read in depth from depth texture. The value is
                 * split into the RGBA channels of the texture, so these
                 * values must be bit-shifted back to obtain the depth.
                 *
                 * @param  {vec2} coord     screen-space coordinate
                 * @return {float}             world-space z-depth
                 */
                "float readDepth( in vec2 coord ) {",
                    "vec4 rgba_depth = texture2D( tDepth, coord );",
                    "const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
                    "float depth = dot( rgba_depth, bit_shift );",

                    "return 2.0*near / ( far+near - depth*(far-near) );", // regular depth buffer
                "}",

                /**
                 * Calculates the view-space (camera-space) position of
                 * a given uv coordinate
                 *
                 * @param  {vec2} uv     screen-space coordinate
                 * @return {vec3}         view-space coordinate
                 */
                "vec3 calcVSPos(vec2 uv) {",
                    "float depth = readDepth( uv );",
                    "vec2 clipUV  = uv * 2.0 - vec2(1.0);", // convert to clip-space
                    "vec4 invUV = (projInv * mat4(viewInv) * vec4(clipUV, -1.0, 1.0));", // invert view and camera projections
                    "vec3 eyeRay = normalize( (invUV/invUV.w).xyz - cameraPosition);", // ray from camera

                    "vec3 wsPos = eyeRay * depth + cameraPosition;", // world-space position
                    "return (viewMatrix * vec4(wsPos, 1.0)).xyz;", // re-project world-space position to screen space
                "}",

                /**
                 * Gets the screen-space location of a sample on a unit disk
                 *
                 * @param  {int} sampleNumber     the index of the current sample
                 * @param  {float} spinAngle     the angle on the unit disk
                 * @return {float} ssR             the screen space radius of the sample location
                 * @return {vec2}                 the unit vector offset
                 */
                "vec2 tapLocation(int sampleNumber, float spinAngle, out float ssR) {",
                    "float alpha = (float(sampleNumber) + 0.5) / float(NUM_SAMPLES);",
                    "float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;",

                    "ssR = alpha;",

                    "return vec2(cos(angle), sin(angle));",
                "}",

                /**
                 * Gets the view-space position of the point at screen-space pixel uv:
                 * uv + unitOffset * ssR
                 *
                 * @param  {vec2} uv            screen-space coordinate
                 * @param  {vec2} unitOffset    unit vector in offset direciton
                 * @param  {float} ssR          screen-space radius
                 * @return {vec3}               view-space position of point at uv
                 */
                "vec3 getOffsetPt(vec2 uv, vec2 unitOffset, float ssR) {",
                    "vec2 offsetUV = uv + ssR * unitOffset * (size.y / size.x);",
                    "return calcVSPos(offsetUV);",
                "}",

                /**
                 * Calculates the ambient occlusion from pixel uv from the
                 * sample with index tapIndex
                 *
                 * @param  {vec2} uv                screen-space coordinate
                 * @param  {vec3} vsPos             view-space position
                 * @param  {vec3} vsNorm            view-space normal
                 * @param  {float} sampleSSR         screen-space sampling radius
                 * @param  {int} tapIndex              index of current sample
                 * @param  {float} rotationAngle     angle of rotation on unit disk
                 * @return {float}                   occlusion from this sample
                 */
                "float sampleAO(vec2 uv, vec3 vsPos, vec3 vsNorm, float sampleSSR, int tapIndex, float rotationAngle) {",
                    "const float epsilon = 0.01;",
                    "float r2 = radius * radius;",

                    // offset on the unit disk, spun for this pixel
                    "float ssR;",
                    "vec2 unitOffset = tapLocation(tapIndex, rotationAngle, ssR);",
                    "ssR *= sampleSSR;",

                    // view-space coordinate of sample point
                    "vec3 Q = getOffsetPt(uv, unitOffset, ssR);",
                    "vec3 v = Q - vsPos;",

                    "float vv = dot(v, v) / projScale;",
                    "float vn = dot(v, vsNorm);",

                    "if (variation == 1) {",
                         // Smoother transition to zero (lowers contrast, smoothing out corners)
                         "float f = max(r2 - vv, 0.0);",
                         "return f * f * f * max( (vn - bias) / (epsilon + vv), 0.0);",
                     "} else if (variation == 2) {",
                         // Medium contrast (which looks better at high radii), no division.
                         "float invR2 = 1.0 / r2;",
                         "return 4.0 * max(1.0 - vv * invR2, 0.0) * max(vn, 0.0);",
                     "} else if (variation == 3) { ",
                         // Low contrast, no division operation
                         "return 2.0 * float(vv < r2) * max(vn, 0.0);",
                     "} else {",
                         // Default to variation == 0
                         // From HPG12 paper (large epsilon to avoid overdarkening within cracks)
                         "return float(vv < r2) * max(vn / (epsilon + vv), 0.0);",
                    "}",

                "}",

                /**
                 * Calculates the total occlusion of pixel uv by sampling
                 * nearby pixels and summing the occlusion from each
                 *
                 * @param  {vec2} uv       texture coordinate of current pixel
                 * @return {float}        occlusion of pixel uv in [0, 1]
                 */
                "float calcAO(vec2 uv) {",
                    "vec3 vsPos = calcVSPos(uv);",
                    "vec3 vsNorm = texture2D( tNorm, uv).rgb;",

                    "float sampleNoise = rand(uv) * noise;",
                    "float rAngle = 2.0 * PI * sampleNoise;", // random angle

                    "float ssR = projScale * radius / ( vsPos.z ) ;", // radius of influence in screen space

                    // sum occlusion from each sample and average
                    "float occlusion = 0.0;",
                    "for (int i = 0; i < NUM_SAMPLES; ++i) {",
                        "occlusion += sampleAO(uv, vsPos, vsNorm, ssR, i, rAngle);",
                    "}",
                    "occlusion = (1.0 - occlusion * (2.0*sigma / float(NUM_SAMPLES)));",
                    "occlusion = clamp(pow(occlusion, 1.0 + intensity), 0.0, 1.0);",

                    // TODO uncomment for THREE js r72
                    // slight blur (from paper), effects are subtle
                    /*"if (abs(dFdx(vsPos.z)) < 0.02) {",
                        "occlusion -= dFdx(occlusion) * ((uv.x) - 0.5);",
                    "}",
                    "if (abs(dFdy(vsPos.z)) < 0.02) {",
                        "occlusion -= dFdy(occlusion) * ((uv.y) - 0.5);",
                    "}",*/

                    "return occlusion;",
                "}",

                "void main(void) {",
                    // diffuse color of pixel
                    "vec4 color = texture2D( tDiffuse, vUv );",

                    "if (onlyDiffuse) {",
                        "gl_FragColor = vec4( color.rgb, 1.0 );",
                    "} else {",
                        "float occlusion = calcAO( vUv );",
                        "if (onlyAO) {",
                            "gl_FragColor = vec4( vec3(occlusion), 1.0 );",
                        "} else {",
                            "gl_FragColor = vec4( vec3(occlusion)*color.rgb, 1.0 );",
                        "}",
                    "}",

                "}"



            ].join("\n")

        };

        //TODO(Kyle): This is from three.js r72 and should be updated to
        // the latest example in r77 before enabling in production. LIB3D-640
        function EffectComposer ( renderer, renderTarget ) {

        	this.renderer = renderer;

        	if ( renderTarget === undefined ) {

        		var pixelRatio = renderer.getPixelRatio();
        		var size = renderer.getSize();
        		var width  = Math.floor( size.width  / pixelRatio ) || 1;
        		var height = Math.floor( size.height / pixelRatio ) || 1;
        		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

        		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

        	}

        	this.renderTarget1 = renderTarget;
        	this.renderTarget2 = renderTarget.clone();

        	this.writeBuffer = this.renderTarget1;
        	this.readBuffer = this.renderTarget2;

        	this.passes = [];

        	this.copyPass = new ShaderPass( CopyShader );

        }

        EffectComposer.prototype = {

        	swapBuffers: function() {

        		var tmp = this.readBuffer;
        		this.readBuffer = this.writeBuffer;
        		this.writeBuffer = tmp;

        	},

        	addPass: function ( pass ) {

        		this.passes.push( pass );

        	},

        	insertPass: function ( pass, index ) {

        		this.passes.splice( index, 0, pass );

        	},

        	render: function ( delta ) {

        		this.writeBuffer = this.renderTarget1;
        		this.readBuffer = this.renderTarget2;

        		var maskActive = false;

        		var pass, i, il = this.passes.length;

        		for ( i = 0; i < il; i ++ ) {

        			pass = this.passes[ i ];

        			if ( ! pass.enabled ) continue;

        			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

        			if ( pass.needsSwap ) {

        				if ( maskActive ) {

        					var context = this.renderer.context;

        					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

        					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

        					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

        				}

        				this.swapBuffers();

        			}

        			if ( pass instanceof MaskPass ) {

        				maskActive = true;

        			} else if ( pass instanceof ClearMaskPass ) {

        				maskActive = false;

        			}

        		}

        	},

        	reset: function ( renderTarget ) {

        		if ( renderTarget === undefined ) {

        			renderTarget = this.renderTarget1.clone();

        			var pixelRatio = this.renderer.getPixelRatio();

        			renderTarget.width  = Math.floor( this.renderer.context.canvas.width  / pixelRatio );
        			renderTarget.height = Math.floor( this.renderer.context.canvas.height / pixelRatio );

        		}

        		this.renderTarget1.dispose();
        		this.renderTarget1 = renderTarget;
        		this.renderTarget2.dispose();
        		this.renderTarget2 = renderTarget.clone();

        		this.writeBuffer = this.renderTarget1;
        		this.readBuffer = this.renderTarget2;

        	},

        	setSize: function ( width, height ) {

        		this.renderTarget1.setSize( width, height );
        		this.renderTarget2.setSize( width, height );

        	}

        };

        function ShadowBuilder ( position, category ) {
            /**
             * The origin of the light that is casting shadows.
             * Directional lights are always pointing at the origin
             *
             * @type {THREE.Vector3}
             */
            this.origin = position;

            /**
             * The type of the light source, 'directional' or 'point'
             *
             * @type {String}
             * @default 'directional'
             */
            this.category = 'directional';
            if (category) this.category = category;

            /**
             * Dictionary mapping the unique id of a THREE.Mesh (uuid)
             * to its shadow volume
             *
             * @type {Object}
             */
            this.meshes = {};

            /**
             * Default material for all shadow volumes. The only
             * requirement is that it is double-sided.
             *
             * @type {THREE.Material}
             */
            this.material = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide } );

            /**
             * Extent of the shadow volume, based on the camera
             * far plane. If the back of the volume is cut off, there
             * will be shadow artifacts.
             *
             * TODO: get from camera. (Should be slightly less than far plane)
             *
             * @type {Number}
             */
            this.far = 10000.0 * 0.75;

            /**
             * Offsets the shadow volume to prevent z-fighting where
             * volume faces are coincident with geometry. High bias
             * causes bleeding, low bias causes z-fighting.
             *
             * @type {Number}
             */
            this.bias = 0.0075;
        }

        ShadowBuilder.prototype = {

            // INITIALIZATION

            /**
             * Adds a mesh (THREE.Mesh) to the shadow builder.
             * Creates a dictionary entry for this mesh, holding geometry
             * information and shadow volume information.
             *
             * @param {THREE.Mesh} mesh      the mesh casting the shadow
             */
            _addMesh: function ( mesh ) {
                this.meshes[mesh.uuid] = {
                    'v' : null,
                    'f' : null,

                    'matrixWorld' : new THREE.Matrix4(),
                    'normalMatrix' : new THREE.Matrix3(),

                    'vertices': [],     // holds vertices (THREE.Vector3) of shadow volume
                    'faces': [],        // holds faces (THREE.Face3) of shadow volume
                    'volume': null      // shadow volume
                };

                mesh.updateMatrixWorld(true);
                // mesh transform matrix
                this.meshes[mesh.uuid].matrixWorld = mesh.matrixWorld;
                // inverse transpose of upper 3x3 for normal transforms
                this.meshes[mesh.uuid].normalMatrix.getNormalMatrix(mesh.matrixWorld);

                this._addGeometry(mesh);

                var volume = new THREE.Mesh(new THREE.Geometry(), this.material);
                volume.geometry.vertices = this.meshes[mesh.uuid].vertices;
                volume.geometry.faces = this.meshes[mesh.uuid].faces;
                this.meshes[mesh.uuid].volume = volume;
            },

            /**
             * Transforms and adds vertex and face info from a mesh.
             *
             * @param {THREE.Mesh} mesh      the mesh casting the shadow
             */
            _addGeometry: function ( mesh ) {
                // the BufferGeometry holds vertices and faces in a different format
                var geom;
                if (mesh.geometry instanceof THREE.BufferGeometry) {
                    geom = new THREE.Geometry().fromBufferGeometry( mesh.geometry );
                } else {
                    geom = mesh.geometry.clone(); // TODO any way to avoid cloning entire geom?
                }
                geom.computeFaceNormals();
                geom.mergeVertices();

                // input geometry values
                var v = geom.vertices;
                var f = geom.faces;

                // transform vertices by mesh scale/rotate/translate
                for (var i = 0; i < v.length; i++) {
                    v[i].applyMatrix4(this.meshes[mesh.uuid].matrixWorld);
                }

                this.meshes[mesh.uuid].v = v;
                this.meshes[mesh.uuid].f = f;

                geom.dispose();
            },

            // GEOMETRY COMPUTATION

            /**
             * Deletes the current volume geometry if it exists,
             * then computes the silhouette, calculates the shadow
             * volume and the THREE.js mesh representing it.
             *
             * @param  {String} meshID       unique id of mesh
             */
            _computeShadowVolume: function ( meshID ) {
                // clear previous volume calculation
                this.meshes[meshID].vertices.length = 0;
                this.meshes[meshID].faces.length = 0;
                if (this.meshes[meshID].volume) {
                    this.meshes[meshID].volume.geometry.dispose();
                }

                var edges = this._getSilhouetteAndCap(meshID);
                this._computeShadowSides(meshID, edges);

                var volume = this.meshes[meshID].volume;
                volume.geometry = new THREE.Geometry();
                volume.geometry.vertices = this.meshes[meshID].vertices;
                volume.geometry.faces = this.meshes[meshID].faces;

                this.meshes[meshID].volume.geometry.computeFaceNormals();
            },

            /**
             * Extrudes the silhouette in the direction of the light,
             * adds these triangles to the list of vertices and faces.
             *
             * @param  {String} meshID       unique id of mesh
             * @param  {String[]} edges      array of edges in silhouette
             */
            _computeShadowSides: function ( meshID, edges ) {
                // generates two triangles for each side
                for (var i = 0; i < edges.length; i++) {
                    var a = this._projectVertex(this.meshes[meshID].v[edges[i][0]], this.bias);
                    var b = this._projectVertex(this.meshes[meshID].v[edges[i][1]], this.bias);
                    var a_prime = this._projectVertex(a, this.far);
                    var b_prime = this._projectVertex(b, this.far);
                    this._addQuad(meshID, a, a_prime, b, b_prime);
                }
            },

            /**
             * Calculates the silhouette of the geometry. Each edge is added
             * to the dictionary if not yet present, and the appropriate boolean
             * (light-facing or not-light-facing) is set to be true. An edge
             * from vertex a to vertex b is represented as the string 'a_b'
             * ('a_b' == 'b_a') plus the array [a, b].
             *
             * While iterating through the faces, this function
             * also computes the back and front caps of the shadow volume.
             *
             * @param  {String} meshID       unique id of mesh
             * @return {Array.<Array.<Number>>}     array of edges in silhouette
             */
            _getSilhouetteAndCap: function ( meshID ) {
                var edgeDict = {}; // edges currently in silhouette
                var edges = []; // final silhouette edges
                var i, j, face, verts, isFacing, a, b;

                // iterate over all triangles
                var f = this.meshes[meshID].f;
                var v = this.meshes[meshID].v;
                for (i = 0; i < f.length; i++) {
                    face = f[i];
                    verts = [face.a, face.b, face.c];

                    // check if triangle is light-facing
                    isFacing = this._isLightFacing( meshID, face );
                    for (j = 0; j < 3; j++) {
                        a = verts[j];
                        b = verts[(j+1)%3];
                        this._addEdge( edgeDict, a, b, isFacing );
                    }

                    // add non-light-facing triangles as caps
                    if (!isFacing) {
                        this._addCapTriangle(meshID, v[face.a], v[face.c], v[face.b]);
                    }
                }

                var manifold = true;
                for (var k in edgeDict) {
                    // first check if edge is manifold
                    if (!edgeDict[k].manifold) {
                        manifold = false;
                        break;
                    } else if (edgeDict[k].front && edgeDict[k].back) {
                        // all edges on the border between light-facing and
                        // back-facing are part of the silhouette
                        var endpts = edgeDict[k].verts;
                        edges.push(endpts);
                    }
                }

                // for non-manifold geometries, add all edges to the silhouette
                if (!manifold) {
                    edges.length = 0;
                    for (i = 0; i < f.length; i++) {
                        face = f[i];
                        verts = [face.a, face.b, face.c];

                        isFacing = this._isLightFacing( meshID, face );
                        for (j = 0; j < 3; j++) {
                            a = verts[j];
                            b = verts[(j+1)%3];
                            var edge = !isFacing ? [b, a] : [a, b];
                            edges.push(edge);
                        }

                        // add remaining triangles to caps
                        if (isFacing) {
                            this._addCapTriangle(meshID, v[face.a], v[face.b], v[face.c]);
                        }
                    }
                }

                return edges;
            },

            // MATH FUNCTIONS

            /**
             * Check if triangle faces the light. For point lights, calculate
             * a ray from the light origin to the center of the triangle. For
             * directional lights use a ray in the light direction.
             *
             * @param  {string} meshID       unique id of mesh
             * @param  {THREE.Face3} face    the current face
             * @return {bool}                true if triangle faces the light
             */
            _isLightFacing: function ( meshID, face ) {
                var n = face.normal.clone().applyMatrix3(this.meshes[meshID].normalMatrix);

                if (this.category == 'point') {
                    var v = this.meshes[meshID].v;
                    var a = v[face.a];
                    var b = v[face.b];
                    var c = v[face.c];
                    var center = new THREE.Vector3();
                    center.x = (a.x + b.x + c.x)/3.0;
                    center.y = (a.y + b.y + c.y)/3.0;
                    center.z = (a.z + b.z + c.z)/3.0;
                    var dir = this.origin.clone().sub(center);
                    return ( n.dot(dir) >= 0 );
                } else {
                    return ( n.dot(this.origin) >= 0 );
                }

            },

            /**
             * Projects a vertex in the direction of the light for a length
             * of dist. For point lights, project from light origin,
             * for directional lights, project along light direction.
             *
             * @param  {THREE.Vector3} v     vertex to be projected
             * @param  {Number} dist         distance to project
             * @return {THREE.Vector3}       new, projected vertex
             */
            _projectVertex: function ( v, dist ) {
                var v_prime = v.clone();

                if (this.category == 'point') {
                    var dir = v.clone().sub(this.light).normalize();
                    v_prime.add(dir.multiplyScalar(dist));
                } else {
                    var l = this.origin.clone().normalize();
                    l.negate().multiplyScalar(dist);
                    v_prime.add(l);
                }

                return v_prime;
            },

            // GEOMETRY ADDITION

            /**
             * Attempts to add the edge from vertex a to b. Edges are
             * defined as a string 'a_b'. Removes edge from dict if
             * either 'a_b' or 'b_a' is already present.
             *
             * @param {Object} edgeDict      dictionary of processed edges
             * @param {int} a                index of vertex a
             * @param {int} b                index of vertex b
             * @param {bool} isFacing        is the edge from a light-facing triangle
             */
            _addEdge: function ( edgeDict, a, b, isFacing ) {
                var name = a+'_'+b;
                if (edgeDict[b+'_'+a]) name = b+'_'+a;

                if ( edgeDict[name] ) {
                    // check if we've already seen the edge twice
                    if (edgeDict[name].front == edgeDict[name].back) {
                        edgeDict[name].manifold = false;
                        return;
                    }
                    // otherwise flip the appropriate boolean
                    if (isFacing) {
                        edgeDict[name].front = !edgeDict[name].front;
                    } else {
                        edgeDict[name].back = !edgeDict[name].back;
                    }
                    edgeDict[name].manifold = true;
                } else {
                    var verts = !isFacing ? [b, a] : [a, b];
                    edgeDict[a+'_'+b] = {
                        'verts'     : verts,
                        'front'     : isFacing,
                        'back'      : !isFacing,
                        'manifold'  : false
                    };
                }
            },

            /**
             * Adds a triangle to the front and back shadow caps.
             *
             * @param {String} meshID        unique id of mesh
             * @param {[type]} a             vertex of triangle
             * @param {[type]} b             vertex of triangle
             * @param {[type]} c             vertex of triangle
             */
            _addCapTriangle: function( meshID, a, b, c ) {
                // front cap
                var a_front = this._projectVertex(a, this.bias);
                var b_front = this._projectVertex(b, this.bias);
                var c_front = this._projectVertex(c, this.bias);
                this._addTriangle(meshID, a_front, b_front, c_front);

                // back cap
                var a_back = this._projectVertex(a, this.far);
                var b_back = this._projectVertex(b, this.far);
                var c_back = this._projectVertex(c, this.far);
                this._addTriangle(meshID, a_back, c_back, b_back);
            },

            /**
             * Adds two triangles defining the rectangular shadow side abcd.
             *
             * @param {String} meshID               unique id of mesh
             * @param {THREE.Vector3} a             vertex of rectangle
             * @param {THREE.Vector3} b             vertex of rectangle
             * @param {THREE.Vector3} c             vertex of rectangle
             * @param {THREE.Vector3} d             vertex of rectangle
             */
            _addQuad: function ( meshID, a, b, c, d ) {
                this._addTriangle(meshID, a, b, c);
                this._addTriangle(meshID, d, c, b);
            },

            /**
             * Adds the vertices and approrpiate face to shadow volume.
             *
             * @param {String} meshID               unique id of mesh
             * @param {THREE.Vector3} a             vertex of triangle
             * @param {THREE.Vector3} b             vertex of triangle
             * @param {THREE.Vector3} c             vertex of triangle
             */
            _addTriangle: function ( meshID, a, b, c ) {
                this.meshes[meshID].vertices.push(a);
                this.meshes[meshID].vertices.push(b);
                this.meshes[meshID].vertices.push(c);
                var l = this.meshes[meshID].vertices.length;
                this.meshes[meshID].faces.push(new THREE.Face3(l-3, l-2, l-1));
            },


            // PUBLIC FUNCTIONS

            /**
             * Calculates shadow volume if not yet calculated, returns volume
             *
             * @param  {THREE.Mesh} mesh     position of the light
             * @return {THREE.Mesh}          a mesh representing the shadow volume
             */
            getShadowVolume: function ( mesh ) {
                if (!this.meshes[mesh.uuid]) {
                    this._addMesh(mesh);
                    this._computeShadowVolume(mesh.uuid);
                }

                return this.meshes[mesh.uuid].volume;
            },

            /**
             * Recalculates a shadow volume (used when light or geometry changes)
             *
             * @param  {THREE.Mesh} mesh     mesh casting the shadow
             * @return {THREE.Mesh}          a mesh representing the shadow volume
             */
            updateShadowVolume: function ( mesh ) {
                mesh.updateMatrixWorld(true);
                this.meshes[mesh.uuid].matrixWorld = mesh.matrixWorld;
                this.meshes[mesh.uuid].normalMatrix.getNormalMatrix(mesh.matrixWorld);

                this._addGeometry( mesh );
                this._computeShadowVolume( mesh.uuid );
                return this.meshes[mesh.uuid].volume;
            },

            /**
             * Updates the position of the light
             *
             * @param  {THREE.Vector3} position     position of the light
             */
            updateLight: function ( position ) {
                this.origin = position;
            }
        };

        // From legacy three.js r72 THREE.ShaderLib.depthRGBA
        var depthRGBA = {

            uniforms: {},

            vertexShader: [

                THREE.ShaderChunk.common,
                THREE.ShaderChunk.morphtarget_pars_vertex,
                THREE.ShaderChunk.skinning_pars_vertex,
                THREE.ShaderChunk.logdepthbuf_pars_vertex,

                "void main() {",

                    THREE.ShaderChunk.skinbase_vertex,

                    THREE.ShaderChunk.begin_vertex,
                    THREE.ShaderChunk.morphtarget_vertex,
                    THREE.ShaderChunk.skinning_vertex,
                    THREE.ShaderChunk.project_vertex,
                    THREE.ShaderChunk.logdepthbuf_vertex,

                "}"

            ].join( "\n" ),

            fragmentShader: [

                THREE.ShaderChunk.common,
                THREE.ShaderChunk.logdepthbuf_pars_fragment,

                "vec4 pack_depth( const in float depth ) {",

                "   const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
                "   const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
                "   vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "    vec4 res = fract( depth * bit_shift );",
                "   res -= res.xxyz * bit_mask;",
                "   return res;",

                "}",

                "void main() {",

                    THREE.ShaderChunk.logdepthbuf_fragment,

                "   #ifdef USE_LOGDEPTHBUF_EXT",

                "       gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

                "   #else",

                "       gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

                "   #endif",

                    //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
                    //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
                    //"gl_FragData[ 0 ] = pack_depth( z );",
                    //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

                "}"

            ].join( "\n" )


        };

        // Multipass Variables (private, singleton)
        // Material that writes depth to pixels
        var DEPTH_MATERIAL = new THREE.ShaderMaterial( {
            uniforms: THREE.UniformsUtils.clone( depthRGBA.uniforms ),
            fragmentShader: depthRGBA.fragmentShader,
            vertexShader: depthRGBA.vertexShader,
            blending: THREE.NoBlending
        } );

        // Material that writes normal to pixels
        var NORMAL_MATERIAL = new THREE.MeshNormalMaterial();

        /**
         * Class wrapping the renderer with custom passes and context swapping.
         * Multipass rendering uses GPU shaders to accomplish ambient obscurance
         * and stencil buffer shadows.
         * Context swapping lets a single OpenGL context and canvas be used for multiple renderers.
         * @class FluxRenderer
         * @param {Element} domParent The div container for the canvas
         * @param {Number} width     The width of the canvas
         * @param {Number} height    The height of the canvas
         */
        function FluxRenderer(domParent, width, height) {
            this.id = FluxRenderer.nextId++;

            // Dom element that wraps the canvas
            this._domParent = domParent;

            // Determines if multipass rendering (FluxThreePlugins.EffectsComposer) is used
            this._multipass = false;

            // TODO: Convert this to a list of passes rather than individual bools
            // Determines if ambient occlusion is used (requires multipass to be true)
            this._showOcclusion = true;

            // Determines if stencilbuffer shadows are used (requires multipass)
            this._showShadows = false;

            // Current three.js geometry to render
            this._model = null;

            // The object containing the lights in the scene
            this._lights = null;

            // The context that contains the renderer and corresponds to a canvas
            // Create renderer for the first time.
            this._context = FluxRenderContext.getNewContext();

            // EffectComposer object, used in multipass rendering
            this._composer = new EffectComposer(this._context.renderer);

            this._width = width;
            this._height = height;

            this._createCacheCanvas(width, height);

            this.setClearColor(0xC5CDCC);

            this._cameras = new FluxCameras(width, height);
            this._helpers = new FluxHelpers();
            this._helpersScene = new THREE.Scene();
            this._helpersScene.add(this._helpers);

            // Camera to be rendered with.Any instance of `THREE.Camera` can be set here.
            this._initControls();

            // Scene containing geometry to be rendered in this viewport THREE.Scene
            this._scene = new THREE.Scene();
            // this._scene.add(this._helpers);

            // Fog object for this viewport constructed from color and density
            this._fog = new THREE.FogExp2( this._clearColor, 0.0 );
            this._scene.fog = this._fog;

            // Scene containing edges geometry for hidden line rendering
            this._edgesScene = new THREE.Scene();
            this._edgesMode = EdgesHelper.EDGES_MODES.NONE;

            // variables for stencilbuffer shadows
            // Scene holding shadow volumes = THREE.Scene
            this._shadowScene = new THREE.Scene();
            // Color of shadows (multiplied with ground) @type {THREE.Color}
            this._shadowColor = new THREE.Color(0.08, 0.0, 0.2);
            // Alpha opacity of shadow, where 1.0 is completely opaque
            this._shadowAlpha = 0.35;
            this._shadowBuilder = new ShadowBuilder(this._shadowLight);

            this._addPasses();
        }

        FluxRenderer.prototype = Object.create( THREE.EventDispatcher.prototype );
        FluxRenderer.prototype.constructor = FluxRenderer;

        // Used for debugging issues with _setHost
        FluxRenderer.nextId = 0;

        /**
         * Name of the event fired when the camera changes
         * @type {String}
         */
        FluxRenderer.CHANGE_EVENT = 'change';

        /**
         * Set the lights used to illuminate the scene.
         * @param {THREE.Object3D} lights Object with lights as children
         */
        FluxRenderer.prototype.setLights = function(lights) {
            if (this._lights) {
                this._scene.remove(this._lights);
            }
            this._lights = lights;
            this._scene.add(this._lights);
        };

        /**
         * Remove the geometry objects from the THREE registry so they can be garbage collected
         * @param  {THREE.Object3D} obj The object being removed
         */
        function _removeGeometries(obj) {
            if (obj.geometry) {
                obj.geometry.dispose();
            }
        }

        /**
         * Remove an object from the scene and clean up memory
         * @param  {THREE.Scene} scene Scene containing the model
         * @param  {THREE.Object3D} model The geometry to remove
         */
        function _deleteFromScene(scene, model) {
            if (!model || !scene) return;
            scene.remove(model);
            model.traverse(_removeGeometries);
        }

        /**
         * Set the object to render
         * Replaces old render contents
         * @param {THREE.Object3D} model What to render
         */
        FluxRenderer.prototype.setModel = function(model) {
            if (this._model) {
                _deleteFromScene(this._scene, this._model);
                _deleteFromScene(this._edgesScene, this._model.edgesHelper);
            }
            this._model = model;
            if (this._model) {
                this._scene.add(this._model);
                if (EdgesHelper.AddEdges(this._model, this._edgesMode)) {
                    this._edgesScene.add(this._model.edgesHelper);
                }
            }
        };

        /**
         * Set the edges rendering mode for hidden line rendering
         * @param  {EdgesHelper.EDGES_MODES} mode Whether to render front, back, both or none
         */
        FluxRenderer.prototype.setEdgesMode = function(mode) {
            this._edgesMode = mode;
        };

        /**
         * When the camera controls change make sure to update the camera
         * @private
         */
        FluxRenderer.prototype._initControls = function() {
            if (this._controls) this._controls.enabled = false;
            //TODO(Kyle): rewrite EditorControls to allow camera to be changed
            this._controls = new EditorControls(this._cameras.getCamera(), this._domParent);
            var _this = this;
            this._controls.addEventListener(FluxRenderer.CHANGE_EVENT, function(event) {
                _this._cameras.updateCamera(_this._width, _this._height);
                _this.dispatchEvent( event );
            });
        };

        /**
         * Restore the camera to a default location
         */
        FluxRenderer.prototype.homeCamera = function() {
            this._controls.focus(this._helpers, true);
        };

        /**
        * Focus the controls' current camera on an object.
        * This function will focus on the union of object and all of it's visible children.
        * @param  {THREE.Object3D} object The scene object to focus on.
        */
        FluxRenderer.prototype.focus = function() {
            if (!this._model) return;
            this._controls.focus(this._model, true);
            // Changing the controls here triggers a render
        };

        /**
         * Set the clear color (background) for WebGL canvas
         * @param {String|Number} color Hexadecimal or a CSS-style string
         */
        FluxRenderer.prototype.setClearColor = function(color) {
            this._clearColor = new THREE.Color(color);
        };

        /**
         * Set up a new canvas used for storing a cached image.
         * The cache image is populated when this renderer loses it's context.
         * @private
         * @param {Number} width The width of the canvas
         * @param {Number} height The height of the canvas
         */
        FluxRenderer.prototype._createCacheCanvas = function(width, height) {
            if (this._cacheCanvas) return;
            // The canvas used to store a cached image of the previous render when all the WebGL contexts are in use with other renderers
            this._cacheCanvas = document.createElement('canvas');
            this._cacheCanvas.width = width;
            this._cacheCanvas.height = height;
            this._cacheCanvas.style.position = 'absolute';
            this._cacheCanvas.style['user-select'] = 'none';
            this._cacheCanvas.style['-webkit-user-select'] = 'none';
            this._domParent.appendChild(this._cacheCanvas);

            // Canvas2D used to store framebuffer pixels after renderer.domElement migration.
            this.ctx = this._cacheCanvas.getContext('2d');
        };

        /**
         * Destructor to prevent future rendering after being unloaded
         */
        FluxRenderer.prototype.detach = function() {
            if (this._context && this._context.currentHost === this) {
                this._context.currentHost = null;
            }
        };

        /**
         * Change the camera view
         * @param {String} view The new view mode
         */
        FluxRenderer.prototype.setView = function(view) {
            this._cameras.setView(view);
            this._cameras.updateCamera(this._width, this._height);
            this._initControls();
            this._helpers.setView(view);

            if (!this._renderPasses) return;
            this._renderPasses.renderPass.camera = this._cameras.getCamera();
            this._renderPasses.edgesPass.camera = this._cameras.getCamera();
            this._renderPasses.helperPass.camera = this._cameras.getCamera();
            this._renderPasses.stencilPass.camera = this._cameras.getCamera();
        };

        /**
         * Creates depth, normal materials and depth, normal render targets.
         * @private
         */
        FluxRenderer.prototype._addRenderTargets = function() {
            // depth render target (uses THREE.js depth shader)
            this._depthTarget = new THREE.WebGLRenderTarget(
                window.innerWidth, //TODO(kyle) Why does this use window!?
                window.innerHeight,
                {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat
                }
            );

            // normal render target
            this._normalTarget = this._depthTarget.clone();
        };

        /**
         * Adds enabled passes to the EffectComposer
         *
         * Always begins with a render pass
         * Always ends with an antialiasing (FXAA) pass
         *
         * May include the following: Ambient occlusion, Shadows
         * @private
         */
        FluxRenderer.prototype._addPasses = function() {
            // _renderPasses dictionary for holding passes that need to be accessed or modified
            this._renderPasses = {};
            this._addRenderTargets();

            // diffuse render pass
            var renderPass = new RenderPass(this._scene, this._cameras.getCamera());
            this._composer.addPass(renderPass);
            this._renderPasses.renderPass = renderPass;

            var edgesPass = new RenderPass(this._edgesScene, this._cameras.getCamera());
            edgesPass.clear = false;
            this._composer.addPass(edgesPass);
            edgesPass.polygonOffset = true;
            edgesPass.enabled = !!this._edgesScene;
            this._renderPasses.edgesPass = edgesPass;

            // helper render pass
            var helperPass = new RenderPass(this._helpersScene, this._cameras.getCamera());
            helperPass.clear = false;
            this._composer.addPass(helperPass);
            this._renderPasses.helperPass = helperPass;
            helperPass.enabled = true;

            // ambient occlusion pass
            var aoPass = new ShaderPass(SAOShader);
            // set uniform vars for ao pass
            aoPass.uniforms.tDepth.value = this._depthTarget;
            aoPass.uniforms.tNorm.value = this._normalTarget;
            aoPass.uniforms.projInv.value = new THREE.Matrix4();//TODO.getInverse(this._cameras.getCamera().projectionMatrix);
            aoPass.uniforms.onlyAO.value = false; // set to true to view only ambient occlusion
            aoPass.clear = true;
            aoPass.needsSwap = true;
            this._renderPasses.aoPass = aoPass;
            this._composer.addPass(aoPass);

            // stencil buffer shadow passes
            var copyPass = new ShaderPass( CopyShader );
            copyPass.needsSwap = false;
            this._composer.addPass( copyPass ); // copy AO to write buffer
            this._renderPasses.copyPass = copyPass;

            var stencilPass = new StencilPass( this._shadowScene, this._cameras.getCamera());
            this._composer.addPass( stencilPass ); // render shadow volumes to stencilbuffer
            this._renderPasses.stencilPass = stencilPass;

            var darkenPass = new ShaderPass( DarkenShader );
            darkenPass.uniforms.alpha.value = this._shadowAlpha;
            darkenPass.uniforms.color.value = new THREE.Vector3(this._shadowColor.r, this._shadowColor.g, this._shadowColor.b);
            darkenPass.needsSwap = false;
            this._composer.addPass( darkenPass ); // darken stencil areas
            this._renderPasses.darkenPass = darkenPass;

            var clearPass = new ClearStencilPass();
            clearPass.needsSwap = true;
            this._composer.addPass( clearPass ); // clear stencil
            this._renderPasses.clearPass = clearPass;

            // fast approximate antialiasing pass
            var FXAAPass = new ShaderPass(FXAAShader);
            FXAAPass.renderToScreen = true;
            this._renderPasses.FXAAPass = FXAAPass;
            this._composer.addPass(FXAAPass);
        };

        /**
         * For multipass rendering, update which render passes are enabled.
         * Based on user preferences some passes may be turned on or off.
         * Also passes may be disabled if the corresponding scene is empty.
         * @private
         */
        FluxRenderer.prototype._updatePasses = function () {
            if (this._showOcclusion) {
                // populate depth target
                this._scene.overrideMaterial = DEPTH_MATERIAL;
                this._context.renderer.clearTarget( this._depthTarget, true, true );
                this._context.renderer.render( this._scene, this._cameras.getCamera(), this._depthTarget );

                // populate normal target (set clearColor to (0,0,0) since
                // empty pixels do not have normals)
                this._context.renderer.setClearColor( 0x000000 );
                this._scene.overrideMaterial = NORMAL_MATERIAL;
                this._context.renderer.clearTarget( this._normalTarget, true, true );
                this._context.renderer.render( this._scene, this._cameras.getCamera(), this._normalTarget );
                this._scene.overrideMaterial = null;
                this._context.renderer.setClearColor( this._clearColor );

                // update ambient occlusion shader uniforms
                var projInv = new THREE.Matrix4();
                projInv.getInverse(this._cameras.getCamera().projectionMatrix);
                this._renderPasses.aoPass.uniforms.projInv.value = projInv;
                this._renderPasses.aoPass.uniforms.size.value.set(this._width, this._height);
                this._renderPasses.aoPass.uniforms.onlyDiffuse.value = false;
            } else {
                this._renderPasses.aoPass.uniforms.onlyDiffuse.value = true;
            }

            if (this._showShadows) {
                this._composer.renderTarget1.stencilBuffer = true;
                this._composer.renderTarget2.stencilBuffer = true;
                this._renderPasses.copyPass.enabled = true;
                this._renderPasses.stencilPass.enabled = true;
                this._renderPasses.darkenPass.enabled = true;
                this._renderPasses.clearPass.enabled = true;
            } else {
                this._composer.renderTarget1.stencilBuffer = false;
                this._composer.renderTarget2.stencilBuffer = false;
                this._renderPasses.copyPass.enabled = false;
                this._renderPasses.stencilPass.enabled = false;
                this._renderPasses.darkenPass.enabled = false;
                this._renderPasses.clearPass.enabled = false;
            }

            // set antialiasing 'resolution' uniform to current screen resolution
            this._renderPasses.FXAAPass.uniforms.resolution.value.set(1.0/this._width, 1.0/this._height);
        };

        /**
        * Render the scene with its geometry.
        */
        FluxRenderer.prototype.doRender = function () {
            this._setHost();
            this._update();
            this._context.renderer.clear();
            if (this._multipass) {
                this._updatePasses();
                // render scene
                this._composer.render();
            } else {
                this._context.renderer.render(this._scene, this._cameras.getCamera());
                this._context.renderer.render(this._edgesScene, this._cameras.getCamera());
                this._context.renderer.render(this._helpersScene, this._cameras.getCamera());
            }
        };

        /**
         * Say whether there are any objects to render in the model
         * @return {Boolean} True if there are objects to render
         */
        FluxRenderer.prototype.anyValidPrims = function() {
            return this._model ? this._model.children.length > 0 : false;
        };

        /**
        * Set the light that is casting shadows.
        * @param {THREE.Light} light      light object, position is saved
        */
        FluxRenderer.prototype.setShadowLight = function(light) {
            // Enable shadows on this renderer
            this._multipass = true;
            this._showShadows = true;

            this._shadowLight = light.position;
            this._shadowBuilder.updateLight(light.position);
        };

        /**
         * Add the shadows for everything in the current model
         */
        FluxRenderer.prototype.addShadows = function() {
            var _this = this;
            this._model.traverse(function (obj) {
                if (obj && obj.geometry) {
                    _this.addShadow(obj);
                }
            });
        };
        /**
        * Add a shadow to the scene.
        * @param {THREE.Mesh} mesh        The mesh of the object casting a shadow
        */
        FluxRenderer.prototype.addShadow = function(mesh) {
            var shadow = this._shadowBuilder.getShadowVolume(mesh);
            this._shadowScene.add(shadow);
        };

        /**
        * Remove a shadow from the scene.
        * @param  {THREE.Mesh} mesh       The mesh of the shadow to remove
        */
        FluxRenderer.prototype.removeShadow = function(mesh) {
            var shadow = this._shadowBuilder.getShadowVolume(mesh);
            this._shadowScene.remove(shadow);
        };

        /**
         * Copy the image that is in the render canvas to this renderer's cache canvas.
         * This allows the rendered image to persist even when the renderer is not available.
         * This happens when the user moves the mouse away from this viewport to another one.
         * @private
         */
        FluxRenderer.prototype._cacheImageToCanvas = function () {
            this.doRender();
            this.ctx.drawImage(this._context.renderer.domElement, 0, 0, this._cacheCanvas.width, this._cacheCanvas.height);
        };

        /**
         * Get the canvas for use in QA scripts
         * @return {Canvas} WebGL canvas dom element
         */
        FluxRenderer.prototype.getGlCanvas = function() {
            return this._context.renderer.domElement;
        };

        /**
        * Migrate renderer.domElement to this host if necessary
        * and copy framebuffer into Canvas2D element of the previous host.
         * @private
        */
        FluxRenderer.prototype._setHost = function() {
            if (this === this._context.currentHost) return;
            if (this._context.currentHost) {
                // Copy the image from domElement (THREE's interactive canvas)
                // to the 2D context for this element's canvas
                // This image will remain up until the user interacts with the old viewport again
                this._context.currentHost._cacheImageToCanvas();
            }
            this._context.currentHost = this;
            this.setSize(this._width, this._height);
            // Move the THREE.WebGLRenderer's canvas under the new host
            this._domParent.appendChild(this._context.renderer.domElement);
        };

        /**
         * Set the WebGLRenderer parameters to match this renderer.
         * @private
         */
        FluxRenderer.prototype._update = function() {
            this._context.renderer.autoClearColor = this._multipass;
            this._context.renderer.autoClearDepth = this._multipass;
            this._context.renderer.setSize(this._width, this._height);
            this._context.renderer.setClearColor(this._clearColor);
        };

        /**
         * Set the size of things that are per viewport.
         * @param {Number} width  The canvas width in pixels
         * @param {Number} height The canvas height in pixels
         */
        FluxRenderer.prototype.setSize = function(width, height) {
            if (width <= 0 || height <= 0 || (width === this._width && height === this.height)) return;
            this._width = width;
            this._height = height;

            this._cameras.updateCamera(this._width, this._height);

            this._composer.setSize(this._width, this._height);

            this._cacheCanvas.height = height;
            this._cacheCanvas.width = width;
        };

        /**
         * Make serializable by pruning all references and building an object property tree
         * @return {Object} Data to stringify
         */
        FluxRenderer.prototype.toJSON = function() {
            var serializableState = {
                cameras: this._cameras.toJSON(), // camera pos and view
                controls: this._controls.toJSON() // center point
            };
            return serializableState;
        };

        /**
         * Take a data object and use it to update the internal state
         * @param  {Object} state The properties to set
         */
        FluxRenderer.prototype.fromJSON = function(state) {
            if (!state) return;
            if (state.cameras != null) {
                this.setView(state.cameras.view);
                this._cameras.fromJSON(state.cameras);
            }
            if (state.controls) {
                this._controls.fromJSON(state.controls);
            }
        };

        /**
         * The VectorManager class. It is an ObjectPool
         * for three js vectors. When the vectors are done
         * being used, they should be cleared
         *
         * @class VectorManager
         */
        function VectorManager () {
            this._vectorData = [];
            this._vectorCount = 0;
        }



        /**
         * Allocate a new vector with new or existing object.
         * The returned vector may have junk in its values
         *
         * @method alloc
         *
         * @return { THREE.Vector3 } The vector
         */
        VectorManager.prototype.alloc = function alloc () {
            var result;

            if ( this._vectorCount < this._vectorData.length ) result = this._vectorData[ this._vectorCount ];
            else {
                result = new THREE.Vector3();
                this._vectorData.push( result );
            }

            this._vectorCount += 1;

            return result;
        };



        /**
         * Deallocate all vectors and begin reallocating from the pool
         *
         * @method clear
         * @return { VectorManager } this
         */
        VectorManager.prototype.clear = function clear () {
            this._vectorCount = 0;
            return this;
        };



        /**
         * Allocate a new vector with the same values as an existing one
         *
         * @method clone
         * @return { THREE.Vector3 } The newly allocated vector
         *
         * @param { THREE.Vector3 } v The vector to copy
         */
        VectorManager.prototype.clone = function clone ( v ) {
            return this.alloc().copy( v );
        };


        /**
         * Create and allocate a vector from an array
         *
         * @method convert
         * @return { THREE.Vector3 } The newly allocated vector
         *
         * @param  {[Number]} arr Array of 3 numeric values
         */
        VectorManager.prototype.convert = function clone ( arr ) {
            return this.alloc().set( arr[0], arr[1], arr[2] );
        };

        var HALF_PI = Math.PI * 0.5;
        var TOLERANCE = 0.000001;
        var DEFAULT_ROTATION = new THREE.Vector3( HALF_PI, HALF_PI, 0 );
        var PLANE_DEFAULTS = {
                WIDTH: 10000,
                HEIGHT: 10000,
                WIDTH_SEGMENTS: 100,
                HEIGHT_SEGMENTS: 100
            };
        var CIRCLE_RES = 32;
        var DEG_2_RAD = Math.PI / 180;
        var MATERIAL_TYPES = {
            PHONG: 0,
            POINT: 1,
            LINE: 2
        };
        //----NURBS
        var NURBS_CURVE_QUALITY = 2.5;
        var NURBS_SURFACE_QUALITY = 2.5;
        // A NURBS surface with angles between the faces of its control hull below
        // this threshold will be considered flat
        var degreesFlatLimit = 1.0;
        var NURBS_FLAT_LIMIT = degreesFlatLimit/180.0;

        // These entities are not official Flux Entities, but can be rendered
        var NON_STANDARD_ENTITIES = 'stl obj text';

        // These are primitives that are recognized as geometry, but get special
        // treatment and do not have their own specific handler function in src/primitives
        var KNOWN_PRIMITIVES = ['point', 'polycurve', 'polysurface', 'brep', 'scene', 'revitElement'];

        // Enumeration of strings used as primitive types in scenes
        var SCENE_PRIMITIVES = {
            scene: 'scene',
            layer: 'layer',
            assembly: 'assembly',
            instance: 'instance',
            geometry: 'alphaGeometryContainer'
        };

        // For a face compare the angle between it's normals and those of
        // it's neighbors. If all the angles are smaller than the limit,
        // the face will be rendered smooth.
        // Range is from 0 (more faceted) to 180 (more smooth)
        var degreesSmoothLimit = 45;
        var NORMALS_SMOOTH_LIMIT = Math.cos(degreesSmoothLimit * DEG_2_RAD);

        var DEFAULT_POINT_COLOR = [0.5,0.5,0.8];
        var DEFAULT_LINE_COLOR =  [0.5,0.5,0.8];
        var DEFAULT_PHONG_COLOR = [  1,  1,  1];

        var POINT_PIXEL_SIZE = 2.0;
        var DEFAULT_MATERIAL_PROPERTIES = {
            // color is per point
            phong: {
                opacity: 1.0,
                //roughness: 1.0,  TODO this has to be translated to specular as in flux-materialUtil.html
                wireframe: false,
                side: THREE.DoubleSide
            },
            point: {
                size: 0.001,// This default helps with very small points coming from grasshopper in millimeters
                sizeAttenuation: true
            },
            line: {
                linewidth: 1.0
            }
        };

        var DEFAULT_UNITS = 'meters';
        var IMAGES_URL = 'https://object-library.storage.googleapis.com/image_based_lighting/park_filtered';

        function FluxGeometryError(message) {
            this.name = 'FluxGeometryError';
            this.message = message || 'Invalid or degenerate geometry specified.';
            this.stack = (new Error()).stack;
        }
        FluxGeometryError.prototype = Object.create(Error.prototype);
        FluxGeometryError.prototype.constructor = FluxGeometryError;

        /**************************************************************
         *	NURBS Utils
         **************************************************************/

        /*
        Finds knot vector span.

        p : degree
        u : parametric value
        U : knot vector

        returns the span
        */
        function findSpan( p,  u,  U ) {
        	var n = U.length - p - 1;

        	if (u >= U[n]) {
        		return n - 1;
        	}

        	if (u <= U[p]) {
        		return p;
        	}

        	var low = p;
        	var high = n;
        	var mid = Math.floor((low + high) / 2);

        	while (u < U[mid] || u >= U[mid + 1]) {

        		if (u < U[mid]) {
        			high = mid;
        		} else {
        			low = mid;
        		}

        		mid = Math.floor((low + high) / 2);
        	}

        	return mid;
        }


        /*
        Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

        span : span in which u lies
        u    : parametric point
        p    : degree
        U    : knot vector

        returns array[p+1] with basis functions values.
        */
        function calcBasisFunctions( span, u, p, U ) {
        	var N = [];
        	var left = [];
        	var right = [];
        	N[0] = 1.0;

        	for (var j = 1; j <= p; ++ j) {

        		left[j] = u - U[span + 1 - j];
        		right[j] = U[span + j] - u;

        		var saved = 0.0;

        		for (var r = 0; r < j; ++ r) {

        			var rv = right[r + 1];
        			var lv = left[j - r];
        			var temp = N[r] / (rv + lv);
        			N[r] = saved + rv * temp;
        			saved = lv * temp;
        		}

        		N[j] = saved;
        	}

        	return N;
        }


        /*
        Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

        p : degree of B-Spline
        U : knot vector
        P : control points (x, y, z, w)
        u : parametric point

        returns point for given u
        */
        function calcBSplinePoint( p, U, P, u ) {
        	var span = findSpan(p, u, U);
        	var N = calcBasisFunctions(span, u, p, U);
        	var C = new THREE.Vector4(0, 0, 0, 0);

        	for (var j = 0; j <= p; ++ j) {
        		var point = P[span - p + j];
        		var Nj = N[j];
        		var wNj = point.w * Nj;
        		C.x += point.x * wNj;
        		C.y += point.y * wNj;
        		C.z += point.z * wNj;
        		C.w += point.w * Nj;
        	}

        	return C;
        }


        /*
        Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

        span : span in which u lies
        u    : parametric point
        p    : degree
        n    : number of derivatives to calculate
        U    : knot vector

        returns array[n+1][p+1] with basis functions derivatives
        */
        function calcBasisFunctionDerivatives( span,  u,  p,  n,  U ) {

        	var i, j, k, r;

        	var zeroArr = [];
        	for (i = 0; i <= p; ++ i)
        		zeroArr[i] = 0.0;

        	var ders = [];
        	for (i = 0; i <= n; ++ i)
        		ders[i] = zeroArr.slice(0);

        	var ndu = [];
        	for (i = 0; i <= p; ++ i)
        		ndu[i] = zeroArr.slice(0);

        	ndu[0][0] = 1.0;

        	var left = zeroArr.slice(0);
        	var right = zeroArr.slice(0);

        	for (j = 1; j <= p; ++ j) {
        		left[j] = u - U[span + 1 - j];
        		right[j] = U[span + j] - u;

        		var saved = 0.0;

        		for (r = 0; r < j; ++ r) {
        			var rv = right[r + 1];
        			var lv = left[j - r];
        			ndu[j][r] = rv + lv;

        			var temp = ndu[r][j - 1] / ndu[j][r];
        			ndu[r][j] = saved + rv * temp;
        			saved = lv * temp;
        		}

        		ndu[j][j] = saved;
        	}

        	for (j = 0; j <= p; ++ j) {
        		ders[0][j] = ndu[j][p];
        	}

        	for (r = 0; r <= p; ++ r) {
        		var s1 = 0;
        		var s2 = 1;

        		var a = [];
        		for (i = 0; i <= p; ++ i) {
        			a[i] = zeroArr.slice(0);
        		}
        		a[0][0] = 1.0;

        		for (k = 1; k <= n; ++ k) {
        			var d = 0.0;
        			var rk = r - k;
        			var pk = p - k;

        			if (r >= k) {
        				a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        				d = a[s2][0] * ndu[rk][pk];
        			}

        			var j1 = (rk >= -1) ? 1 : -rk;
        			var j2 = (r - 1 <= pk) ? k - 1 :  p - r;

        			for (j = j1; j <= j2; ++ j) {
        				a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];
        				d += a[s2][j] * ndu[rk + j][pk];
        			}

        			if (r <= pk) {
        				a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];
        				d += a[s2][k] * ndu[r][pk];
        			}

        			ders[k][r] = d;

        			j = s1;
        			s1 = s2;
        			s2 = j;
        		}
        	}

        	r = p;

        	for (k = 1; k <= n; ++ k) {
        		for (j = 0; j <= p; ++ j) {
        			ders[k][j] *= r;
        		}
        		r *= p - k;
        	}

        	return ders;
        }


        /*
        Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

        p  : degree
        U  : knot vector
        P  : control points
        u  : Parametric points
        nd : number of derivatives

        returns array[d+1] with derivatives
        */
        function calcBSplineDerivatives( p,  U,  P,  u,  nd ) {
        	var du = nd < p ? nd : p;
        	var CK = [];
        	var span = findSpan(p, u, U);
        	var nders = calcBasisFunctionDerivatives(span, u, p, du, U);
        	var Pw = [];
        	var point;
        	var k;

        	for (var i = 0; i < P.length; ++ i) {
        		point = P[i].clone();
        		var w = point.w;

        		point.x *= w;
        		point.y *= w;
        		point.z *= w;

        		Pw[i] = point;
        	}
        	for (k = 0; k <= du; ++ k) {
        		point = Pw[span - p].clone().multiplyScalar(nders[k][0]);

        		for (var j = 1; j <= p; ++ j) {
        			point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
        		}

        		CK[k] = point;
        	}

        	for (k = du + 1; k <= nd + 1; ++ k) {
        		CK[k] = new THREE.Vector4(0, 0, 0);
        	}

        	return CK;
        }


        /*
        Calculate "K over I"

        returns k!/(i!(k-i)!)
        */
        function calcKoverI( k, i ) {
        	var nom = 1;
        	var j;

        	for (j = 2; j <= k; ++ j) {
        		nom *= j;
        	}

        	var denom = 1;

        	for (j = 2; j <= i; ++ j) {
        		denom *= j;
        	}

        	for (j = 2; j <= k - i; ++ j) {
        		denom *= j;
        	}

        	return nom / denom;
        }


        /*
        Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

        Pders : result of function calcBSplineDerivatives

        returns array with derivatives for rational curve.
        */
        function calcRationalCurveDerivatives ( Pders ) {
        	var nd = Pders.length;
        	var Aders = [];
        	var wders = [];
        	var i;

        	for (i = 0; i < nd; ++ i) {
        		var point = Pders[i];
        		Aders[i] = new THREE.Vector3(point.x, point.y, point.z);
        		wders[i] = point.w;
        	}

        	var CK = [];

        	for (var k = 0; k < nd; ++ k) {
        		var v = Aders[k].clone();

        		for (i = 1; i <= k; ++ i) {
        			v.sub(CK[k - i].clone().multiplyScalar(calcKoverI(k, i) * wders[i]));
        		}

        		CK[k] = v.divideScalar(wders[0]);
        	}

        	return CK;
        }


        /*
        Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

        p  : degree
        U  : knot vector
        P  : control points in homogeneous space
        u  : parametric points
        nd : number of derivatives

        returns array with derivatives.
        */
        function calcNURBSDerivatives( p,  U,  P,  u,  nd ) {
        	var Pders = calcBSplineDerivatives(p, U, P, u, nd);
        	return calcRationalCurveDerivatives(Pders);
        }


        /*
        Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.

        p1, p2 : degrees of B-Spline surface
        U1, U2 : knot vectors
        P      : control points (x, y, z, w)
        u, v   : parametric values

        returns point for given (u, v)
        */
        function calcSurfacePoint( p, q, U, V, P, u, v ) {
        	var uspan = findSpan(p, u, U);
        	var vspan = findSpan(q, v, V);
        	var Nu = calcBasisFunctions(uspan, u, p, U);
        	var Nv = calcBasisFunctions(vspan, v, q, V);
        	var temp = [];
        	var l;

        	for (l = 0; l <= q; ++ l) {
        		temp[l] = new THREE.Vector4(0, 0, 0, 0);
        		for (var k = 0; k <= p; ++ k) {
        			var point = P[uspan - p + k][vspan - q + l].clone();
        			var w = point.w;
        			point.x *= w;
        			point.y *= w;
        			point.z *= w;
        			temp[l].add(point.multiplyScalar(Nu[k]));
        		}
        	}

        	var Sw = new THREE.Vector4(0, 0, 0, 0);
        	for (l = 0; l <= q; ++ l) {
        		Sw.add(temp[l].multiplyScalar(Nv[l]));
        	}

        	Sw.divideScalar(Sw.w);
        	return new THREE.Vector3(Sw.x, Sw.y, Sw.z);
        }

        /**************************************************************
         *	NURBS curve
         *	knots Array of reals
         *	controlPoints Array of Vector(2|3|4)
         **************************************************************/

        function NURBSCurve ( degree, knots, controlPoints ) {

        	this.degree = degree;
        	this.knots = knots;
        	this.controlPoints = [];
        	for (var i = 0; i < controlPoints.length; ++ i) { // ensure Vector4 for control points
        		var point = controlPoints[i];
        		this.controlPoints[i] = new THREE.Vector4(point.x, point.y, point.z, point.w);
        	}
        	// Closed curves force their first span to be a single point. Since a
        	// span consists of a number of knots equal to the degree, we must skip
        	// the first knots to avoid extrapolation artifacts for parametric values
        	// outside the domain of the curve. iMin and iMax are integer Numbers that
        	// store the beginning and ending index which contain the renderable
        	// domain of the curve.
        	this.iMin = 0;
        	this.iMax = this.knots.length-1;
        	if (this.isClosed()) {
        		this.iMin = this.degree;
        		this.iMax = this.knots.length-1-this.degree;
        	}
        }


        NURBSCurve.prototype = Object.create( THREE.Curve.prototype );
        NURBSCurve.prototype.constructor = NURBSCurve;

        NURBSCurve.prototype.isClosed = function ( ) {
        	var start = this._getPointByParameter(this.knots[this.degree]);
        	var end = this._getPointByParameter(this.knots[this.knots.length-1-this.degree]);
        	start.sub(end);
        	var TOLERANCE = 0.000001;
        	return start.length() < TOLERANCE;
        };

        NURBSCurve.prototype.getPoint = function ( t ) {
        	var u = this.knots[this.iMin] + t * (this.knots[this.iMax] - this.knots[this.iMin]); // linear mapping t->u
        	return this._getPointByParameter(u);
        };

        NURBSCurve.prototype._getPointByParameter = function ( u ) {

        	// following results in (wx, wy, wz, w) homogeneous point
        	var hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);

        	if (hpoint.w != 1.0) { // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
        		hpoint.divideScalar(hpoint.w);
        	}

        	return new THREE.Vector3(hpoint.x, hpoint.y, hpoint.z);
        };


        NURBSCurve.prototype.getTangent = function ( t ) {

        	var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
        	var ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
        	var tangent = ders[1].clone();
        	tangent.normalize();

        	return tangent;
        };

        /*
         * helpers
         */

        var vec = new VectorManager(); // an ObjectPool for managing Three.js vectors

        /**
         * Creates a linear mesh from parasolid data and a material
         *
         * @function line
         *
         * @return { THREE.Mesh } The linear mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh
         */
        function line ( data, material ) {
            var geometry = new THREE.BufferGeometry(),
                vertices = new Float32Array( data.start.concat( data.end ) );

            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

            return new THREE.Line( geometry, material );
        }

        /**
         * Creates a mesh as a set of lines from parasolid data and a material
         *
         * @function polyline
         *
         * @return { THREE.Mesh } The mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh

         */
        function polyline ( data, material ) {

            var point;
            var pos = [];
            for ( var i = 0, len = data.points.length ; i < len ; i++ ) {
                point = data.points[ i ];
                pos.push(point[0]);
                pos.push(point[1]);
                pos.push(point[2]);
            }
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(pos), 3 ) );
            return new THREE.Line( geometry, material );
        }

        /**
         * Creates a circular line from parasolid data and a material
         *
         * @function circle
         *
         * @return { THREE.Line } The circular line
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh
         */
        function circle ( data, material ) {
            var r = data.radius;
            var numPoints = CIRCLE_RES;
            var vertices = new Float32Array( ( numPoints  ) * 3 );
            var i, x, y, t, dt;
            t = 0;
            dt = 2 * Math.PI / (numPoints-1);
            for (i = 0; i < vertices.length; i += 3, t += dt) {
                x = r * Math.cos(t);
                y = r * Math.sin(t);
                vertices[i  ] = x;
                vertices[i+1] = y;
                vertices[i+2] = 0;
            }

            // Create geometry and material
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

            return new THREE.Line(geometry, material);
        }

        /**
         * Creates a curve mesh from parasolid data and a material
         *
         * @function curve
         *
         * @return { THREE.Mesh } The curve mesh
         * @throws FluxGeometryError if nurbs are invalid
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh
         */
        function curve ( data, material ) {
            if ( !data.knots || !data.controlPoints )
                throw new FluxGeometryError( 'Curve is missing knots or control points.');

            var nurbsControlPoints = _createControlPoints( data );

            if ( data.knots.length !== nurbsControlPoints.length + data.degree + 1 )
                throw new FluxGeometryError( 'Number of uKnots in a NURBS curve should equal degree + N + 1, where N is the number ' +
                                 'of control points' );

            var numPoints = Math.max(Math.floor(nurbsControlPoints.length * data.degree * NURBS_CURVE_QUALITY),
                nurbsControlPoints.length-1);
            var vertices = data.degree > 1 ?
                new NURBSCurve( data.degree, data.knots, nurbsControlPoints ).getPoints( numPoints ) :
                nurbsControlPoints;
            var geometry = _bufferFromVertices(vertices);
            return new THREE.Line( geometry, material );

        }

        /**
         * Create a buffer geometry for a line from just it's vertices
         * @param  {Array.<THREE.Vector3>} vertices The list of points
         * @return {THREE.BufferGeometry}          Geometry containing the points
         */
        function _bufferFromVertices(vertices) {
            var pos = [];
            for (var i=0;i<vertices.length;i++) {
                var v = vertices[i];
                pos.push(v.x);
                pos.push(v.y);
                pos.push(v.z);
            }
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(pos), 3 ) );
            return geometry;
        }
        /**
         * Helper to create a set of control points from parasolid data
         *
         * @function _createControlPoints
         * @private
         *
         * @return { Array<Three.Vector4> } The array of vector 4s
         *
         * @param { Object }           data     Parasolid data
         */
        function _createControlPoints ( data ) {
            var controlPoints = data.controlPoints,
                result = [],
                i = 0,
                weights = data.weights,
                len = controlPoints.length,
                currentControlPoint;

            for ( ; i < len ; i++ ) {
                currentControlPoint = controlPoints[ i ];
                result.push(
                    new THREE.Vector4(
                        currentControlPoint[ 0 ],
                        currentControlPoint[ 1 ],
                        currentControlPoint[ 2 ],
                        weights ? weights[ i ] : 1
                    )
                );
            }

            return result;
        }

        /**
         * Creates a arc mesh from parasolid data and a material
         *
         * @function arc
         *
         * @return { THREE.Mesh } The arc mesh
         *
         * @throws FluxGeometryError if the data doesn't have a start, middle, or end property
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh

         */
        function arc ( data, material ) {
            var geometry,
                vertices;

            if (!data.start || !data.middle || !data.end) {
                throw new FluxGeometryError('Can not create arc due to incomplete definition.');
            }

            // Initialize vectors
            var a = vec.alloc().set(data.start[0], data.start[1], data.start[2]);
            var b = vec.alloc().set(data.middle[0], data.middle[1], data.middle[2]);
            var c = vec.alloc().set(data.end[0], data.end[1], data.end[2]);

            // Compute line segments
            var ab = vec.clone(b).sub(a);
            var bc = vec.clone(c).sub(b);

            // check for degenerate inputs
            if (ab.length() < TOLERANCE || bc.length() < TOLERANCE ||
                    1.0 - Math.abs(vec.clone(ab).normalize().dot(vec.clone(bc).normalize())) < TOLERANCE) {
                // when the arc is degenerate, just draw line segments
                vertices = new Float32Array( 9 );
                _setVecInArray(vertices, 0, a);
                _setVecInArray(vertices, 3, b);
                _setVecInArray(vertices, 6, c);
            }
            else { // arc is ok
                var abMid =  vec.alloc();
                _computeMidpoint(a, b, abMid);
                var bcMid =  vec.alloc();
                _computeMidpoint(b, c, bcMid);

                // compute perpendicular bisectors
                var up = vec.alloc().crossVectors(ab,bc).normalize();
                var abPerp = vec.alloc().crossVectors(ab,up).normalize();
                var bcPerp = vec.alloc().crossVectors(up,bc).normalize();

                // calculate intersection
                var center =  vec.alloc();
                _intersectLines(abMid, bcMid, abPerp, bcPerp, center);

                // determine line segment points
                vertices = _tessellateArc(a, c, ab, bc, center, up);
            }

            if (vertices.length <= 0) {
                throw new FluxGeometryError( 'Arc has no vertices');
            }

            // Create geometry and material
            geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

            vec.clear();

            return new THREE.Line(geometry, material);
        }

        /**
         * Computes the midpoint as the center of segment ab
         *
         * @function _computeMidpoint
         * @private
         *
         * @param { THREE.Vector3 } a        The first point
         * @param { THREE.Vector3 } b        The second point
         * @param { THREE.Vector3 } midPoint The midpoint
         */
        function _computeMidpoint ( a, b, midPoint ) {
            midPoint.copy( b );
            midPoint.sub( a );
            midPoint.multiplyScalar( 0.5 );
            midPoint.add( a );
        }

        /**
         * Caclulate an appropriate number of points along a given arc
         *
         * @function _tessellateArc
         * @private
         *
         * @return { Float32Array } List of coordinates
         *
         * @param { THREE.Vector3 } a First point along the arc
         * @param { THREE.Vector3 } c Third point on arc
         * @param { THREE.Vector3 } ab Segement from a to b
         * @param { THREE.Vector3 } bc Segement from b to c
         * @param { THREE.Vector3 } center Center of arc
         * @param { THREE.Vector3 } up Normal to plane containing the arc
         */
        function _tessellateArc ( a, c, ab, bc, center, up ) {
            // interpolate points on the curve and populate geometry
            var relA = vec.clone( a ).sub( center ),
                relC = vec.clone( c ).sub( center ),
                angle = relA.angleTo( relC ),
                angleABC = Math.PI - ab.angleTo( bc );

            if ( angleABC < Math.PI * 0.5 ) {
                angle = 2 * Math.PI - angle;
            }

            var numSections = Math.ceil( angle * ( 42 / ( 2 * Math.PI ) ) ),
                dTheta = angle / numSections,
                vertices = new Float32Array( ( numSections + 1  ) * 3 );

            for ( var i = 0 ; i <= numSections ; i++ ) {
                vertices[ i * 3 ] = relA.x + center.x;
                vertices[ i * 3 + 1 ] = relA.y + center.y;
                vertices[ i * 3 + 2 ] = relA.z + center.z;
                relA.applyAxisAngle( up, dTheta );
            }

            return vertices;
        }

        /**
         * Compute the intersection of two lines in 3D.
         * @Precondition The lines are not parallel, there is exactly 1 intersection.
         *
         * @function _intersectLines
         * @private
         *
         * @param  {THREE.Vector3} p0 Point on the first line
         * @param  {THREE.Vector3} p1 Point on the second line
         * @param  {THREE.Vector3} d0 Direciton of first line
         * @param  {THREE.Vector3} d1 Direction of second line
         * @param {THREE.Vector3} intersect Return parameter for intersection point
         */
        function _intersectLines (p0, p1, d0, d1, intersect) {
            // Mathematically this is solved by equating the parametric equations
            // of the two lines and solving for t at the time of their intersection
            // Equivalent equations can be made by substituting each component x, y and z
            // so we try each permutation in case one of them runs into divide by zero.
            // Each pair of elements in this array is one case to calculate.
            var cases = ['x', 'y', 'x', 'z', 'y', 'x',
                'y', 'z', 'z', 'x', 'z', 'y' ];
            var t0;
            var i = 0;
            var x;
            var y;
            while(!isFinite(t0) && i < cases.length) {
                x = cases[i];
                y = cases[i+1];
                // compute t from the formula
                t0 = (p0[x] - p1[x] - (p0[y] * d1[x]) / d1[y] + (p1[y] * d1[x]) / d1[y] ) /
                    ( (d0[y] * d1[x]) / d1[y] - d0[x]);
                    i += 2;
            }
            // calculate the intersection as a linear combination of the point and direction
            intersect.copy(d0).multiplyScalar(t0).add(p0);
        }

        /**
         * Add each element of a vector to an array
         * @param  {Array} arr Array of coordinates
         * @param  {Number} offset Index to start in array
         * @param  {THREE.Vector3} vec Vector of 3 values
         */
        function _setVecInArray (arr, offset, vec) {
            arr[offset] = vec.x;
            arr[offset+1] = vec.y;
            arr[offset+2] = vec.z;
        }

        /**
         * Creates a rectangular line from parasolid data and a material
         *
         * @function rectangle
         *
         * @return { THREE.Line } The rectangular line
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the mesh
         */
        function rectangle ( data, material ) {
            var dx = data.dimensions[0] * 0.5;
            var dy = data.dimensions[1] * 0.5;

            var numPoints = 5;
            var vertices = new Float32Array( ( numPoints  ) * 3 );
            vertices[0] = -dx;
            vertices[1] = dy;
            vertices[2] = 0;

            vertices[3] = dx;
            vertices[4] = dy;
            vertices[5] = 0;

            vertices[6] = dx;
            vertices[7] = -dy;
            vertices[8] = 0;

            vertices[9] = -dx;
            vertices[10] = -dy;
            vertices[11] = 0;

            vertices[12] = -dx;
            vertices[13] = dy;
            vertices[14] = 0;

            // Create geometry and material
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );

            return new THREE.Line(geometry, material);
        }

        /**
         * Creates a elliptic curve
         *
         * @function ellipse
         *
         * @return { THREE.Line } The shape
         *
         * @param { Object }           data     Parasolid entity data
         * @param { THREE.Material } material The material to give the mesh
         */
        function ellipse ( data, material ) {
            // Origin and axis are ignored here and applied later in cleanupMesh
            var curve = new THREE.EllipseCurve(
                0,  0,                              // center x, center y
                data.majorRadius, data.minorRadius, // xRadius, yRadius
                0,  2 * Math.PI,                    // aStartAngle, aEndAngle
                false,                              // aClockwise
                0                                   // aRotation
            );

            var path = new THREE.Path( curve.getPoints( CIRCLE_RES ) );
            var geometry = path.createPointsGeometry( CIRCLE_RES );
            var bufferGeometry = _bufferFromVertices(geometry.vertices);
            geometry.dispose();
            return new THREE.Line( bufferGeometry, material );
        }

        /**
         * Creates a vector THREE.Mesh from parasolid data and a material
         *
         * @function vector
         *
         * @return { THREE.Mesh } The vector THREE.Mesh
         *
         * @throws FluxGeometryError if vector has zero length
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function vector ( data, material ) {
            var dir = new THREE.Vector3( data.coords[ 0 ], data.coords[ 1 ], data.coords[ 2 ] );

            if ( dir.length() > 0 ) dir.normalize();
            else throw new FluxGeometryError( 'Vector primitive has length zero' );

            // The half width of the arrow
            var d = 0.03;
            // The length of the arrow
            var l = 1;
            // This is the coordinate of the base of the head
            var c = 0.85;
            var verticesArr = [
                // Main axis
                0,0,0,
                0,0,l,
                // Cap the head
                d,d,c,
                d,-d,c,
                0,0,1,
                -d,d,c,
                -d,-d,c,
                0,0,l,
                d,-d,c,
                -d,-d,c,
                0,0,l,
                d,d,c,
                -d,d,c
            ];

            var vertices = new Float32Array( verticesArr );
            // Create geometry and material
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
            var mesh = new THREE.Line(geometry, material);
            mesh.lookAt(dir);
            return mesh;
        }

var wirePrimitives = Object.freeze({
            line: line,
            polyline: polyline,
            circle: circle,
            curve: curve,
            arc: arc,
            rectangle: rectangle,
            ellipse: ellipse,
            vector: vector
        });

        /**************************************************************
         *	NURBS surface
         *	knots2 Arrays of reals
         *	controlPoints array^2 of Vector(2|3|4)
         **************************************************************/

        function NURBSSurface ( degree1, degree2, knots1, knots2 , controlPoints ) {
        	this.degree1 = degree1;
        	this.degree2 = degree2;
        	this.knots1 = knots1;
        	this.knots2 = knots2;
        	this.controlPoints = [];

        	var len1 = knots1.length - degree1 - 1;
        	var len2 = knots2.length - degree2 - 1;

        	// ensure Vector4 for control points
        	for (var i = 0; i < len1; ++ i) {
        		this.controlPoints[i] = [];
        		for (var j = 0; j < len2; ++ j) {
        			var point = controlPoints[i][j];
        			this.controlPoints[i][j] = new THREE.Vector4(point.x, point.y, point.z, point.w);
        		}
        	}
        	// Closed surfaces force their first span to be a single point. Since a
        	// span consists of a number of knots equal to the degree, we must skip
        	// the first knots to avoid extrapolation artifacts for parametric values
        	// outside the domain of the curve. iMin and iMax are integer Numbers that
        	// store the beginning and ending index which contain the renderable
        	// domain of the curve.
        	this.iMin1 = 0;
        	this.iMax1 = this.knots1.length-1;
        	if (this.isClosed(this.knots1, this.degree1)) {
        		this.iMin1 = this.degree1;
        		this.iMax1 = this.knots1.length-1-this.degree1;
        	}
        	this.iMin2 = 0;
        	this.iMax2 = this.knots2.length-1;
        	if (this.isClosed(this.knots2, this.degree2)) {
        		this.iMin2 = this.degree2;
        		this.iMax2 = this.knots2.length-1-this.degree2;
        	}
        }

        NURBSSurface.prototype.isClosed = function ( knots, degree ) {
        	var start1 = this._getPointByParameters(knots[degree][0]);
        	var end1 = this._getPointByParameters(knots[knots.length-1-degree][0]);
        	start1.sub(end1);
        	var TOLERANCE = 0.000001;
        	return start1.length() < TOLERANCE;
        },

        NURBSSurface.prototype.getPoint = function ( t1, t2 ) {
        	var u = this.knots1[this.iMin1] + t1 * (this.knots1[this.iMax1] - this.knots1[this.iMin1]); // linear mapping t1->u
        	var v = this.knots2[this.iMin2] + t2 * (this.knots2[this.iMax2] - this.knots2[this.iMin2]); // linear mapping t2->u
        	return this._getPointByParameters(u, v);
        };
        NURBSSurface.prototype._getPointByParameters = function ( u, v ) {
        	return calcSurfacePoint(this.degree1, this.degree2, this.knots1, this.knots2, this.controlPoints, u, v);
        };

        /**
         * Merge a list of buffer geometries into a new one.
         * The old two will be disposed, so they can be garbage collected.
         * @param  {Array.<THREE.Object3D>} meshes A list of meshes containing geometry to merge
         * @return {THREE.BufferGeometry}       The merged result.
         */
        function mergeBufferGeom(meshes) {
            var i, m, geom2;
            var geometry = new THREE.BufferGeometry();
            var geom1 = meshes[0].geometry;

            // Split all indexed geometry so we don't need it anymore
            for (m=0;m<meshes.length;m++) {
                geom2 = meshes[m].geometry;
                if (geom2.index) {
                    // throw new FluxGeometryError('Not expecting indexed geometry.');
                    meshes[m].geometry = splitVertices(geom2);
                }
                geom2 = meshes[m].geometry;
                if (!geom2.attributes.normal) {
                    meshes[m].geometry = computeNormals(geom2);
                }
            }

            // for each attribute
            for ( var key in geom1.attributes ) {
                // Don't care about uv and other stuff
                if (key !== 'color' && key !== 'position' && key !== 'normal') continue;

                var data = [];
                // for each geometry
                for (m=0;m<meshes.length;m++) {
                    geom2 = meshes[m].geometry;
                    if (!geom2.attributes[key]) {
                        throw new FluxGeometryError('Mismatched geometry attributes: '+key);
                    }

                    var attributeArray2 = geom2.attributes[key].array;
                    for ( i = 0; i < attributeArray2.length; i ++ ) {
                        data.push(attributeArray2[i]);
                    }
                } // end for each geom
                geometry.addAttribute(key, new THREE.BufferAttribute(new Float32Array(data), geom1.attributes[key].itemSize));
            } // end for each attr

            for (m=0;m<meshes.length;m++) {
                meshes[m].geometry.dispose();
            }

            return geometry;
        }

        /**
         * Make sure that the buffer geometry has an index array and it is of the right type
         * @param  {THREE.BufferGeometry} geom The geometry to check
         */
        function _ensureIndex(geom) {
            var i;
            if (!geom.index) {
                var pos = geom.attributes.position.array;
                var index = [];
                for (i=0;i<pos.length/3;i++) {
                    index.push(i);
                }
                geom.setIndex(new THREE.BufferAttribute(new Uint32Array(index), 1));
            } else if (!geom.index.array.constructor instanceof Uint32Array) {
                geom.index.array = Uint32Array.from(geom.index.array);
            }
        }


        /**
         * Checks for duplicate vertices with hashmap.
         * Faces with duplicate vertices are rewired to point to the first instance.
         * This is a fork of THREE.Geometry.mergeVertices that has been adapted to work on buffer geometry.
         * @param  {THREE.BufferGeometry} geom Geometry to clean
         */
        function mergeVertices(geom) {
            _ensureIndex(geom);
            var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
            var changes = {};
            var vx, vy, vz, key;
            var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
            var precision = Math.pow( 10, precisionPoints );
            var i, il, j;

            var pos = geom.attributes.position.array;
            var index = geom.index.array;

            // for each vertex
            for ( i = 0, il = pos.length; i < il; i += 3) {
                vx = pos[i];
                vy = pos[i+1];
                vz = pos[i+2];
                key = Math.round( vx * precision ) + '_' + Math.round( vy * precision ) + '_' + Math.round( vz * precision );
                if ( verticesMap[ key ] === undefined ) {
                    verticesMap[ key ] = i;
                } else {
                    j = verticesMap[key];
                    changes[i] = j;
                }
            }
            // Re-index faces to uses the first possible index when points overlap.
            // Could cause degenerate faces.
            for ( i = 0, il = index.length; i < il; i++) {
                var idx = index[i]*3;
                if (changes[idx]!=null) {
                    index[i] = Math.floor(changes[idx]/3);
                }
            }

        }

        /**
         * Split the faces of an indexed buffer geometry
         * This creates attribute arrays that are populated per face vertex allowing
         * it to have sharp changes in attributes and not need an index array.
         * @param  {THREE.BufferGeometry} geom The indexed geometry to split
         * @return {THREE.BufferGeometry}      A modified clone or the original geometry
         */
        function splitVertices(geom) {
            var geometry = new THREE.BufferGeometry();
            if (!geom.index) return geom;
            var i, j, il, idx;
            var index = geom.index.array;
            // for each attribute
            for ( var key in geom.attributes ) {
                if (geom.attributes[key].array.constructor !== Float32Array) continue;
                var attr = geom.attributes[key].array;
                var size = geom.attributes[key].itemSize
                var values = new Float32Array(index.length*size);
                for ( j=0, i=0, il=index.length; i < il; i++) {
                    idx = index[i]*size;
                    for ( var k = 0; k < size; k ++ ) {
                        values[ i*size + k ] = attr[ idx + k ];
                    }
                }
                geometry.addAttribute( key, new THREE.BufferAttribute( values, size ) );
            }
            geom.dispose();
            return geometry;
        }

        /**
         * Compute good looking normal vectors for geometry.
         * Preserve sharp creases, but allow smoothing in low curvature areas.
         * @param  {THREE.Geometry|THREE.BufferGeometry} geometry The geometry in need of normals.
         * @return {THREE.Geometry|THREE.BufferGeometry}          The geometry, or a clone if the original was replaced
         */
        function computeNormals ( geometry ) {
            var newGeom = geometry;
            // Buffer geometry needs to be treated differently
            // with a lot of custom functions that are missing from THREE.js
            if (geometry instanceof THREE.BufferGeometry) {

                // The first step is to expand the buffer to accommodate every triangle
                // with unique face vertices (no shared vertex between triangles).
                // This gives the most flexibility, since indexed buffer geometry affords
                // too much blending, and does not allow the necessary sharp creases.
                newGeom = splitVertices(geometry);

                // Just get the normals per triangle to be used in the cusp calculation
                _computeFlatFaceNormals(newGeom);

                // Re-index the geometry merging triangles that have shared vertices.
                // I know we just blew them away, but now we have the full list of triangles
                // so we can store normals per triangle, but also have the connectivity information
                // implicitly by the indexing scheme
                mergeVertices(newGeom);

                // Calculate vertex normals from a weighted average of neighboring faces' normals
                _computeBufferCuspNormals(newGeom, NORMALS_SMOOTH_LIMIT);

                // Now we want to render as un-indexed geometry, and we already have the
                // points split, so we can just drop the index attribute, and keep our
                // newly calculated connectivity aware normals
                newGeom = _unmergeVertices(newGeom);

            } else {
                geometry.mergeVertices();
                geometry.computeFaceNormals();
                _computeCuspNormals(geometry, NORMALS_SMOOTH_LIMIT);
            }
            return newGeom;
        }

        function _unmergeVertices(geom) {
            var geometry = new THREE.BufferGeometry();
            geometry.addAttribute( 'position', geom.attributes.position);
            if (geom.attributes.normal) {
                geometry.addAttribute( 'normal', geom.attributes.normal);
                var n = geometry.attributes.normal.array;
                for (var i=0;i<n.length;i++) {
                    if (isNaN(n[i])) {
                        n[i] = 0;
                    }
                }
            } else {
                geometry.addAttribute( 'normal', geom.attributes.faceNormal);
            }
            if (geom.attributes.uv) {
                geometry.addAttribute( 'uv', geom.attributes.uv);
            }
            geom.dispose();
            return geometry;
        }


        /**
         * Compute optimal normals from face and vertex normals
         *
         * @param  {Three.Geometry} geom  The geometry in need of normals
         * @param  {Number} thresh        Threshold for switching to vertex normals
         */
        function _computeCuspNormals( geom, thresh ) {
            var v, vl, f, fl, face, vertexToFaces, faceNormals;
            // List of all the co-incident faces, indexed by [v][f]
            // Stores a pair of a face index and a vertex index on a face
            vertexToFaces = [];

            for ( v = 0, vl = geom.vertices.length; v < vl; v ++ ) {
                vertexToFaces[v] = [];
            }

            faceNormals = [];
            // Add the face normals as vertex normals
            for ( f = 0, fl = geom.faces.length; f < fl; f ++ ) {
                face = geom.faces[ f ];
                faceNormals.push([]);
                faceNormals[f][0] = new THREE.Vector3();
                faceNormals[f][1] = new THREE.Vector3();
                faceNormals[f][2] = new THREE.Vector3();
                vertexToFaces[face.a].push([f,0]);
                vertexToFaces[face.b].push([f,1]);
                vertexToFaces[face.c].push([f,2]);
            }

            // Convert triangle index scheme from a b c to 1 2 3
            var iToAbc = ['a', 'b', 'c'];
            // For each face
            for ( f = 0, fl = geom.faces.length; f < fl; f ++ ) {
                face = geom.faces[ f ];
                // For each vertex on the face
                for (var i=0; i<3; i++) {
                    var faceAbc = face[iToAbc[i]];
                    // For each face neighboring the vertex
                    for ( v = 0, vl = vertexToFaces[faceAbc].length; v < vl; v ++ ) {
                        // look up normal by face, and vertex and add if within threshold
                        var faceIndex = vertexToFaces[faceAbc][v][0];
                        var fN = geom.faces[faceIndex].normal;
                        if (face.normal.dot(fN) > thresh) {
                            faceNormals[faceIndex][vertexToFaces[faceAbc][v][1]].add(face.normal);
                        }
                    }
                }
            }

            // Normalize the normals to unit length
            for ( f = 0, fl = faceNormals.length; f < fl; f ++ ) {
                for (v=0;v<faceNormals[f].length;v++) {
                    faceNormals[f][v].normalize();
                }
            }

            // Apply the normals to the faces
            for ( f = 0, fl = geom.faces.length; f < fl; f ++ ) {
                face = geom.faces[ f ];
                // Apply vertex normals if the face is not flat
                if (faceNormals[f][0].distanceToSquared(faceNormals[f][1]) > TOLERANCE ||
                    faceNormals[f][1].distanceToSquared(faceNormals[f][2]) > TOLERANCE) {
                    var vertexNormals = face.vertexNormals;
                    vertexNormals[0] = faceNormals[f][0].clone();
                    vertexNormals[1] = faceNormals[f][1].clone();
                    vertexNormals[2] = faceNormals[f][2].clone();
                }
            }
        }

        /**
         * Compute one normal vector per face and apply to each face vertex
         * @param  {THREE.BufferGeometry} geom Geometry in need of normals
         */
        function _computeFlatFaceNormals(geom) {
            var pos = geom.attributes.position.array;
            var attrName = 'normal';
            if ( geom.attributes[attrName] === undefined ) {
                geom.addAttribute( attrName, new THREE.BufferAttribute( new Float32Array( pos.length ), 3 ) );
            }
            var n = geom.attributes[attrName].array;
            var i, v, il;
            var cb = new THREE.Vector3();
            var ab = new THREE.Vector3();
            for (i=0, il=pos.length;i<il;i+=9) {

                var iA = i;
                var iB = i+3;
                var iC = i+6;

                cb.set(pos[iC  ]-pos[iB  ],
                       pos[iC+1]-pos[iB+1],
                       pos[iC+2]-pos[iB+2]);
                ab.set(pos[iA  ]-pos[iB  ],
                       pos[iA+1]-pos[iB+1],
                       pos[iA+2]-pos[iB+2]);
                cb.cross( ab );
                cb.normalize();

                var face = [iA,iB,iC];
                // For each vertex on the face
                for (v=0; v<3; v++) {
                    var faceAbc = face[v];
                    n[faceAbc  ] = cb.x;
                    n[faceAbc+1] = cb.y;
                    n[faceAbc+2] = cb.z;
                }
            }
        }

        // Optimization: These variables are only allocated once and made unique by rollup namespacing
        var gFaceN = new THREE.Vector3();
        var gNeighborFaceN = new THREE.Vector3();
        var gTmpN = new THREE.Vector3();
        // Temporary normals buffer to use for accumulation
        var gFaceNormals = new Float32Array(900);

        /**
         * Calculate nice looking normal vectors for a buffer geometry
         * Precondition: Normal attribute contains flat face normals
         * Precondition: Buffer geometry has a vertex for each face vertex and has been indexed to map shared vertices
         * @param  {THREE.BufferGeometry} geom   The geometry to use
         * @param  {Number} thresh  Threshold for smooth or sharp normals
         */
        function _computeBufferCuspNormals(geom, thresh) {

            var i, il, v, vl, f, fl, faceAbc, vertexToFaces, faceIndex;
            // Just allocate a constant number of

            var normals = geom.attributes.normal.array;
            var faces = geom.index.array;

            vertexToFaces = {};
            _linkFaces(vertexToFaces, faces);

            _resetNormalBuffer(normals);

            // Accumulate the normals
            // For each face
            for ( f = 0, fl = faces.length; f < fl; f+=3 ) {
                gFaceN.set(normals[f*3],
                          normals[f*3+1],
                          normals[f*3+2]);
                // For each vertex on the face
                for (i=0; i<3; i++) {
                    faceAbc = faces[f+i];
                    // For each face neighboring the vertex
                    for ( v = 0, vl = vertexToFaces[faceAbc].length; v < vl; v ++ ) {
                        // look up normal by face, and vertex and add if within threshold
                        faceIndex = vertexToFaces[faceAbc][v][0];
                        // Get the smooth and flat normal from the current face
                        gNeighborFaceN.set(normals[faceIndex*3],
                                          normals[faceIndex*3+1],
                                          normals[faceIndex*3+2]);
                        var delta = gFaceN.dot(gNeighborFaceN);
                        if (delta > thresh) {
                            // append the normal to the cumulation for the neighboring face
                            var faceI = 3*(faceIndex+vertexToFaces[faceAbc][v][1]);
                            gTmpN.set(gFaceNormals[faceI+0],gFaceNormals[faceI+1],gFaceNormals[faceI+2]).add(gFaceN);
                            gFaceNormals[faceI  ] = gTmpN.x;
                            gFaceNormals[faceI+1] = gTmpN.y;
                            gFaceNormals[faceI+2] = gTmpN.z;
                        }
                    }
                }
            }

            _normalizeNormals(gFaceNormals, normals.length, gTmpN);

            // Apply the normals
            for ( i=0, il=normals.length; i < il; i++) {
                normals[i] = gFaceNormals[i];
            }
        }

        /**
         * Resize or clear the reused normal buffer
         * @param  {Float32Array} normals      The reference buffer for length
         */
        function _resetNormalBuffer(normals) {
            // Allocate a bigger array if necessary
            if (gFaceNormals.length < normals.length) {
                gFaceNormals = new Float32Array(normals.length);
            } else { // clear the array
                for (var i=0, il=normals.length; i < il; i++) {
                    gFaceNormals[i] = 0;
                }
            }
        }

        /**
         * Create an array of face adjacencies
         * @param  {Object} vertexToFaces List of all the co-incident faces, indexed by [v][f]
         *                                Stores a pair of a face index and a vertex index on a face
         * @param  {UInt32Array} faces    List of face offsets
         */
        function _linkFaces(vertexToFaces, faces) {
            var i, f, fl, face, faceAbc;

            // Add the face normals as vertex normals
            for ( f = 0, fl = faces.length; f < fl; f+=3 ) {
                face = [faces[f],faces[f+1],faces[f+2]];
                // For each vertex on the face
                for (i=0; i<3; i++) {
                    faceAbc = face[i];
                    if (!vertexToFaces[faceAbc]) {
                        vertexToFaces[faceAbc]=[];
                    }
                    vertexToFaces[faceAbc].push([f,i]);
                }
            }
        }

        /**
         * Normalize the given list of vectors
         * @param  {Float32Array}   faceNormals The normal vector data
         * @param  {Number}         length      The length of the data array (it is reused so this might be different than the actual length in memory)
         * @param  {THREE.Vector3}  tmpN        Pre allocated vector limits need for garbage collection
         */
        function _normalizeNormals(faceNormals, length, tmpN) {
            var f, fl;
            // Normalize the normals to unit length
            for ( f = 0, fl = length; f < fl; f +=3 ) {
                tmpN.set(faceNormals[f+0],faceNormals[f+1],faceNormals[f+2]).normalize();
                faceNormals[f  ] = tmpN.x;
                faceNormals[f+1] = tmpN.y;
                faceNormals[f+2] = tmpN.z;
            }
        }

        /*
         * helpers
         */

        var vec$1 = new VectorManager(); // an ObjectPool for managing Three.js vectors

        /**
         * Convert a flux json polygon to an object with THREE Vector3 coordinates
         *
         * @function _polygonToThree
         *
         * @return {Object}         The new converted polygon
         *
         * @param  {Object} polygon The Flux JSON polygon to convert
         */
        function _polygonToThree(polygon) {
            var polygonThree = {boundary: [], holes: []};
            _pointArrayToThree(polygonThree.boundary, polygon.boundary);
            if (!polygon.holes) return polygonThree;
            for (var i=0, len=polygon.holes.length; i<len; i++) {
                var holeThree = [];
                polygonThree.holes.push(holeThree);
                _pointArrayToThree(holeThree, polygon.holes[i]);
            }
            return polygonThree;
        }

        /**
         * Convert an array of triples of numbers into an array of THREE.Vector3
         * @param  {Array.<THREE.Vector3>} pointsThree Destination
         * @param  {Array.<[Number,Number,Number]>} pointsArray Source
         */
        function _pointArrayToThree(pointsThree, pointsArray) {
            for (var i=0, len=pointsArray.length; i<len; i++) {
                pointsThree.push(vec$1.convert(pointsArray[i]));
            }
        }

        /**
         * Creates a THREE.Mesh as a set of polygons from parasolid data and a material
         *
         * @function polygonSet
         *
         * @return { THREE.Mesh } The THREE.Mesh
         *
         *  @throws FluxGeometryError if polygon is non planar
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function polygonSet ( data, material ) {

            // TODO check for degeneracy (such as collocated points)
            // TODO check for winding order (holes should match boundary)
            var p = vec$1.alloc();
            var n = vec$1.alloc();
            var u = vec$1.alloc();
            var v = vec$1.alloc();

            // Loop over all shapes and holes
            for (var i=0, len=data.polygons.length; i<len; i++) {

                var polygon = _polygonToThree(data.polygons[i]);

                _computePointBasis(p, n, u, v, polygon.boundary);

                var p0 = vec$1.clone(polygon.boundary[0]);

                // Polygon must be planar
                if (!_isPlanarPolygon(polygon, n, p0)) {
                    throw new FluxGeometryError('Non planar polygon in polygonSet');
                }

                //TODO convert the remaining code to use polygon
                var polygon2d = { boundary: [], holes: []};
                _reduceCoordinates(polygon2d.boundary, polygon.boundary, u, v, p0);
                if (polygon.holes) {
                    for (var j=0, jLen = polygon.holes.length; j<jLen; j++) {
                        polygon2d.holes.push([]);
                        _reduceCoordinates(polygon2d.holes[j], polygon.holes[j], u, v, p0);
                    }
                }
                // Build the triangulated shape
                var geometry = _makeShapeGeometry(polygon2d);

                _restoreCoordinates(geometry, p, u, v);
            }
            var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);
            geometry.dispose();
            return new THREE.Mesh( bufferGeometry, material );
        }

        /**
         * Check if an array of points is on a given plane
         * @param  {Array.<THREE.Vector3>}  pointsThree List of point objects
         * @param  {THREE.Vector3}  n       Normal vector
         * @param  {THREE.Vector3}  p0      Point on the plane
         * @return {Boolean}                True when the points are on the plane
         */
        function _isPlanarArray (pointsThree, n, p0) {
            var pointRel = vec$1.alloc();
            for (var i=0, len=pointsThree.length; i<len; i++) {
                pointRel.copy(pointsThree[i]).sub(p0);
                if (Math.abs(pointRel.dot(n))>TOLERANCE) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Check if a polygon is flat.
         * @param  {Object}  polyThree Polygon with points as objects
         * @param  {THREE.Vector3}  n       Normal vector
         * @param  {THREE.Vector3}  p0      Point on the plane
         * @return {Boolean}           True if the polygon and it's holes are planar
         */
        function _isPlanarPolygon(polyThree, n, p0) {
            var planar = _isPlanarArray(polyThree.boundary, n, p0);
            if (!polyThree.holes) return planar;
            for (var i=0, len=polyThree.holes.length; i<len && planar; i++) {
                if (!_isPlanarArray(polyThree.holes[i], n, p0)) {
                    planar = false;
                }
            }
            return planar;
        }

        /**
         * Convert planar three dimensional points to a two dimensional coordinate system.
         * @param  {[]} destPoints Array to hold output
         * @param  {[]} srcPoints  Source array of points
         * @param  {THREE.Vector3} u          Coordinate basis first direction
         * @param  {THREE.Vector3} v          Coordinate basis second direction
         * @param  {THREE.Vector3} p0         Point on the polygon
         */
        function _reduceCoordinates(destPoints, srcPoints, u, v, p0) {
            var p = vec$1.alloc();
            var s, t;
            for (var i=0, len=srcPoints.length; i<len; i++) {
                p.copy(srcPoints[i]).sub(p0);

                s = p.dot(u);
                t = p.dot(v);
                destPoints.push(vec$1.alloc().set(s, t, 0));
            }
        }

        /**
         * Convert 2D coordinates back to world space 3D.
         * This modifies the vertex positions in place.
         * @param  {THREE.Geometry} geometry The geometry to transform
         * @param  {THREE.Vector3} p        The origin point on the polygon
         * @param  {THREE.Vector3} u        The first basis direction.
         * @param  {THREE.Vector3} v        The second basis direction.
         */
        function _restoreCoordinates(geometry, p, u, v) {
            var uTmp = vec$1.alloc();
            var vTmp = vec$1.alloc();
            for ( var i = 0, len = geometry.vertices.length ; i < len ; i++ ) {

                var vert = geometry.vertices[i];
                var s = vert.x;
                var t = vert.y;
                uTmp.copy(u);
                vTmp.copy(v);

                vert.copy(p);
                vert.add(uTmp.multiplyScalar(s));
                vert.add(vTmp.multiplyScalar(t));
            }
            geometry.verticesNeedUpdate = true;
        }

        /**
         * Compute a coordinate system for the given set of points
         * @param  {THREE.Vector3} p      Return vector for a point on the polygon
         * @param  {THREE.Vector3} n      Return vector for the polygon normal
         * @param  {THREE.Vector3} u      Return vector for the polygon basis first direction
         * @param  {THREE.Vector3} v      Return vector for the polygon basis second direction
         * @param  {Array.<Array.<Number>>} points The points defining the polygon
         */
        function _computePointBasis(p, n, u, v, points) {
            n.set(0,0,1);
            if (points.length < 3) {
                return;
            }
            p.copy(points[0]);

            //TODO check memory allocation (would be large for many polygons)
            var v0 = vec$1.alloc().copy(points[0]);
            u.copy(points[1]);
            v.copy(points[points.length-1]);

            u.sub(v0).normalize();
            v.sub(v0).normalize();

            n.crossVectors(u, v).normalize();
            v.crossVectors(n, u).normalize();
        }

        /**
         * Make THREE.geometry from a flux JSON polygon object.
         * The polygon is like a flux JSON object, but actually
         * the points have all been converted from arrays to Vector3 objects.
         * @param  {Object} polygon Flux JSON polygon
         * @return {THREE.ShapeGeometry}         The renderable geometry.
         */
        function _makeShapeGeometry(polygon) {

            var shape = _makeShape( polygon.boundary );

            _makeShapeHoles(shape, polygon.holes);

            var geometry = new THREE.ShapeGeometry( shape );

            geometry.computeBoundingSphere();
            computeNormals(geometry);

            return geometry;
        }

        /**
         * Process each hole as a shape to convert it.
         * @param  {Object} shape The shape to contain the converted holes
         * @param  {Object} holes The list of holes
         */
        function _makeShapeHoles(shape, holes) {
            for (var i=0, len=holes.length; i<len; i++) {
                var hole = _makeShape( holes[i] );
                shape.holes.push(hole);
            }
        }

        /**
         * Create a shape object from a list of points
         * @param  {Array.<THREE.Vector3>} boundary The points to process
         * @return {THREE.Shape}          Shape object representing the polygon
         */
        function _makeShape(boundary) {

            var shape = new THREE.Shape();
            for ( var i = 0, len = boundary.length ; i < len ; i++ ) {
                shape.moveTo( boundary[i].x, boundary[i].y );
            }
            return shape;
        }

        /**
         * Calculate the maximum curvature across a surface geometry
         * The curvature is computed for each face compared to it's neighbors
         * and then the maximum angle is the result.
         * @param {THREE.Geometry} geom The surface
         * @returns {number} The normalized curvature between 0 and 1
         * @private
         */
        function _calcMaxCurvature(geom) {

            var v, vl, f, fl, face, vertexToFaces;
            // List of all the co-incident faces, indexed by [v][f]
            // Stores a pair of a face index and a vertex index on a face
            vertexToFaces = [];

            for ( v = 0, vl = geom.vertices.length; v < vl; v ++ ) {
                vertexToFaces[v] = [];
            }

            // Add the face normals as vertex normals
            for ( f = 0, fl = geom.faces.length; f < fl; f ++ ) {
                face = geom.faces[ f ];
                vertexToFaces[face.a].push([f,0]);
                vertexToFaces[face.b].push([f,1]);
                vertexToFaces[face.c].push([f,2]);
            }
            var invPi = 1.0 / Math.PI;
            var maxCurvature = 0;
            // Convert triangle index scheme from a b c to 1 2 3
            var iToAbc = ['a', 'b', 'c'];
            // For each face
            for ( f = 0, fl = geom.faces.length; f < fl; f ++ ) {
                face = geom.faces[ f ];
                // For each vertex on the face
                for (var i=0; i<3; i++) {
                    var faceAbc = face[iToAbc[i]];
                    // For each face neighboring the vertex
                    for ( v = 0, vl = vertexToFaces[faceAbc].length; v < vl; v ++ ) {
                        // look up normal by face, and vertex and add if within threshold
                        var faceIndex = vertexToFaces[faceAbc][v][0];
                        var curvature = invPi * face.normal.angleTo(geom.faces[faceIndex].normal);
                        if (curvature > maxCurvature) {
                            maxCurvature = curvature;
                        }
                    }
                }
            }

            return maxCurvature;
        }
        /**
         * Creates a surface THREE.Mesh from parasolid data and a material
         *
         * @function surface
         *
         * @return { THREE.Mesh } The THREE.Mesh
         *
         * @throws FluxGeometryError if nurbs definition is invalid
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh

         */
        function surface ( data, material ) {
            if (!data || !data.controlPoints) {
                throw new FluxGeometryError('Data must exist and have controlPoints');
            }
            var j, len2, controlPointRow, point, arr;
            var nsControlPoints = [];
            var controlPoints = data.controlPoints;
            var i = 0;
            var len = controlPoints.length;

            // For each control point
            for ( ; i < len ; i++ ) {
                arr = [];
                nsControlPoints.push( arr );
                controlPointRow = controlPoints[ i ];
                for ( j = 0, len2 = controlPointRow.length ; j < len2 ; j++ ) {
                    point = controlPointRow[ j ];
                    arr.push(
                        new THREE.Vector4(
                            point[ 0 ], point[ 1 ], point[ 2 ],
                            data.weights ? data.weights[ j * len + i ] : 1
                        )
                    );
                }
            }

            if ( data.uKnots.length !== nsControlPoints[ 0 ].length + data.uDegree + 1 )
                throw new FluxGeometryError( 'Number of uKnots in a NURBS surface should equal uDegree + N + 1' +
                                 ', where N is the number of control points along U direction' );

            if ( data.vKnots.length !== nsControlPoints.length + data.vDegree + 1 )
                throw new FluxGeometryError( 'Number of vKnots in a NURBS surface should equal vDegree + N + 1' +
                                 ', where N is the number of control points along V direction' );

            var nurbsSurface = new NURBSSurface( data.vDegree, data.uDegree, data.vKnots, data.uKnots, nsControlPoints );
            var getPointFunction = nurbsSurface.getPoint.bind(nurbsSurface);

            // Tessellate the NURBS at the minimum level to get the polygon control hull
            var minSlices = nsControlPoints.length-1;
            var minStacks = nsControlPoints[0].length-1;
            var geometry = new THREE.ParametricGeometry(getPointFunction, minSlices, minStacks);
            computeNormals(geometry);

            // Determine the appropriate resolution for the surface based on the curvature of the control hull
            var curvature = _calcMaxCurvature(geometry);
            var factor = curvature * NURBS_SURFACE_QUALITY;

            // Interpolate between flat and maximum detail, never less than the nurbs control hull
            var slices = Math.max(Math.floor(data.vDegree * nsControlPoints.length * factor), minSlices);
            var stacks = Math.max(Math.floor(data.uDegree * nsControlPoints[0].length * factor), minStacks);

            // Exception for totally flat surfaces, then render as a single quad
            if (curvature < NURBS_FLAT_LIMIT) {
                slices = 1;
                stacks = 1;
            }

            if (slices !== minSlices || stacks !== minStacks) {
                // Build the final geometry using the dynamic resolution
                geometry.dispose();
                geometry = new THREE.ParametricGeometry(getPointFunction, slices, stacks);
                computeNormals(geometry);
            }
            var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);
            geometry.dispose();
            return new THREE.Mesh( bufferGeometry, material );
        }


        var sheetPrimitives = Object.freeze({
            polygonSet: polygonSet,
            surface: surface
        });

        function OBJLoader ( manager ) {

        	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

        }

        OBJLoader.prototype = {

        	constructor: OBJLoader,

        	load: function ( url, onLoad, onProgress, onError ) {

        		var scope = this;

        		var loader = new THREE.XHRLoader( scope.manager );
        		loader.setCrossOrigin( this.crossOrigin );
        		loader.load( url, function ( text ) {

        			onLoad( scope.parse( text ) );

        		}, onProgress, onError );

        	},

        	parse: function ( text ) {

        		var object, objects = [];
        		var geometry, material;

        		function parseVertexIndex( value ) {

        			var index = parseInt( value );

        			return ( index >= 0 ? index - 1 : index + vertices.length / 3 ) * 3;

        		}

        		function parseNormalIndex( value ) {

        			var index = parseInt( value );

        			return ( index >= 0 ? index - 1 : index + normals.length / 3 ) * 3;

        		}

        		function parseUVIndex( value ) {

        			var index = parseInt( value );

        			return ( index >= 0 ? index - 1 : index + uvs.length / 2 ) * 2;

        		}

        		function addVertex( a, b, c ) {

        			geometry.vertices.push(
        				vertices[ a ], vertices[ a + 1 ], vertices[ a + 2 ],
        				vertices[ b ], vertices[ b + 1 ], vertices[ b + 2 ],
        				vertices[ c ], vertices[ c + 1 ], vertices[ c + 2 ]
        			);

        		}

        		function addNormal( a, b, c ) {

        			geometry.normals.push(
        				normals[ a ], normals[ a + 1 ], normals[ a + 2 ],
        				normals[ b ], normals[ b + 1 ], normals[ b + 2 ],
        				normals[ c ], normals[ c + 1 ], normals[ c + 2 ]
        			);

        		}

        		function addUV( a, b, c ) {

        			geometry.uvs.push(
        				uvs[ a ], uvs[ a + 1 ],
        				uvs[ b ], uvs[ b + 1 ],
        				uvs[ c ], uvs[ c + 1 ]
        			);

        		}

        		function addFace( a, b, c, d,  ua, ub, uc, ud, na, nb, nc, nd ) {

        			var ia = parseVertexIndex( a );
        			var ib = parseVertexIndex( b );
        			var ic = parseVertexIndex( c );
        			var id;

        			if ( d === undefined ) {

        				addVertex( ia, ib, ic );

        			} else {

        				id = parseVertexIndex( d );

        				addVertex( ia, ib, id );
        				addVertex( ib, ic, id );

        			}

        			if ( ua !== undefined ) {

        				ia = parseUVIndex( ua );
        				ib = parseUVIndex( ub );
        				ic = parseUVIndex( uc );

        				if ( d === undefined ) {

        					addUV( ia, ib, ic );

        				} else {

        					id = parseUVIndex( ud );

        					addUV( ia, ib, id );
        					addUV( ib, ic, id );

        				}

        			}

        			if ( na !== undefined ) {

        				ia = parseNormalIndex( na );
        				ib = parseNormalIndex( nb );
        				ic = parseNormalIndex( nc );

        				if ( d === undefined ) {

        					addNormal( ia, ib, ic );

        				} else {

        					id = parseNormalIndex( nd );

        					addNormal( ia, ib, id );
        					addNormal( ib, ic, id );

        				}

        			}

        		}

        		// create mesh if no objects in text

        		if ( /^o /gm.test( text ) === false ) {

        			geometry = {
        				vertices: [],
        				normals: [],
        				uvs: []
        			};

        			material = {
        				name: ''
        			};

        			object = {
        				name: '',
        				geometry: geometry,
        				material: material
        			};

        			objects.push( object );

        		}

        		var vertices = [];
        		var normals = [];
        		var uvs = [];

        		// v float float float

        		var vertex_pattern = /v( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

        		// vn float float float

        		var normal_pattern = /vn( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

        		// vt float float

        		var uv_pattern = /vt( +[\d|\.|\+|\-|e|E]+)( +[\d|\.|\+|\-|e|E]+)/;

        		// f vertex vertex vertex ...

        		var face_pattern1 = /f( +-?\d+)( +-?\d+)( +-?\d+)( +-?\d+)?/;

        		// f vertex/uv vertex/uv vertex/uv ...

        		var face_pattern2 = /f( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+))?/;

        		// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...

        		var face_pattern3 = /f( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))( +(-?\d+)\/(-?\d+)\/(-?\d+))?/;

        		// f vertex//normal vertex//normal vertex//normal ...

        		var face_pattern4 = /f( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))( +(-?\d+)\/\/(-?\d+))?/;

        		//

        		var lines = text.split( '\n' );
        		var i;

        		for ( i = 0; i < lines.length; i ++ ) {

        			var line = lines[ i ];
        			line = line.trim();

        			var result;

        			if ( line.length === 0 || line.charAt( 0 ) === '#' ) {

        				continue;

        			} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {

        				// ["v 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

        				vertices.push(
        					parseFloat( result[ 1 ] ),
        					parseFloat( result[ 2 ] ),
        					parseFloat( result[ 3 ] )
        				);

        			} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {

        				// ["vn 1.0 2.0 3.0", "1.0", "2.0", "3.0"]

        				normals.push(
        					parseFloat( result[ 1 ] ),
        					parseFloat( result[ 2 ] ),
        					parseFloat( result[ 3 ] )
        				);

        			} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {

        				// ["vt 0.1 0.2", "0.1", "0.2"]

        				uvs.push(
        					parseFloat( result[ 1 ] ),
        					parseFloat( result[ 2 ] )
        				);

        			} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {

        				// ["f 1 2 3", "1", "2", "3", undefined]

        				addFace(
        					result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]
        				);

        			} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {

        				// ["f 1/1 2/2 3/3", " 1/1", "1", "1", " 2/2", "2", "2", " 3/3", "3", "3", undefined, undefined, undefined]

        				addFace(
        					result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
        					result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
        				);

        			} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {

        				// ["f 1/1/1 2/2/2 3/3/3", " 1/1/1", "1", "1", "1", " 2/2/2", "2", "2", "2", " 3/3/3", "3", "3", "3", undefined, undefined, undefined, undefined]

        				addFace(
        					result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ],
        					result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ],
        					result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ]
        				);

        			} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {

        				// ["f 1//1 2//2 3//3", " 1//1", "1", "1", " 2//2", "2", "2", " 3//3", "3", "3", undefined, undefined, undefined]

        				addFace(
        					result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],
        					undefined, undefined, undefined, undefined,
        					result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]
        				);

        			} else if ( /^o /.test( line ) ) {

        				geometry = {
        					vertices: [],
        					normals: [],
        					uvs: []
        				};

        				material = {
        					name: ''
        				};

        				object = {
        					name: line.substring( 2 ).trim(),
        					geometry: geometry,
        					material: material
        				};

        				objects.push( object );

        			} else if ( /^g /.test( line ) ) {

        				// group

        			} else if ( /^usemtl /.test( line ) ) {

        				// material

        				material.name = line.substring( 7 ).trim();

        			} else if ( /^mtllib /.test( line ) ) {

        				// mtl file

        			} else if ( /^s /.test( line ) ) {

        				// smooth shading

        			} else {

        				// console.log( "THREE.OBJLoader: Unhandled line " + line );

        			}

        		}

        		var container = new THREE.Object3D();
        		var l;
        		for ( i = 0, l = objects.length; i < l; i ++ ) {

        			object = objects[ i ];
        			geometry = object.geometry;

        			var buffergeometry = new THREE.BufferGeometry();

        			buffergeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );

        			if ( geometry.normals.length > 0 ) {
        				buffergeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );
        			}

        			if ( geometry.uvs.length > 0 ) {
        				buffergeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );
        			}

        			material = new THREE.MeshLambertMaterial();
        			material.name = object.material.name;

        			var mesh = new THREE.Mesh( buffergeometry, material );
        			mesh.name = object.name;

        			container.add( mesh );

        		}

        		return container;

        	}

        };

        function STLLoader ( manager ) {

        	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

        }

        STLLoader.prototype = {

        	constructor: STLLoader,

        	load: function ( url, onLoad, onProgress, onError ) {

        		var scope = this;

        		var loader = new THREE.XHRLoader( scope.manager );
        		loader.setCrossOrigin( this.crossOrigin );
        		loader.setResponseType( 'arraybuffer' );
        		loader.load( url, function ( text ) {

        			onLoad( scope.parse( text ) );

        		}, onProgress, onError );

        	},

        	setCrossOrigin: function ( value ) {

        		this.crossOrigin = value;

        	},

        	parse: function ( data ) {

        		var isBinary = function () {

        			var expect, face_size, n_faces, reader;
        			reader = new DataView( binData );
        			face_size = ( 32 / 8 * 3 ) + ( ( 32 / 8 * 3 ) * 3 ) + ( 16 / 8 );
        			n_faces = reader.getUint32( 80, true );
        			expect = 80 + ( 32 / 8 ) + ( n_faces * face_size );

        			if ( expect === reader.byteLength ) {

        				return true;

        			}

        			// some binary files will have different size from expected,
        			// checking characters higher than ASCII to confirm is binary
        			var fileLength = reader.byteLength;
        			for ( var index = 0; index < fileLength; index ++ ) {

        				if ( reader.getUint8( index, false ) > 127 ) {

        					return true;

        				}

        			}

        			return false;

        		};

        		var binData = this.ensureBinary( data );

        		return isBinary()
        			? this.parseBinary( binData )
        			: this.parseASCII( this.ensureString( data ) );

        	},

        	parseBinary: function ( data ) {

        		var reader = new DataView( data );
        		var faces = reader.getUint32( 80, true );

        		var r, g, b, hasColors = false, colors;
        		var defaultR, defaultG, defaultB, alpha;

        		// process STL header
        		// check for default color in header ("COLOR=rgba" sequence).

        		for ( var index = 0; index < 80 - 10; index ++ ) {

        			if ( ( reader.getUint32( index, false ) == 0x434F4C4F /*COLO*/ ) &&
        				( reader.getUint8( index + 4 ) == 0x52 /*'R'*/ ) &&
        				( reader.getUint8( index + 5 ) == 0x3D /*'='*/ ) ) {

        				hasColors = true;
        				colors = new Float32Array( faces * 3 * 3 );

        				defaultR = reader.getUint8( index + 6 ) / 255;
        				defaultG = reader.getUint8( index + 7 ) / 255;
        				defaultB = reader.getUint8( index + 8 ) / 255;
        				alpha = reader.getUint8( index + 9 ) / 255;

        			}

        		}

        		var dataOffset = 84;
        		var faceLength = 12 * 4 + 2;

        		var offset = 0;

        		var geometry = new THREE.BufferGeometry();

        		var vertices = new Float32Array( faces * 3 * 3 );
        		var normals = new Float32Array( faces * 3 * 3 );

        		for ( var face = 0; face < faces; face ++ ) {

        			var start = dataOffset + face * faceLength;
        			var normalX = reader.getFloat32( start, true );
        			var normalY = reader.getFloat32( start + 4, true );
        			var normalZ = reader.getFloat32( start + 8, true );

        			if ( hasColors ) {

        				var packedColor = reader.getUint16( start + 48, true );

        				if ( ( packedColor & 0x8000 ) === 0 ) {

        					// facet has its own unique color

        					r = ( packedColor & 0x1F ) / 31;
        					g = ( ( packedColor >> 5 ) & 0x1F ) / 31;
        					b = ( ( packedColor >> 10 ) & 0x1F ) / 31;

        				} else {

        					r = defaultR;
        					g = defaultG;
        					b = defaultB;

        				}

        			}

        			for ( var i = 1; i <= 3; i ++ ) {

        				var vertexstart = start + i * 12;

        				vertices[ offset ] = reader.getFloat32( vertexstart, true );
        				vertices[ offset + 1 ] = reader.getFloat32( vertexstart + 4, true );
        				vertices[ offset + 2 ] = reader.getFloat32( vertexstart + 8, true );

        				normals[ offset ] = normalX;
        				normals[ offset + 1 ] = normalY;
        				normals[ offset + 2 ] = normalZ;

        				if ( hasColors ) {

        					colors[ offset ] = r;
        					colors[ offset + 1 ] = g;
        					colors[ offset + 2 ] = b;

        				}

        				offset += 3;

        			}

        		}

        		geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
        		geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );

        		if ( hasColors ) {

        			geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );
        			geometry.hasColors = true;
        			geometry.alpha = alpha;

        		}

        		return geometry;

        	},

        	parseASCII: function ( data ) {

        		var geometry, length, normal, patternFace, patternNormal, patternVertex, result, text;
        		geometry = new THREE.Geometry();
        		patternFace = /facet([\s\S]*?)endfacet/g;

        		while ( ( result = patternFace.exec( data ) ) !== null ) {

        			text = result[ 0 ];
        			patternNormal = /normal[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

        			while ( ( result = patternNormal.exec( text ) ) !== null ) {

        				normal = new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) );

        			}

        			patternVertex = /vertex[\s]+([\-+]?[0-9]+\.?[0-9]*([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+[\s]+([\-+]?[0-9]*\.?[0-9]+([eE][\-+]?[0-9]+)?)+/g;

        			while ( ( result = patternVertex.exec( text ) ) !== null ) {

        				geometry.vertices.push( new THREE.Vector3( parseFloat( result[ 1 ] ), parseFloat( result[ 3 ] ), parseFloat( result[ 5 ] ) ) );

        			}

        			length = geometry.vertices.length;

        			geometry.faces.push( new THREE.Face3( length - 3, length - 2, length - 1, normal ) );

        		}

        		geometry.computeBoundingBox();
        		geometry.computeBoundingSphere();

        		return geometry;

        	},

        	ensureString: function ( buf ) {

        		if ( typeof buf !== "string" ) {

        			var array_buffer = new Uint8Array( buf );
        			var str = '';
        			for ( var i = 0; i < buf.byteLength; i ++ ) {

        				str += String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian

        			}
        			return str;

        		} else {

        			return buf;

        		}

        	},

        	ensureBinary: function ( buf ) {

        		if ( typeof buf === "string" ) {

        			var array_buffer = new Uint8Array( buf.length );
        			for ( var i = 0; i < buf.length; i ++ ) {

        				array_buffer[ i ] = buf.charCodeAt( i ) & 0xff; // implicitly assumes little-endian

        			}
        			return array_buffer.buffer || array_buffer;

        		} else {

        			return buf;

        		}

        	}

        };

        function DataView( buffer, byteOffset, byteLength ) {

        	this.buffer = buffer;
        	this.byteOffset = byteOffset || 0;
        	this.byteLength = byteLength || buffer.byteLength || buffer.length;
        	this._isString = typeof buffer === "string";

        }

        DataView.prototype = {

        	_getCharCodes: function( buffer, start, length ) {

        		start = start || 0;
        		length = length || buffer.length;
        		var end = start + length;
        		var codes = [];
        		for ( var i = start; i < end; i ++ ) {

        			codes.push( buffer.charCodeAt( i ) & 0xff );

        		}
        		return codes;

        	},

        	_getBytes: function ( length, byteOffset, littleEndian ) {

        		var result;

        		// Handle the lack of endianness
        		if ( littleEndian === undefined ) {

        			littleEndian = this._littleEndian;

        		}

        		// Handle the lack of byteOffset
        		if ( byteOffset === undefined ) {

        			byteOffset = this.byteOffset;

        		} else {

        			byteOffset = this.byteOffset + byteOffset;

        		}

        		if ( length === undefined ) {

        			length = this.byteLength - byteOffset;

        		}

        		// Error Checking
        		if ( typeof byteOffset !== 'number' ) {

        			throw new TypeError( 'DataView byteOffset is not a number' );

        		}

        		if ( length < 0 || byteOffset + length > this.byteLength ) {

        			throw new Error( 'DataView length or (byteOffset+length) value is out of bounds' );

        		}

        		if ( this.isString ) {

        			result = this._getCharCodes( this.buffer, byteOffset, byteOffset + length );

        		} else {

        			result = this.buffer.slice( byteOffset, byteOffset + length );

        		}

        		if ( ! littleEndian && length > 1 ) {

        			if ( Array.isArray( result ) === false ) {

        				result = Array.prototype.slice.call( result );

        			}

        			result.reverse();

        		}

        		return result;

        	},

        	// Compatibility functions on a String Buffer

        	getFloat64: function ( byteOffset, littleEndian ) {

        		var b = this._getBytes( 8, byteOffset, littleEndian ),

        			sign = 1 - ( 2 * ( b[ 7 ] >> 7 ) ),
        			exponent = ( ( ( ( b[ 7 ] << 1 ) & 0xff ) << 3 ) | ( b[ 6 ] >> 4 ) ) - ( ( 1 << 10 ) - 1 ),

        		// Binary operators such as | and << operate on 32 bit values, using + and Math.pow(2) instead
        			mantissa = ( ( b[ 6 ] & 0x0f ) * Math.pow( 2, 48 ) ) + ( b[ 5 ] * Math.pow( 2, 40 ) ) + ( b[ 4 ] * Math.pow( 2, 32 ) ) +
        						( b[ 3 ] * Math.pow( 2, 24 ) ) + ( b[ 2 ] * Math.pow( 2, 16 ) ) + ( b[ 1 ] * Math.pow( 2, 8 ) ) + b[ 0 ];

        		if ( exponent === 1024 ) {

        			if ( mantissa !== 0 ) {

        				return NaN;

        			} else {

        				return sign * Infinity;

        			}

        		}

        		if ( exponent === - 1023 ) {

        			// Denormalized
        			return sign * mantissa * Math.pow( 2, - 1022 - 52 );

        		}

        		return sign * ( 1 + mantissa * Math.pow( 2, - 52 ) ) * Math.pow( 2, exponent );

        	},

        	getFloat32: function ( byteOffset, littleEndian ) {

        		var b = this._getBytes( 4, byteOffset, littleEndian ),

        			sign = 1 - ( 2 * ( b[ 3 ] >> 7 ) ),
        			exponent = ( ( ( b[ 3 ] << 1 ) & 0xff ) | ( b[ 2 ] >> 7 ) ) - 127,
        			mantissa = ( ( b[ 2 ] & 0x7f ) << 16 ) | ( b[ 1 ] << 8 ) | b[ 0 ];

        		if ( exponent === 128 ) {

        			if ( mantissa !== 0 ) {

        				return NaN;

        			} else {

        				return sign * Infinity;

        			}

        		}

        		if ( exponent === - 127 ) {

        			// Denormalized
        			return sign * mantissa * Math.pow( 2, - 126 - 23 );

        		}

        		return sign * ( 1 + mantissa * Math.pow( 2, - 23 ) ) * Math.pow( 2, exponent );

        	},

        	getInt32: function ( byteOffset, littleEndian ) {

        		var b = this._getBytes( 4, byteOffset, littleEndian );
        		return ( b[ 3 ] << 24 ) | ( b[ 2 ] << 16 ) | ( b[ 1 ] << 8 ) | b[ 0 ];

        	},

        	getUint32: function ( byteOffset, littleEndian ) {

        		return this.getInt32( byteOffset, littleEndian ) >>> 0;

        	},

        	getInt16: function ( byteOffset, littleEndian ) {

        		return ( this.getUint16( byteOffset, littleEndian ) << 16 ) >> 16;

        	},

        	getUint16: function ( byteOffset, littleEndian ) {

        		var b = this._getBytes( 2, byteOffset, littleEndian );
        		return ( b[ 1 ] << 8 ) | b[ 0 ];

        	},

        	getInt8: function ( byteOffset ) {

        		return ( this.getUint8( byteOffset ) << 24 ) >> 24;

        	},

        	getUint8: function ( byteOffset ) {

        		return this._getBytes( 1, byteOffset )[ 0 ];

        	}

        };

        /**
         * Moves a geometry by a vector
         *
         * @function moveGeometry
         *
         * @param { THREEJS.OBJECT3D } object The object to move
         * @param { THREE.Vector3 } vector The vector to move the object by
         */
        function moveGeometry ( object, vector ) {
            object.position.copy( vector );
            object.updateMatrix();
            object.geometry.applyMatrix( object.matrix );
            object.position.set( 0, 0, 0 );
        }

        /**
         * Rotates a geometry by a vector
         *
         * @function rotateGeometry
         *
         * @param { THREEJS.OBJECT3D } object The object to rotate
         * @param { THREE.Vector3 }  vector The vector to rotate by in Euler Angles
         */
        function rotateGeometry ( object, vector ) {
            object.rotation.set( vector.x, vector.y, vector.z );
            object.updateMatrix();
            object.geometry.applyMatrix( object.matrix );
            object.rotation.set( 0, 0, 0 );
        }

        /**
         * Extract the semi angle property from a data object.
         * Used to determine cone shape. Data is expected to have a
         * semiAngle property set in degrees.
         *
         * @param  {Object} data The data describing a cone.
         *
         * @function getSemiAngle
         *
         * @throws FluxGeometryError if property is missing or out of bounds
         *
         * @return {Number}      The semi angle in radians.
         */
        function getSemiAngle(data) {
            var semiAngle;
            if (data.semiAngle) {
                semiAngle = data.semiAngle;
            } else {
                if (data['semi-angle']) {
                    semiAngle = data['semi-angle'];
                } else {
                    throw new FluxGeometryError('Cone must specify semiAngle parameter.');
                }
            }
            if (data.semiAngle <= 0 || data.semiAngle >= 90) {
                throw new FluxGeometryError('Cone semiAngle must be between 0 and 90 degrees exclusive.');
            }
            return DEG_2_RAD * semiAngle;
        }
        /**
         * Creates a cone THREE.Mesh from parasolid data and a material.
         *
         * @function cone
         *
         * @return { THREE.Mesh } The cone THREE.Mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function cone ( data, material ) {
            var geometry, mesh;
            var semiAngle = getSemiAngle(data);
            var topRadius = data.height * Math.tan(semiAngle);
            geometry = new THREE.CylinderBufferGeometry( topRadius+data.radius, data.radius, data.height, CIRCLE_RES );
            mesh = new THREE.Mesh( geometry, material );
            moveGeometry( mesh, new THREE.Vector3( 0, data.height * 0.5, 0 ) );
            rotateGeometry( mesh, DEFAULT_ROTATION );

            return mesh;
        }

        /**
         * Creates a cylindrical THREE.Mesh from parasolid data and a material
         *
         * @function cylinder
         *
         * @return { THREE.Mesh } The cylindrical THREE.Mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function cylinder ( data, material ) {
            var geometry, mesh;

            geometry = new THREE.CylinderBufferGeometry( data.radius, data.radius, data.height, CIRCLE_RES );
            mesh = new THREE.Mesh( geometry, material );
            moveGeometry( mesh, new THREE.Vector3( 0, data.height * 0.5, 0 ) );
            rotateGeometry( mesh, DEFAULT_ROTATION );

            return mesh;
        }

        /**
         * Creates a spherical THREE.Mesh from parasolid data and a material
         *
         * @function sphere
         *
         * @return { THREE.Mesh } The spherical THREE.Mesh
         *
         * @throws FluxGeometryError if sphere is missing radius
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function sphere ( data, material ) {
            var geometry, mesh;

            if (!data.radius) {
                throw new FluxGeometryError('Sphere is missing radius.');
            }

            geometry = new THREE.SphereBufferGeometry( data.radius, 12, 8 );
            geometry = computeNormals(geometry);
            mesh = new THREE.Mesh( geometry, material );
            rotateGeometry( mesh, DEFAULT_ROTATION );
            return mesh;
        }

        /**
         * Creates a toroidal THREE.Mesh from parasolid data and a material
         *
         * @function torus
         *
         * @return { THREE.Mesh } The toroidal THREE.Mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function torus ( data, material ) {
            var majorRadius = data.majorRadius || data.major_radius;
            var minorRadius = data.minorRadius || data.minor_radius;
            var geometry = new THREE.TorusBufferGeometry( majorRadius, minorRadius, 24, 24 );
            return new THREE.Mesh( geometry, material );
        }

        /**
         * Creates a box THREE.Mesh from parasolid data and a material
         *
         * @function block
         *
         * @return { THREE.Mesh } The box THREE.Mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function block ( data, material ) {
            var geometry = new THREE.BoxBufferGeometry( data.dimensions[ 0 ], data.dimensions[ 1 ], data.dimensions[ 2 ] );
            return new THREE.Mesh( geometry, material );
        }


        /**
         * Creates a THREE.Mesh from parasolid data and a material
         *
         * @precondition The faces in the mesh must be triangles or convex planar polygons.
         * Also this assumes the faces are wound counter clockwise.
         *
         * @function THREE.Mesh
         *
         * @return {THREE.Mesh} The THREE.Mesh
         *
         * @param {Object}          data     Parasolid data
         * @param {THREE.Material}  material The material to give the THREE.Mesh

         */
        function mesh (data, material) {

            var positions = [];
            for ( var i = 0, len = data.vertices.length ; i < len ; i++ ) {
                positions.push(data.vertices[i][0]);
                positions.push(data.vertices[i][1]);
                positions.push(data.vertices[i][2]);
            }

            var face;
            var triangles = [];
            for ( i = 0, len = data.faces.length ; i < len ; i++ ) {
                face = data.faces[ i ];
                if ( face.length === 3 ) {
                    triangles.push(face[0]);
                    triangles.push(face[1]);
                    triangles.push(face[2]);
                } else if ( face.length > 3 ) {
                    for ( var j=0; j+2<face.length; j++) {
                        triangles.push(face[0]);
                        triangles.push(face[j+1]);
                        triangles.push(face[j+2]);
                    }
                }

            }

            var geometry = new THREE.BufferGeometry();
            if (data.attributes && data.attributes.uvs) {
                var uvs = [];
                for ( var i = 0, len = data.attributes.uvs.length ; i < len ; i++ ) {
                    uvs.push(data.attributes.uvs[i][0]);
                    uvs.push(data.attributes.uvs[i][1]);
                }
                geometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array(uvs), 2 ) );
            }
            geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array(positions), 3 ) );
            geometry.setIndex( new THREE.BufferAttribute( new Uint32Array( triangles ), 1 ) );

            geometry.computeBoundingSphere();
            geometry = computeNormals(geometry);
            return new THREE.Mesh( geometry, material );
          }

        // Singleton loader object
        var objLoader = new OBJLoader();
        /**
         * Convert stl data into geometry
         * @param {object} data The stl primitive
         * @param {THREE.material} material The material to use
         * @returns {THREE.Mesh} The mesh containing the geometry
         */
        function obj (data) {
            return objLoader.parse(data.data);
        }

        // Singleton loader object
        var stlLoader = new STLLoader();
        /**
         * Convert stl data into geometry
         * @param {object} data The stl primitive
         * @param {THREE.material} material The material to use
         * @returns {THREE.Mesh} The mesh containing the geometry
         */
        function stl (data, material) {
            var geometry = stlLoader.parseASCII(data.data);

            geometry.computeBoundingSphere();
            computeNormals(geometry);
            var bufferGeometry = new THREE.BufferGeometry().fromGeometry(geometry);
            geometry.dispose();
            return new THREE.Mesh( bufferGeometry, material );
        }

        /**
         * Creates a planar THREE.Mesh from parasolid data and a material
         *
         * @function plane
         *
         * @return { THREE.Mesh } The planar THREE.Mesh
         *
         * @param { Object }           data     Parasolid data
         * @param { THREE.Material } material The material to give the THREE.Mesh
         */
        function plane ( data, material ) {
            var geometry = new THREE.PlaneBufferGeometry( PLANE_DEFAULTS.WIDTH, PLANE_DEFAULTS.HEIGHT,
                PLANE_DEFAULTS.WIDTH_SEGMENTS, PLANE_DEFAULTS.HEIGHT_SEGMENTS );
            return new THREE.Mesh( geometry, material );
        }


        var solidPrimitives = Object.freeze({
          cone: cone,
          cylinder: cylinder,
          sphere: sphere,
          torus: torus,
          block: block,
          mesh: mesh,
          obj: obj,
          stl: stl,
          plane: plane
        });

        /**
         * Convert a material to hash like string.
         * The string will always be the same for the same property values,
         * and can be used to determine uniqueness of materials.
         * @param {constants.MATERIAL_TYPES} type The type of material
         * @param {THREE.material} m The material
         * @return {string} The result
         */
        function materialToJson(type, m) {
            var knownProperties = DEFAULT_MATERIAL_PROPERTIES;
            var propertyNames = [];
            var prop;
            switch ( type ) {
                case MATERIAL_TYPES.PHONG: {
                    propertyNames = Object.keys(knownProperties.phong);
                    // Special case roughness since its not a real property, but determines uniqueness
                    propertyNames.push('roughness');
                    break;
                }
                case MATERIAL_TYPES.POINT: {
                    propertyNames = Object.keys(knownProperties.point);
                    break;
                }
                case MATERIAL_TYPES.LINE: {
                    propertyNames = Object.keys(knownProperties.line);
                    break;
                }
            }
            propertyNames.sort();
            var orderedMaterial =[];
            var i, len;
            for (i=0, len=propertyNames.length; i<len; i++) {
                prop = m[propertyNames[i]];
                if (prop) {
                    orderedMaterial.push(prop);
                }
            }
            // Use the type (mesh, phong, line) as a namespace to separate materials
            var result = JSON.stringify(type);
            result += JSON.stringify(orderedMaterial);
            return result;
        }

        /**
         * Convert a color string or array to an object
         * @param {String|Array} color The html color
         * @returns {THREE.Color} The color object
         * @private
         */
        function _convertColor(color) {
            if (color == null) {
                color = DEFAULT_MATERIAL_PROPERTIES.phong.color;
            }
            var newColor = new THREE.Color();
            if (typeof color === 'object' &&
                color.r !== undefined && color.g !== undefined && color.b !== undefined) {
                newColor.copy(color);
            } else if (typeof color === 'object' && color instanceof Array && color.length === 3) {
                newColor.setRGB(color[0], color[1], color[2]);
            } else {
                newColor.set(color);
            }
            return newColor;
        }

        /**
         * Find a parameter on the entity object data
         * @param {Object} data The entity parameters object
         * @param {String} attr The name of the desired attribute
         * @param {*} defaultAttr The default value for the attribute
         * @returns {*} The found property or the default
         * @private
         */
        function _getEntityData(data, attr, defaultAttr) {
            if (!data) return defaultAttr;
            var value = defaultAttr;
            if (data[attr]) {
                value = data[attr];
            } else if (data.materialProperties && data.materialProperties[attr]) {
                value = data.materialProperties[attr];
            } else if (data.attributes && data.attributes.materialProperties && data.attributes.materialProperties[attr]) {
                value = data.attributes.materialProperties[attr];
            }
            return value;
        }

        (function(self) {
          'use strict';

          if (self.fetch) {
            return
          }

          var support = {
            searchParams: 'URLSearchParams' in self,
            iterable: 'Symbol' in self && 'iterator' in Symbol,
            blob: 'FileReader' in self && 'Blob' in self && (function() {
              try {
                new Blob()
                return true
              } catch(e) {
                return false
              }
            })(),
            formData: 'FormData' in self,
            arrayBuffer: 'ArrayBuffer' in self
          }

          function normalizeName(name) {
            if (typeof name !== 'string') {
              name = String(name)
            }
            if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
              throw new TypeError('Invalid character in header field name')
            }
            return name.toLowerCase()
          }

          function normalizeValue(value) {
            if (typeof value !== 'string') {
              value = String(value)
            }
            return value
          }

          // Build a destructive iterator for the value list
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift()
                return {done: value === undefined, value: value}
              }
            }

            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator
              }
            }

            return iterator
          }

          function Headers(headers) {
            this.map = {}

            if (headers instanceof Headers) {
              headers.forEach(function(value, name) {
                this.append(name, value)
              }, this)

            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name) {
                this.append(name, headers[name])
              }, this)
            }
          }

          Headers.prototype.append = function(name, value) {
            name = normalizeName(name)
            value = normalizeValue(value)
            var list = this.map[name]
            if (!list) {
              list = []
              this.map[name] = list
            }
            list.push(value)
          }

          Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)]
          }

          Headers.prototype.get = function(name) {
            var values = this.map[normalizeName(name)]
            return values ? values[0] : null
          }

          Headers.prototype.getAll = function(name) {
            return this.map[normalizeName(name)] || []
          }

          Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name))
          }

          Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = [normalizeValue(value)]
          }

          Headers.prototype.forEach = function(callback, thisArg) {
            Object.getOwnPropertyNames(this.map).forEach(function(name) {
              this.map[name].forEach(function(value) {
                callback.call(thisArg, value, name, this)
              }, this)
            }, this)
          }

          Headers.prototype.keys = function() {
            var items = []
            this.forEach(function(value, name) { items.push(name) })
            return iteratorFor(items)
          }

          Headers.prototype.values = function() {
            var items = []
            this.forEach(function(value) { items.push(value) })
            return iteratorFor(items)
          }

          Headers.prototype.entries = function() {
            var items = []
            this.forEach(function(value, name) { items.push([name, value]) })
            return iteratorFor(items)
          }

          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries
          }

          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError('Already read'))
            }
            body.bodyUsed = true
          }

          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result)
              }
              reader.onerror = function() {
                reject(reader.error)
              }
            })
          }

          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader()
            reader.readAsArrayBuffer(blob)
            return fileReaderReady(reader)
          }

          function readBlobAsText(blob) {
            var reader = new FileReader()
            reader.readAsText(blob)
            return fileReaderReady(reader)
          }

          function Body() {
            this.bodyUsed = false

            this._initBody = function(body) {
              this._bodyInit = body
              if (typeof body === 'string') {
                this._bodyText = body
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString()
              } else if (!body) {
                this._bodyText = ''
              } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {
                // Only support ArrayBuffers for POST method.
                // Receiving ArrayBuffers happens via Blobs, instead.
              } else {
                throw new Error('unsupported BodyInit type')
              }

              if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                  this.headers.set('content-type', 'text/plain;charset=UTF-8')
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set('content-type', this._bodyBlob.type)
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
                }
              }
            }

            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this)
                if (rejected) {
                  return rejected
                }

                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob)
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as blob')
                } else {
                  return Promise.resolve(new Blob([this._bodyText]))
                }
              }

              this.arrayBuffer = function() {
                return this.blob().then(readBlobAsArrayBuffer)
              }

              this.text = function() {
                var rejected = consumed(this)
                if (rejected) {
                  return rejected
                }

                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob)
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as text')
                } else {
                  return Promise.resolve(this._bodyText)
                }
              }
            } else {
              this.text = function() {
                var rejected = consumed(this)
                return rejected ? rejected : Promise.resolve(this._bodyText)
              }
            }

            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode)
              }
            }

            this.json = function() {
              return this.text().then(JSON.parse)
            }

            return this
          }

          // HTTP methods whose capitalization should be normalized
          var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']

          function normalizeMethod(method) {
            var upcased = method.toUpperCase()
            return (methods.indexOf(upcased) > -1) ? upcased : method
          }

          function Request(input, options) {
            options = options || {}
            var body = options.body
            if (Request.prototype.isPrototypeOf(input)) {
              if (input.bodyUsed) {
                throw new TypeError('Already read')
              }
              this.url = input.url
              this.credentials = input.credentials
              if (!options.headers) {
                this.headers = new Headers(input.headers)
              }
              this.method = input.method
              this.mode = input.mode
              if (!body) {
                body = input._bodyInit
                input.bodyUsed = true
              }
            } else {
              this.url = input
            }

            this.credentials = options.credentials || this.credentials || 'omit'
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers)
            }
            this.method = normalizeMethod(options.method || this.method || 'GET')
            this.mode = options.mode || this.mode || null
            this.referrer = null

            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
              throw new TypeError('Body not allowed for GET or HEAD requests')
            }
            this._initBody(body)
          }

          Request.prototype.clone = function() {
            return new Request(this)
          }

          function decode(body) {
            var form = new FormData()
            body.trim().split('&').forEach(function(bytes) {
              if (bytes) {
                var split = bytes.split('=')
                var name = split.shift().replace(/\+/g, ' ')
                var value = split.join('=').replace(/\+/g, ' ')
                form.append(decodeURIComponent(name), decodeURIComponent(value))
              }
            })
            return form
          }

          function headers(xhr) {
            var head = new Headers()
            var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\n')
            pairs.forEach(function(header) {
              var split = header.trim().split(':')
              var key = split.shift().trim()
              var value = split.join(':').trim()
              head.append(key, value)
            })
            return head
          }

          Body.call(Request.prototype)

          function Response(bodyInit, options) {
            if (!options) {
              options = {}
            }

            this.type = 'default'
            this.status = options.status
            this.ok = this.status >= 200 && this.status < 300
            this.statusText = options.statusText
            this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)
            this.url = options.url || ''
            this._initBody(bodyInit)
          }

          Body.call(Response.prototype)

          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            })
          }

          Response.error = function() {
            var response = new Response(null, {status: 0, statusText: ''})
            response.type = 'error'
            return response
          }

          var redirectStatuses = [301, 302, 303, 307, 308]

          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError('Invalid status code')
            }

            return new Response(null, {status: status, headers: {location: url}})
          }

          self.Headers = Headers
          self.Request = Request
          self.Response = Response

          self.fetch = function(input, init) {
            return new Promise(function(resolve, reject) {
              var request
              if (Request.prototype.isPrototypeOf(input) && !init) {
                request = input
              } else {
                request = new Request(input, init)
              }

              var xhr = new XMLHttpRequest()

              function responseURL() {
                if ('responseURL' in xhr) {
                  return xhr.responseURL
                }

                // Avoid security warnings on getResponseHeader when not allowed by CORS
                if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
                  return xhr.getResponseHeader('X-Request-URL')
                }

                return
              }

              xhr.onload = function() {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: headers(xhr),
                  url: responseURL()
                }
                var body = 'response' in xhr ? xhr.response : xhr.responseText
                resolve(new Response(body, options))
              }

              xhr.onerror = function() {
                reject(new TypeError('Network request failed'))
              }

              xhr.ontimeout = function() {
                reject(new TypeError('Network request failed'))
              }

              xhr.open(request.method, request.url, true)

              if (request.credentials === 'include') {
                xhr.withCredentials = true
              }

              if ('responseType' in xhr && support.blob) {
                xhr.responseType = 'blob'
              }

              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value)
              })

              xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
            })
          }
          self.fetch.polyfill = true
        })(typeof self !== 'undefined' ? self : this);

        var fetchNpmBrowserify = __commonjs(function (module) {
        // the whatwg-fetch polyfill installs the fetch() function
        // on the global object (window or self)
        //
        // Return that as the export for use in Webpack, Browserify etc.

        module.exports = self.fetch.bind(self);
        });

        var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

        function _objectWithoutProperties$1(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

        function parseResponse(response) {
          const payloadType = response.headers.get('content-type') || '';
          let body = null;

          // The mime-type may, for example, include a charset
          if (payloadType.search(/application\/json/i) !== -1) {
            body = response.json();
          } else if (payloadType.search(/multipart\/form-data/i) !== -1) {
            body = response.formData();
          } else {
            body = response.text();
          }

          return {
            body,
            status: response.status,
            statusText: response.statusText,
            headers: response.headers
          };
        }

        function handleError(response) {
          const status = response.status;
          const statusText = response.statusText;
          const headers = response.headers;
          const body = response.body;


          if (status < 200 || status >= 300) {
            const error = new Error(statusText || body);

            error.status = status;
            error.statusText = statusText;
            error.headers = headers;
            error.body = body;

            throw error;
          }

          return response;
        }

        function request(path) {
          var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          var _ref$method = _ref.method;
          let method = _ref$method === undefined ? 'get' : _ref$method;
          let body = _ref.body;
          var _ref$headers = _ref.headers;
          let headers = _ref$headers === undefined ? {} : _ref$headers;

          let others = _objectWithoutProperties$1(_ref, ['method', 'body', 'headers']);

          let payload = null;

          if (body && method.toLowerCase() === 'get') {
            throw new Error('Only `GET` requests can contain a `body`');
          }

          const contentType = headers['content-type'] || headers['Content-Type'] || headers['Content-type'] || 'application/json';

          if (contentType.search(/application\/json/) !== -1 && body) {
            payload = { body: JSON.stringify(body) };
          } else if (body) {
            payload = { body };
          }

          return fetch(path, _extends$1({
            method,
            headers: _extends$1({}, headers, {
              'content-type': contentType
            })
          }, payload, others)).then(parseResponse).then(handleError);
        }

        var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

        function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

        function fluxFetch$1(path) {
          var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          let fluxToken = _ref.fluxToken;
          let headers = _ref.headers;

          let others = _objectWithoutProperties(_ref, ['fluxToken', 'headers']);

          if (!fluxToken) {
            throw new Error('Must provide a `fluxToken` to `fluxFetch`');
          }

          return request(path, _extends({
            credentials: 'include',
            headers: _extends({
              'flux-request-marker': 1,
              'flux-request-token': fluxToken
            }, headers)
          }, others));
        }

        /**
         * Wrapper around flux fetch, which assumes a stub when running tests.
         * @param  {String} url     Resource to request via HTTP
         * @param  {Object} options Collection of key value parameters
         * @return {Promise}         Promise to return headers object
         */
        function fluxFetch(url, options) {
            var xhrPromise;
            if ('BROWSER' === 'BROWSER') {
                xhrPromise = fluxFetch$1(url, options);
            }
            if ('BROWSER' === 'TEST') {}
            return xhrPromise;
        }

        /**
         * Create a canvas element if possible
         * @return {DOMElement} The canvas or null
         */
        function createCanvas() {
            var canvas = null;
            if ('BROWSER' === 'BROWSER') {
                canvas = document.createElement( 'canvas' );
            }
            return canvas;
        }

        function TextHelper ( label, options ) {

            options = options || {};
            options.size = options.size || 4;
            options.resolution = options.resolution || 128;
            options.color = options.color || 'white';
            options.align = options.align || 'center';

            var canvas = createCanvas();
            var aspect = 1;
            if (canvas) {
                var ctx = canvas.getContext( '2d' );
                ctx.font = options.resolution + 'px sans-serif';

                aspect = ctx.measureText(label).width / options.resolution;

                canvas.width = options.resolution * aspect;
                canvas.height = options.resolution;

                ctx.font = options.resolution + 'px sans-serif';
                ctx.fillStyle = 'white';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText( label, options.resolution * aspect / 2, options.resolution / 2 );
            }

            var texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            texture.premultiplyAlpha = true;
            texture.generateMipmaps = false;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;

            var material = new THREE.MeshBasicMaterial( { map: texture, transparent: true, color: options.color, side: THREE.DoubleSide } );
            material.blendSrc = THREE.OneFactor;
            material.blending = THREE.CustomBlending;
            material.depthWrite = false;

            var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
            var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
            var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

            var geometry = new THREE.BufferGeometry();
            geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
            geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
            geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

            THREE.Mesh.call( this, geometry, material );

            this.type = 'textHelper';

            if (options.align == 'left') {

                this.position.x = - options.size * aspect / 2;

            } else if (options.align == 'right') {

                this.position.x = options.size * aspect / 2;

            }

            this.scale.set( options.size * aspect, options.size, 1 );
            this.updateMatrix();
            this.geometry.applyMatrix(this.matrix);

            this.scale.set( 1, 1, 1 );
            this.position.set( 0, 0, 0 );
            this.updateMatrix();

        }

        TextHelper.prototype = Object.create( THREE.Mesh.prototype );
        TextHelper.prototype.constructor = TextHelper;

        /**
         * Creates a linear THREE.Mesh from parasolid data and a material
         *
         * @function text
         *
         * @return { THREE.Mesh } The linear THREE.Mesh
         *
         * @param { Object } data     Parasolid data
         */
        function text ( data ) {
            var textHelper = new TextHelper( data.text, {
                size:       _getEntityData(data, 'size', undefined),
                resolution: _getEntityData(data, 'resolution', undefined),
                align:      _getEntityData(data, 'align', undefined)
            });
            textHelper.material.color = _convertColor(_getEntityData(data, 'color', 'black'));
            return textHelper;
        }


        var otherPrimitives = Object.freeze({
            text: text
        });

        var dimensions = {"length":{"units":[["angstroms","angstrom","A"],["nanometers","nanometer","nm"],["microns","um","micron"],["millimeters","mm","millimeter"],["centimeters","cm","centimeter"],["decimeters","decimeter","dm"],["meters","m","meter"],["dekameters","dekameter","dam"],["hectometers","hectometer","hm"],["kilometers","km","kilometer"],["megameters","megameter","Mm"],["gigameters","gigameter","Gm"],["mils","mil"],["inches","inch","in"],["yards","yard","yd"],["feet","ft","foot"],["decifeet","decifoot","shrekles","shrekle"],["miles","mile"],["nautical miles","nautical mile"],["printer picas","printer pica"],["printer points","printer point"],["astronomical units","astronomical unit","au"],["light years","light year","ly"],["parsecs","parsec","pc"]]},"area":{"units":[["acres"],["hectares"]]},"volume":{"units":[["liters","liter","l"],["gallons","gallon","gal"]]},"temperature":{"units":[["farenheit","F"],["celsius","C"],["kelvin","K"]]},"time":{"units":[["nanoseconds","nanosecond","ns"],["microseconds","microsecond","us"],["milliseconds","milisecond","ms"],["seconds","second","s"],["minutes","minute"],["hours","hour","h"],["days","day"],["weeks","week"],["years","year"]]},"angle":{"units":[["radians","radian","rad"],["degrees","degree","deg"]]},"mass":{"units":[["grams","gram","g"],["kilograms","kilogram","kg"],["pounds","pound","lb"]]},"force":{"units":[["newtons","newton"],["pound-force","lbf"]]},"energy":{"units":[["joules","joule"],["kwh","kilowatt hour"]]},"luminous-intensity":{"units":[["candelas","candela"]]},"illumination":{"units":[["lux","lx"],["foot-candles","foot-candle","fc"]]},"luminous-flux":{"units":[["lumen","lm"]]}};
        var conversions = [{"from":"angstroms","to":"meters","factor":1e-10},{"from":"nanometers","to":"meters","factor":1e-9},{"from":"microns","to":"meters","factor":0.000001},{"from":"millimeters","to":"meters","factor":0.001},{"from":"centimeters","to":"meters","factor":0.01},{"from":"decimeters","to":"meters","factor":0.1},{"from":"dekameters","to":"meters","factor":10},{"from":"hectometers","to":"meters","factor":100},{"from":"kilometers","to":"meters","factor":1000},{"from":"megameters","to":"meters","factor":1000000},{"from":"gigameters","to":"meters","factor":1000000000},{"from":"mils","to":"meters","factor":0.0000254},{"from":"inches","to":"meters","factor":0.0254},{"from":"yards","to":"meters","factor":0.9144},{"from":"feet","to":"meters","factor":0.3048},{"from":"decifeet","to":"meters","factor":0.03048},{"from":"miles","to":"meters","factor":1609.34},{"from":"nautical miles","to":"meters","factor":1852},{"from":"printer picas","to":"meters","factor":0.00423333},{"from":"printer points","to":"meters","factor":0.000352778},{"from":"astronomical units","to":"meters","factor":149600000000},{"from":"light years","to":"meters","factor":9461000000000000},{"from":"parsecs","to":"meters","factor":30860000000000000}];

        function UnitRegistry() {
            // Dimension (string) -> bool
            this.dimensions = {};

            // Unit -> dimension
            this.units = {};

            // Alias -> Unit
            this.aliases = {};

            // Unit -> {Unit -> Scale}}
            this.conversions = {};

        }

        /**
         * Add a unit as a known type that can be converted
         * @param {String} unit The name of the unit (ex 'feet')
         * @param {String} dim The name of the dimension (ex 'length')
         * @param {Array.<String>} aliases Other names for the same unit (ex ['foot', 'ft'])
         */
        UnitRegistry.prototype.addUnit = function (unit, dim, aliases) {
            this.units[unit] = dim;
            for(var i=0;i<aliases.length;i++) {
                this.aliases[aliases[i]] = unit;
            }
        };

        /**
         * Determine the numeric value to convert between two linear units
         * @param {String} from The old unit name
         * @param {String} to The new unit name
         * @returns {Number} The multiplier
         */
        UnitRegistry.prototype.unitConversionFactor = function (from, to) {
            var standardFrom = from;
            if (this.aliases[from]) {
                standardFrom = this.aliases[from];
            }
            // Don't need to convert same units or
            // units that are known, but don't have a conversion
            if (from === to || standardFrom === to) {
                return 1.0;
            }
            var conversionFrom = this.conversions[from];
            if (!conversionFrom) {
                if (standardFrom) {
                    conversionFrom = this.conversions[standardFrom];
                }
            }
            if (conversionFrom) {
                return conversionFrom[to];
            }
            // Known units that are missing conversions are considered a pass through
            if (this.units[standardFrom] && this.units[to]) {
                return 1.0;
            }
            // TODO(Kyle): This should be a warning
            // https://vannevar.atlassian.net/browse/LIB3D-709
            // throw new FluxGeometryError('Could not convert units from "'+from+'" to '+to);
            return null;
        };

        /**
         * Modify all the numeric properties in an object
         * @param {Object} obj The thing to modify
         * @param {Number} factor The multiplier for each property
         * @returns {Object} The modified object
         * @private
         */
        function _scaleProperties(obj, factor) {
            if (obj) {
                if (obj.constructor === Number) {
                    return obj * factor;
                }
                if (obj.constructor === Array) {
                    return obj.map(function (item) {
                        return _scaleProperties(item, factor);
                    });
                }
                // TODO handle objects if needed
            }
            return obj;
        }

        /**
         * Create a function to repeatedly convert a pair of units
         * @param {String} from The old units
         * @param {String} to The new units
         * @returns {Function} The conversion function
         */
        UnitRegistry.prototype.unitConversionFunc = function (from, to) {
            var factor = this.unitConversionFactor(from, to);
            if (factor !== null) {
                return function (obj) {
                    if (!obj) {
                        throw new FluxGeometryError('Invalid unit string '+obj);
                    } else if (obj.constructor === Number) {
                        return obj * factor;
                    }
                    return _scaleProperties(obj, factor);
                };
            }
            return null;
        };

        /**
         * Add a new dimension that can be measured
         * @param {String} d The dimension
         */
        UnitRegistry.prototype.addConcreteDimension = function (d) {
            this.dimensions[d] = true;
        };

        /**
         * Register a scale factor for a given unit conversion
         * @param {String} from Old units
         * @param {String} to New units
         * @param {Number} scale The relative scale of the units
         */
        UnitRegistry.prototype.addConversion = function (from, to, scale) {

            if (!this.conversions[from]) {
                this.conversions[from] = {};
            }
            if (this.conversions[from][to] == null) {
                this.conversions[from][to] = scale;
            }
        };

        /**
         * Factory function to create a units registry with common values populated
         *
         * This is hand migrated code from units-of-measurement / flux-measure.
         * We did not use the emscripten based port because it was too large (~2MB)
         * for what is a reasonable amount of JavaScript code. Also the web viewer
         * only needs a subset of the units conversion logic to display geometry.
         * TODO: move all these function calls into a .json file containing
         * the data and have the code loop over it instead of being hard coded.
         * It is this way currently to match the structure of the other repository.
         *
         * @returns {UnitRegistry} The new registry
         */
        UnitRegistry.newStandardRegistry = function () {
            var r = new UnitRegistry();

            // Add dimensions, units and aliases
            var dimensions$$ = dimensions;
            for (var d in dimensions$$) {
                r.addConcreteDimension(dimensions$$[d]);
                var units = dimensions$$[d].units;
                for (var u in units) {
                    r.addUnit(units[u][0], dimensions$$[d], units[u].splice(1));
                }
            }

            // Add conversions between units
            var conversions$$ = conversions;
            for (var c in conversions$$) {
                r.addConversion(conversions$$[c].from, conversions$$[c].to, conversions$$[c].factor);
            }

            return r;
        };

        var index$1 = __commonjs(function (module) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var toString = Object.prototype.toString;

        module.exports = function forEach (obj, fn, ctx) {
            if (toString.call(fn) !== '[object Function]') {
                throw new TypeError('iterator must be a function');
            }
            var l = obj.length;
            if (l === +l) {
                for (var i = 0; i < l; i++) {
                    fn.call(ctx, obj[i], i, obj);
                }
            } else {
                for (var k in obj) {
                    if (hasOwn.call(obj, k)) {
                        fn.call(ctx, obj[k], k, obj);
                    }
                }
            }
        };
        });

        var require$$0 = (index$1 && typeof index$1 === 'object' && 'default' in index$1 ? index$1['default'] : index$1);

        var index = __commonjs(function (module) {
        'use strict';

        var each = require$$0;
        module.exports = api;


        /**
         * Convenience wrapper around the api.
         * Calls `.get` when called with an `object` and a `pointer`.
         * Calls `.set` when also called with `value`.
         * If only supplied `object`, returns a partially applied function, mapped to the object.
         *
         * @param {Object} obj
         * @param {String|Array} pointer
         * @param value
         * @returns {*}
         */

        function api (obj, pointer, value) {
            // .set()
            if (arguments.length === 3) {
                return api.set(obj, pointer, value);
            }
            // .get()
            if (arguments.length === 2) {
                return api.get(obj, pointer);
            }
            // Return a partially applied function on `obj`.
            var wrapped = api.bind(api, obj);

            // Support for oo style
            for (var name in api) {
                if (api.hasOwnProperty(name)) {
                    wrapped[name] = api[name].bind(wrapped, obj);
                }
            }
            return wrapped;
        }


        /**
         * Lookup a json pointer in an object
         *
         * @param {Object} obj
         * @param {String|Array} pointer
         * @returns {*}
         */
        api.get = function get (obj, pointer) {
            var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);

            for (var i = 0; i < refTokens.length; ++i) {
                var tok = refTokens[i];
                if (!(typeof obj == 'object' && tok in obj)) {
                    throw new Error('Invalid reference token: ' + tok);
                }
                obj = obj[tok];
            }
            return obj;
        };

        /**
         * Sets a value on an object
         *
         * @param {Object} obj
         * @param {String|Array} pointer
         * @param value
         */
        api.set = function set (obj, pointer, value) {
            var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),
              nextTok = refTokens[0];

            for (var i = 0; i < refTokens.length - 1; ++i) {
                var tok = refTokens[i];
                if (tok === '-' && Array.isArray(obj)) {
                  tok = obj.length;
                }
                nextTok = refTokens[i + 1];

                if (!(tok in obj)) {
                    if (nextTok.match(/^(\d+|-)$/)) {
                        obj[tok] = [];
                    } else {
                        obj[tok] = {};
                    }
                }
                obj = obj[tok];
            }
            if (nextTok === '-' && Array.isArray(obj)) {
              nextTok = obj.length;
            }
            obj[nextTok] = value;
            return this;
        };

        /**
         * Removes an attribute
         *
         * @param {Object} obj
         * @param {String|Array} pointer
         */
        api.remove = function (obj, pointer) {
            var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
            var finalToken = refTokens[refTokens.length -1];
            if (finalToken === undefined) {
                throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
            }
            delete api.get(obj, refTokens.slice(0, -1))[finalToken];
        };

        /**
         * Returns a (pointer -> value) dictionary for an object
         *
         * @param obj
         * @param {function} descend
         * @returns {}
         */
        api.dict = function dict (obj, descend) {
            var results = {};
            api.walk(obj, function (value, pointer) {
                results[pointer] = value;
            }, descend);
            return results;
        };

        /**
         * Iterates over an object
         * Iterator: function (value, pointer) {}
         *
         * @param obj
         * @param {function} iterator
         * @param {function} descend
         */
        api.walk = function walk (obj, iterator, descend) {
            var refTokens = [];

            descend = descend || function (value) {
                var type = Object.prototype.toString.call(value);
                return type === '[object Object]' || type === '[object Array]';
            };

            (function next (cur) {
                each(cur, function (value, key) {
                    refTokens.push(String(key));
                    if (descend(value)) {
                        next(value);
                    } else {
                        iterator(value, api.compile(refTokens));
                    }
                    refTokens.pop();
                });
            }(obj));
        };

        /**
         * Tests if an object has a value for a json pointer
         *
         * @param obj
         * @param pointer
         * @returns {boolean}
         */
        api.has = function has (obj, pointer) {
            try {
                api.get(obj, pointer);
            } catch (e) {
                return false;
            }
            return true;
        };

        /**
         * Escapes a reference token
         *
         * @param str
         * @returns {string}
         */
        api.escape = function escape (str) {
            return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
        };

        /**
         * Unescapes a reference token
         *
         * @param str
         * @returns {string}
         */
        api.unescape = function unescape (str) {
            return str.replace(/~1/g, '/').replace(/~0/g, '~');
        };

        /**
         * Converts a json pointer into a array of reference tokens
         *
         * @param pointer
         * @returns {Array}
         */
        api.parse = function parse (pointer) {
            if (pointer === '') { return []; }
            if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }
            return pointer.substring(1).split(/\//).map(api.unescape);
        };

        /**
         * Builds a json pointer from a array of reference tokens
         *
         * @param refTokens
         * @returns {string}
         */
        api.compile = function compile (refTokens) {
            if (refTokens.length === 0) { return ''; }
            return '/' + refTokens.map(api.escape).join('/');
        };
        });

        var pointer = (index && typeof index === 'object' && 'default' in index ? index['default'] : index);

        var registry = UnitRegistry.newStandardRegistry();

        /**
         * Convert an entity to standardized units.
         * Note: modifies input JSON object in place
         * @param {Object} entity Flux entity parameters object
         * @returns {Object} A copy of the entity with standardized units.
         */
        function convertUnits (entity) {
            if (!entity.units) {
                return entity;
            }
            var units = entity.units;
            // Iterate over each unit specification and set it on the object
            for (var unitString in units) {
                // json-pointer requires leading slash, but for us it's optional
                var unitPath = unitString;
                if (unitString[0]!=='/') {
                    unitPath = '/'+unitString;
                }
                if (!pointer.has(entity, unitPath)) {
                    // TODO(Kyle): This should be a warning
                    // https://vannevar.atlassian.net/browse/LIB3D-709
                    // throw new FluxGeometryError('Invalid unit path ' + unitString);
                } else {
                    var unitValue = pointer.get(entity, unitPath);
                    if (unitValue == null) {
                        // TODO(Kyle): This should be a warning
                        // https://vannevar.atlassian.net/browse/LIB3D-709
                        // throw new FluxGeometryError('Invalid unit measure ' + unitString);
                        continue;
                    }
                    var unitMeasure = units[unitString];
                    var func = registry.unitConversionFunc(unitMeasure, DEFAULT_UNITS);
                    if (!func) {
                        // TODO(Kyle): This should be a warning
                        // https://vannevar.atlassian.net/browse/LIB3D-709
                        // throw new FluxGeometryError('Unknown units specified');
                        continue;
                    }
                    // _setPropIgnoreCase(prop, unitPath[j], func(unitValue));
                    pointer.set(entity, unitPath, func(unitValue));
                    entity.units[unitString] = DEFAULT_UNITS;
                }
            }
            return entity;
        }

        var ajv_min = __commonjs(function (module, exports, global) {
        /* ajv 3.8.10: Another JSON Schema Validator */
        !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var r;r="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,r.Ajv=e()}}(function(){var define,module,exports;return function e(r,t,a){function s(i,n){if(!t[i]){if(!r[i]){var l="function"==typeof require&&require;if(!n&&l)return l(i,!0);if(o)return o(i,!0);var c=new Error("Cannot find module '"+i+"'");throw c.code="MODULE_NOT_FOUND",c}var h=t[i]={exports:{}};r[i][0].call(h.exports,function(e){var t=r[i][1][e];return s(t?t:e)},h,h.exports,e,r,t,a)}return t[i].exports}for(var o="function"==typeof require&&require,i=0;a.length>i;i++)s(a[i]);return s}({1:[function(require,module,exports){"use strict";function setupAsync(e,r){r!==!1&&(r=!0);var t,a=e.async,s=e.transpile;switch(typeof s){case"string":var o=TRANSPILE[s];if(!o)throw new Error("bad transpiler: "+s);return e._transpileFunc=o(e,r);case"undefined":case"boolean":if("string"==typeof a){if(t=ASYNC[a],!t)throw new Error("bad async mode: "+a);return e.transpile=t(e,r)}for(var i=0;MODES.length>i;i++){var n=MODES[i];if(setupAsync(n,!1))return util.copy(n,e),e.transpile}throw new Error("generators, nodent and regenerator are not available");case"function":return e._transpileFunc=e.transpile;default:throw new Error("bad transpiler: "+s)}}function checkGenerators(opts,required){try{return eval("(function*(){})()"),!0}catch(e){if(required)throw new Error("generators not supported")}}function checkAsyncFunction(opts,required){try{return eval("(async function(){})()"),!0}catch(e){if(required)throw new Error("es7 async functions not supported")}}function getRegenerator(e,r){try{return regenerator||(regenerator=require("regenerator"),regenerator.runtime()),e.async&&e.async!==!0||(e.async="es7"),regeneratorTranspile}catch(t){if(r)throw new Error("regenerator not available")}}function regeneratorTranspile(e){return regenerator.compile(e).code}function getNodent(e,r){try{return nodent||(nodent=require("nodent")({log:!1,dontInstallRequireHook:!0})),"es7"!=e.async&&(e.async&&e.async!==!0&&console.warn("nodent transpiles only es7 async functions"),e.async="es7"),nodentTranspile}catch(t){if(r)throw new Error("nodent not available")}}function nodentTranspile(e){return nodent.compile(e,"",{promises:!0,sourcemap:!1}).code}function compileAsync(e,r){function t(e,r,a){function o(a){function o(a,o){if(a)return r(a);if(!s._refs[i]&&!s._schemas[i])try{s.addSchema(o,i)}catch(n){return void r(n)}t(e,r)}var i=a.missingSchema;if(s._refs[i]||s._schemas[i])return r(new Error("Schema "+i+" is loaded but"+a.missingRef+"cannot be resolved"));var n=s._loadingSchemas[i];n?"function"==typeof n?s._loadingSchemas[i]=[n,o]:n[n.length]=o:(s._loadingSchemas[i]=o,s._opts.loadSchema(i,function(e,r){var t=s._loadingSchemas[i];if(delete s._loadingSchemas[i],"function"==typeof t)t(e,r);else for(var a=0;t.length>a;a++)t[a](e,r)}))}function i(e,t){return a?void setTimeout(function(){r(e,t)}):r(e,t)}var n;try{n=s.compile(e)}catch(l){return void(l.missingSchema?o(l):i(l))}i(null,n)}var a,s=this;try{a=this._addSchema(e)}catch(o){return void setTimeout(function(){r(o)})}if(a.validate)setTimeout(function(){r(null,a.validate)});else{if("function"!=typeof this._opts.loadSchema)throw new Error("options.loadSchema should be a function");t(e,r,!0)}}module.exports={setup:setupAsync,compile:compileAsync};var util=require("./compile/util"),ASYNC={"*":checkGenerators,"co*":checkGenerators,es7:checkAsyncFunction},TRANSPILE={nodent:getNodent,regenerator:getRegenerator},MODES=[{async:"co*"},{async:"es7",transpile:"nodent"},{async:"co*",transpile:"regenerator"}],regenerator,nodent},{"./compile/util":10}],2:[function(e,r,t){"use strict";var a=r.exports=function(){this._cache={}};a.prototype.put=function(e,r){this._cache[e]=r},a.prototype.get=function(e){return this._cache[e]},a.prototype.del=function(e){delete this._cache[e]},a.prototype.clear=function(){this._cache={}}},{}],3:[function(e,r,t){"use strict";r.exports={$ref:e("../dotjs/ref"),allOf:e("../dotjs/allOf"),anyOf:e("../dotjs/anyOf"),dependencies:e("../dotjs/dependencies"),"enum":e("../dotjs/enum"),format:e("../dotjs/format"),items:e("../dotjs/items"),maximum:e("../dotjs/_limit"),minimum:e("../dotjs/_limit"),maxItems:e("../dotjs/_limitItems"),minItems:e("../dotjs/_limitItems"),maxLength:e("../dotjs/_limitLength"),minLength:e("../dotjs/_limitLength"),maxProperties:e("../dotjs/_limitProperties"),minProperties:e("../dotjs/_limitProperties"),multipleOf:e("../dotjs/multipleOf"),not:e("../dotjs/not"),oneOf:e("../dotjs/oneOf"),pattern:e("../dotjs/pattern"),properties:e("../dotjs/properties"),required:e("../dotjs/required"),uniqueItems:e("../dotjs/uniqueItems"),validate:e("../dotjs/validate")}},{"../dotjs/_limit":13,"../dotjs/_limitItems":14,"../dotjs/_limitLength":15,"../dotjs/_limitProperties":16,"../dotjs/allOf":17,"../dotjs/anyOf":18,"../dotjs/dependencies":20,"../dotjs/enum":21,"../dotjs/format":22,"../dotjs/items":23,"../dotjs/multipleOf":24,"../dotjs/not":25,"../dotjs/oneOf":26,"../dotjs/pattern":27,"../dotjs/properties":29,"../dotjs/ref":30,"../dotjs/required":31,"../dotjs/uniqueItems":33,"../dotjs/validate":34}],4:[function(e,r,t){"use strict";r.exports=function a(e,r){if(e===r)return!0;var t,s=Array.isArray(e),o=Array.isArray(r);if(s&&o){if(e.length!=r.length)return!1;for(t=0;e.length>t;t++)if(!a(e[t],r[t]))return!1;return!0}if(s!=o)return!1;if(e&&r&&"object"==typeof e&&"object"==typeof r){var i=Object.keys(e);if(i.length!==Object.keys(r).length)return!1;for(t=0;i.length>t;t++)if(void 0===r[i[t]])return!1;for(t=0;i.length>t;t++)if(!a(e[i[t]],r[i[t]]))return!1;return!0}return!1}},{}],5:[function(e,r,t){"use strict";function a(e){e="full"==e?"full":"fast";var r=d.copy(a[e]);for(var t in a.compare)r[t]={validate:r[t],compare:a.compare[t]};return r}function s(e){var r=e.match(p);if(!r)return!1;var t=+r[1],a=+r[2];return t>=1&&12>=t&&a>=1&&m[t]>=a}function o(e,r){var t=e.match(v);if(!t)return!1;var a=t[1],s=t[2],o=t[3],i=t[5];return 23>=a&&59>=s&&59>=o&&(!r||i)}function i(e){var r=e.split(w);return s(r[0])&&o(r[1],!0)}function n(e){return 255>=e.length&&y.test(e)}function l(e){return j.test(e)&&g.test(e)}function c(e){try{return new RegExp(e),!0}catch(r){return!1}}function h(e,r){return e&&r?e>r?1:r>e?-1:e===r?0:void 0:void 0}function u(e,r){return e&&r&&(e=e.match(v),r=r.match(v),e&&r)?(e=e[1]+e[2]+e[3]+(e[4]||""),r=r[1]+r[2]+r[3]+(r[4]||""),e>r?1:r>e?-1:e===r?0:void 0):void 0}function f(e,r){if(e&&r){e=e.split(w),r=r.split(w);var t=h(e[0],r[0]);if(void 0!==t)return t||u(e[1],r[1])}}var d=e("./util"),p=/^\d\d\d\d-(\d\d)-(\d\d)$/,m=[0,31,29,31,30,31,30,31,31,30,31,30,31],v=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i,y=/^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i,g=/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i,P=/^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,E=/^(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?$|^\#(?:\/(?:[a-z0-9_\-\.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)+)*(?:\/)?$/i,b=/^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?)$/;r.exports=a,a.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,uri:/^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,email:/^[a-z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:y,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:c,uuid:P,"json-pointer":E,"relative-json-pointer":b},a.full={date:s,time:o,"date-time":i,uri:l,email:/^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:n,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:c,uuid:P,"json-pointer":E,"relative-json-pointer":b},a.compare={date:h,time:u,"date-time":f};var w=/t|\s/i,j=/\/|\:/},{"./util":10}],6:[function(require,module,exports){"use strict";function compile(schema,root,localRefs,baseId){function localCompile(_schema,_root,localRefs,baseId){var isRoot=!_root||_root&&_root.schema==_schema;if(_root.schema!=root.schema)return compile.call(self,_schema,_root,localRefs,baseId);var $async=_schema.$async===!0;$async&&!opts.transpile&&async.setup(opts);var sourceCode=validateGenerator({isTop:!0,schema:_schema,isRoot:isRoot,baseId:baseId,root:_root,schemaPath:"",errSchemaPath:"#",errorPath:'""',RULES:RULES,validate:validateGenerator,util:util,resolve:resolve,resolveRef:resolveRef,usePattern:usePattern,useDefault:useDefault,useCustomRule:useCustomRule,opts:opts,formats:formats,self:self});sourceCode=vars(refVal,refValCode)+vars(patterns,patternCode)+vars(defaults,defaultCode)+vars(customRules,customRuleCode)+sourceCode,opts.beautify&&(beautify?sourceCode=beautify(sourceCode,opts.beautify):console.error('"npm install js-beautify" to use beautify option'));var validate,validateCode,transpile=opts._transpileFunc;try{validateCode=$async&&transpile?transpile(sourceCode):sourceCode,eval(validateCode),refVal[0]=validate}catch(e){throw console.error("Error compiling schema, function code:",validateCode),e}return validate.schema=_schema,validate.errors=null,validate.refs=refs,validate.refVal=refVal,validate.root=isRoot?validate:_root,$async&&(validate.async=!0),validate.sourceCode=sourceCode,validate}function resolveRef(e,r,t){r=resolve.url(e,r);var a,s,o=refs[r];if(void 0!==o)return a=refVal[o],s="refVal["+o+"]",resolvedRef(a,s);if(!t){var i=root.refs[r];if(void 0!==i)return a=root.refVal[i],s=addLocalRef(r,a),resolvedRef(a,s)}s=addLocalRef(r);var n=resolve.call(self,localCompile,root,r);if(!n){var l=localRefs&&localRefs[r];l&&(n=resolve.inlineRef(l,opts.inlineRefs)?l:compile.call(self,l,root,localRefs,e))}return n?(replaceLocalRef(r,n),resolvedRef(n,s)):void 0}function addLocalRef(e,r){var t=refVal.length;return refVal[t]=r,refs[e]=t,"refVal"+t}function replaceLocalRef(e,r){var t=refs[e];refVal[t]=r}function resolvedRef(e,r){return"object"==typeof e?{code:r,schema:e,inline:!0}:{code:r,async:e&&e.async}}function usePattern(e){var r=patternsHash[e];return void 0===r&&(r=patternsHash[e]=patterns.length,patterns[r]=e),"pattern"+r}function useDefault(e){switch(typeof e){case"boolean":case"number":return""+e;case"string":return util.toQuotedString(e);case"object":if(null===e)return"null";var r=stableStringify(e),t=defaultsHash[r];return void 0===t&&(t=defaultsHash[r]=defaults.length,defaults[t]=e),"default"+t}}function useCustomRule(e,r,t,a){var s,o=e.definition.compile,i=e.definition.inline,n=e.definition.macro;o?s=o.call(self,r,t):n?(s=n.call(self,r,t),opts.validateSchema!==!1&&self.validateSchema(s,!0)):s=i?i.call(self,a,e.keyword,r,t):e.definition.validate;var l=customRules.length;return customRules[l]=s,{code:"customRule"+l,validate:s}}var self=this,opts=this._opts,refVal=[void 0],refs={},patterns=[],patternsHash={},defaults=[],defaultsHash={},customRules=[];root=root||{schema:schema,refVal:refVal,refs:refs};var formats=this._formats,RULES=this.RULES;return localCompile(schema,root,localRefs,baseId)}function patternCode(e,r){return"var pattern"+e+" = new RegExp("+util.toQuotedString(r[e])+");"}function defaultCode(e){return"var default"+e+" = defaults["+e+"];"}function refValCode(e,r){return r[e]?"var refVal"+e+" = refVal["+e+"];":""}function customRuleCode(e){return"var customRule"+e+" = customRules["+e+"];"}function vars(e,r){if(!e.length)return"";for(var t="",a=0;e.length>a;a++)t+=r(a,e);return t}var resolve=require("./resolve"),util=require("./util"),stableStringify=require("json-stable-stringify"),async=require("../async"),beautify=function(){try{return require("js-beautify").js_beautify}catch(e){}}(),validateGenerator=require("../dotjs/validate");module.exports=compile;var co=require("co"),ucs2length=util.ucs2length,equal=require("./equal"),ValidationError=require("./validation_error")},{"../async":1,"../dotjs/validate":34,"./equal":4,"./resolve":7,"./util":10,"./validation_error":11,co:45,"json-stable-stringify":46}],7:[function(e,r,t){"use strict";function a(e,r,t){var o=this._refs[t];if("string"==typeof o){if(!this._refs[o])return a.call(this,e,r,o);o=this._refs[o]}if(o=o||this._schemas[t],o instanceof g)return n(o.schema,this._opts.inlineRefs)?o.schema:o.validate||this._compile(o);var i,l,c,h=s.call(this,r,t);return h&&(i=h.schema,r=h.root,c=h.baseId),i instanceof g?l=i.validate||e.call(this,i.schema,r,void 0,c):i&&(l=n(i,this._opts.inlineRefs)?i:e.call(this,i,r,void 0,c)),l}function s(e,r){var t=m.parse(r,!1,!0),a=u(t),s=h(e.schema.id);if(a!==s){var n=f(a),l=this._refs[n];if("string"==typeof l)return o.call(this,e,l,t);if(l instanceof g)l.validate||this._compile(l),e=l;else if(l=this._schemas[n],l instanceof g){if(l.validate||this._compile(l),n==f(r))return{schema:l,root:e,baseId:s};e=l}if(!e.schema)return;s=h(e.schema.id)}return i.call(this,t,s,e.schema,e)}function o(e,r,t){var a=s.call(this,e,r);if(a){var o=a.schema,n=a.baseId;return e=a.root,o.id&&(n=d(n,o.id)),i.call(this,t,n,o,e)}}function i(e,r,t,a){if(e.hash=e.hash||"","#/"==e.hash.slice(0,2)){for(var o=e.hash.split("/"),i=1;o.length>i;i++){var n=o[i];if(n){if(n=y.unescapeFragment(n),t=t[n],!t)break;if(t.id&&!P[n]&&(r=d(r,t.id)),t.$ref){var l=d(r,t.$ref),c=s.call(this,a,l);c&&(t=c.schema,a=c.root,r=c.baseId)}}}return t&&t!=a.schema?{schema:t,root:a,baseId:r}:void 0}}function n(e,r){return r===!1?!1:void 0===r||r===!0?l(e):r?c(e)<=r:void 0}function l(e){var r;if(Array.isArray(e)){for(var t=0;e.length>t;t++)if(r=e[t],"object"==typeof r&&!l(r))return!1}else for(var a in e){if("$ref"==a)return!1;if(r=e[a],"object"==typeof r&&!l(r))return!1}return!0}function c(e){var r,t=0;if(Array.isArray(e)){for(var a=0;e.length>a;a++)if(r=e[a],"object"==typeof r&&(t+=c(r)),t==1/0)return 1/0}else for(var s in e){if("$ref"==s)return 1/0;if(E[s])t++;else if(r=e[s],"object"==typeof r&&(t+=c(r)+1),t==1/0)return 1/0}return t}function h(e,r){r!==!1&&(e=f(e));var t=m.parse(e,!1,!0);return u(t)}function u(e){return(e.protocol||"")+(e.protocol?"//":"")+(e.host||"")+(e.path||"")+"#"}function f(e){return e?e.replace(b,""):""}function d(e,r){return r=f(r),m.resolve(e,r)}function p(e){function r(e,t,s){if(Array.isArray(e))for(var o=0;e.length>o;o++)r.call(this,e[o],t+"/"+o,s);else if(e&&"object"==typeof e){if("string"==typeof e.id){var i=s=s?m.resolve(s,e.id):e.id;i=f(i);var n=this._refs[i];if("string"==typeof n&&(n=this._refs[n]),n&&n.schema){if(!v(e,n.schema))throw new Error('id "'+i+'" resolves to more than one schema')}else if(i!=f(t))if("#"==i[0]){if(a[i]&&!v(e,a[i]))throw new Error('id "'+i+'" resolves to more than one schema');a[i]=e}else this._refs[i]=t}for(var l in e)r.call(this,e[l],t+"/"+y.escapeFragment(l),s)}}var t=f(e.id),a={};return r.call(this,e,h(t,!1),t),a}var m=e("url"),v=e("./equal"),y=e("./util"),g=e("./schema_obj");r.exports=a,a.normalizeId=f,a.fullPath=h,a.url=d,a.ids=p,a.inlineRef=n;var P=y.toHash(["properties","patternProperties","enum","dependencies","definitions"]),E=y.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]),b=/#\/?$/},{"./equal":4,"./schema_obj":9,"./util":10,url:43}],8:[function(e,r,t){"use strict";var a=e("./_rules"),s=e("./util");r.exports=function(){var e=[{type:"number",rules:["maximum","minimum","multipleOf"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","uniqueItems","items"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","properties"]},{rules:["$ref","enum","not","anyOf","oneOf","allOf"]}];return e.all=["type","additionalProperties","patternProperties"],e.keywords=["additionalItems","$schema","id","title","description","default"],e.types=["number","integer","string","array","object","boolean","null"],e.forEach(function(r){r.rules=r.rules.map(function(r){return e.all.push(r),{keyword:r,code:a[r]}})}),e.keywords=s.toHash(e.all.concat(e.keywords)),e.all=s.toHash(e.all),e.types=s.toHash(e.types),e}},{"./_rules":3,"./util":10}],9:[function(e,r,t){"use strict";function a(e){s.copy(e,this)}var s=e("./util");r.exports=a},{"./util":10}],10:[function(e,r,t){"use strict";function a(e,r){r=r||{};for(var t in e)r[t]=e[t];return r}function s(e,r,t){var a=t?" !== ":" === ",s=t?" || ":" && ",o=t?"!":"",i=t?"":"!";switch(e){case"null":return r+a+"null";case"array":return o+"Array.isArray("+r+")";case"object":return"("+o+r+s+"typeof "+r+a+'"object"'+s+i+"Array.isArray("+r+"))";case"integer":return"(typeof "+r+a+'"number"'+s+i+"("+r+" % 1))";default:return"typeof "+r+a+'"'+e+'"'}}function o(e,r){switch(e.length){case 1:return s(e[0],r,!0);default:var t="",a=n(e);a.array&&a.object&&(t=a["null"]?"(":"(!"+r+" || ",t+="typeof "+r+' !== "object")',delete a["null"],delete a.array,delete a.object),a.number&&delete a.integer;for(var o in a)t+=(t?" && ":"")+s(o,r,!0);return t}}function i(e){if(Array.isArray(e)){for(var r=[],t=0;e.length>t;t++){var a=e[t];$[a]&&(r[r.length]=a)}if(r.length)return r}else if($[e])return[e]}function n(e){for(var r={},t=0;e.length>t;t++)r[e[t]]=!0;return r}function l(e){return"number"==typeof e?"["+e+"]":S.test(e)?"."+e:"['"+e.replace(_,"\\$&")+"']"}function c(e){return e.replace(_,"\\$&")}function h(e){for(var r,t=0,a=e.length,s=0;a>s;)t++,r=e.charCodeAt(s++),r>=55296&&56319>=r&&a>s&&(r=e.charCodeAt(s),56320==(64512&r)&&s++);return t}function u(e,r){r+="[^0-9]";var t=e.match(new RegExp(r,"g"));return t?t.length:0}function f(e,r,t){return r+="([^0-9])",t=t.replace(/\$/g,"$$$$"),e.replace(new RegExp(r,"g"),t+"$1")}function d(e){return e.replace(R,"").replace(O,"").replace(k,"if (!($1))")}function p(e,r){var t=e.match(A);return t&&2===t.length?r?e.replace(q,"").replace(D,V):e.replace(I,"").replace(L,C):e}function m(e,r){for(var t in e)if(r[t])return!0}function v(e){return"'"+c(e)+"'"}function y(e,r,t,a){var s=t?"'/' + "+r+(a?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):a?"'[' + "+r+" + ']'":"'[\\'' + "+r+" + '\\']'";return E(e,s)}function g(e,r,t){var a=v(t?"/"+j(r):l(r));return E(e,a)}function P(e,r,t){var a=e.match(U);if(!a)throw new Error("Invalid relative JSON-pointer: "+e);var s=+a[1],o=a[2];if("#"==o){if(s>=r)throw new Error("Cannot access property/index "+s+" levels up, current level is "+r);return t[r-s]}if(s>r)throw new Error("Cannot access data "+s+" levels up, current level is "+r);var i="data"+(r-s||"");if(!o)return i;for(var n=i,c=o.split("/"),h=0;c.length>h;h++){var u=c[h];u&&(i+=l(x(u)),n+=" && "+i)}return n}function E(e,r){return'""'==e?r:(e+" + "+r).replace(/' \+ '/g,"")}function b(e){return x(decodeURIComponent(e))}function w(e){return encodeURIComponent(j(e))}function j(e){return e.replace(/~/g,"~0").replace(/\//g,"~1")}function x(e){return e.replace(/~1/g,"/").replace(/~0/g,"~")}r.exports={copy:a,checkDataType:s,checkDataTypes:o,coerceToTypes:i,toHash:n,getProperty:l,escapeQuotes:c,ucs2length:h,varOccurences:u,varReplace:f,cleanUpCode:d,cleanUpVarErrors:p,schemaHasRules:m,stableStringify:e("json-stable-stringify"),toQuotedString:v,getPathExpr:y,getPath:g,getData:P,unescapeFragment:b,escapeFragment:w,escapeJsonPointer:j};var $=n(["string","number","integer","boolean","null"]),S=/^[a-z$_][a-z$_0-9]*$/i,_=/'|\\/g,R=/else\s*{\s*}/g,O=/if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g,k=/if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g,A=/[^v\.]errors/g,I=/var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,q=/var errors = 0;|var vErrors = null;/g,L="return errors === 0;",C="validate.errors = null; return true;",D=/if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/,V="return true;",U=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/},{"json-stable-stringify":46}],11:[function(e,r,t){"use strict";function a(e){this.message="validation failed",this.errors=e,this.ajv=this.validation=!0}r.exports=a,a.prototype=Object.create(Error.prototype),a.prototype.constructor=a},{}],12:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s;if(a+="var "+u+" = undefined;",e.opts.format===!1)return a+=" "+u+" = true; ";var f=e.schema.format,d=e.opts.v5&&f.$data,p="";if(d){var m=e.util.getData(f.$data,o,e.dataPathArr),v="format"+s,y="compare"+s;a+=" var "+v+" = formats["+m+"] , "+y+" = "+v+" && "+v+".compare;"}else{var v=e.formats[f];if(!v||!v.compare)return a+="  "+u+" = true; ";var y="formats"+e.util.getProperty(f)+".compare"}var g="formatMaximum"==r,P="exclusiveFormat"+(g?"Maximum":"Minimum"),E=e.schema[P],b=e.opts.v5&&E&&E.$data,w=g?"<":">",j="result"+s,x=e.opts.v5&&i.$data,$=x?e.util.getData(i.$data,o,e.dataPathArr):i;if(x&&(a+=" var schema"+s+" = "+$+"; ",$="schema"+s),b){var S=e.util.getData(E.$data,o,e.dataPathArr),_="exclusive"+s,R="op"+s,O="' + "+R+" + '";a+=" var schemaExcl"+s+" = "+S+"; ",S="schemaExcl"+s,a+=" if (typeof "+S+" != 'boolean' && "+S+" !== undefined) { "+u+" = false; ";var t=P,k=k||[];k.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_exclusiveFormatLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: '"+P+" should be boolean' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var A=a;a=k.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+A+"]); ":" validate.errors = ["+A+"]; return false; ":" var err = "+A+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }  ",c&&(p+="}",a+=" else { "),x&&(a+=" if ("+$+" === undefined) "+u+" = true; else if (typeof "+$+" != 'string') "+u+" = false; else { ",p+="}"),d&&(a+=" if (!"+y+") "+u+" = true; else { ",p+="}"),a+=" var "+j+" = "+y+"("+h+",  ",a+=x?""+$:""+e.util.toQuotedString(i),a+=" ); if ("+j+" === undefined) "+u+" = false; var exclusive"+s+" = "+S+" === true; if ("+u+" === undefined) { "+u+" = exclusive"+s+" ? "+j+" "+w+" 0 : "+j+" "+w+"= 0; } if (!"+u+") var op"+s+" = exclusive"+s+" ? '"+w+"' : '"+w+"=';"}else{var _=E===!0,O=w;_||(O+="=");var R="'"+O+"'";x&&(a+=" if ("+$+" === undefined) "+u+" = true; else if (typeof "+$+" != 'string') "+u+" = false; else { ",p+="}"),d&&(a+=" if (!"+y+") "+u+" = true; else { ",p+="}"),a+=" var "+j+" = "+y+"("+h+",  ",a+=x?""+$:""+e.util.toQuotedString(i),a+=" ); if ("+j+" === undefined) "+u+" = false; if ("+u+" === undefined) "+u+" = "+j+" "+w,_||(a+="="),a+=" 0;"}a+=""+p+"if (!"+u+") { ";var t=r,k=k||[];k.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_formatLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { limit:  ',a+=x?""+$:""+e.util.toQuotedString(i),a+="  } ",e.opts.messages!==!1&&(a+=" , message: 'should be "+O+' "',a+=x?"' + "+$+" + '":""+e.util.escapeQuotes(i),a+="\"' "),e.opts.verbose&&(a+=" , schema:  ",a+=x?"validate.schema"+n:""+e.util.toQuotedString(i),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var A=a;return a=k.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+A+"]); ":" validate.errors = ["+A+"]; return false; ":" var err = "+A+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="}"}},{}],13:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s);var d="maximum"==r,p=d?"exclusiveMaximum":"exclusiveMinimum",m=e.schema[p],v=e.opts.v5&&m&&m.$data,y=d?"<":">",g=d?">":"<";if(v){var P=e.util.getData(m.$data,o,e.dataPathArr),E="exclusive"+s,b="op"+s,w="' + "+b+" + '";a+=" var schemaExcl"+s+" = "+P+"; ",P="schemaExcl"+s,a+=" var exclusive"+s+"; if (typeof "+P+" != 'boolean' && typeof "+P+" != 'undefined') { ";var t=p,j=j||[];j.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: '"+p+" should be boolean' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var x=a;a=j.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+x+"]); ":" validate.errors = ["+x+"]; return false; ":" var err = "+x+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else if( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'number') || "),a+=" ((exclusive"+s+" = "+P+" === true) ? "+h+" "+g+"= "+f+" : "+h+" "+g+" "+f+")) { var op"+s+" = exclusive"+s+" ? '"+y+"' : '"+y+"=';"}else{var E=m===!0,w=y;E||(w+="=");var b="'"+w+"'";a+=" if ( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'number') || "),a+=" "+h+" "+g,E&&(a+="="),a+=" "+f+") {"}var t=r,j=j||[];j.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_limit")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { comparison: '+b+", limit: "+f+", exclusive: "+E+" } ",e.opts.messages!==!1&&(a+=" , message: 'should be "+w+" ",a+=u?"' + "+f:""+i+"'"),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var x=a;return a=j.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+x+"]); ":" validate.errors = ["+x+"]; return false; ":" var err = "+x+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",c&&(a+=" else { "),a}},{}],14:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s);var d="maxItems"==r?">":"<";a+="if ( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'number') || "),a+=" "+h+".length "+d+" "+f+") { ";var t=r,p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_limitItems")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { limit: '+f+" } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have ",a+="maxItems"==r?"more":"less",a+=" than ",a+=u?"' + "+f+" + '":""+i,a+=" items' "),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;return a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} ",c&&(a+=" else { "),a}},{}],15:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s);var d="maxLength"==r?">":"<";a+="if ( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'number') || "),a+=e.opts.unicode===!1?" "+h+".length ":" ucs2length("+h+") ",a+=" "+d+" "+f+") { ";var t=r,p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_limitLength")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { limit: '+f+" } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT be ",a+="maxLength"==r?"longer":"shorter",a+=" than ",a+=u?"' + "+f+" + '":""+i,a+=" characters' "),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;return a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} ",c&&(a+=" else { "),a}},{}],16:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;
        u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s);var d="maxProperties"==r?">":"<";a+="if ( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'number') || "),a+=" Object.keys("+h+").length "+d+" "+f+") { ";var t=r,p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"_limitProperties")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { limit: '+f+" } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have ",a+="maxProperties"==r?"more":"less",a+=" than ",a+=u?"' + "+f+" + '":""+i,a+=" properties' "),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;return a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} ",c&&(a+=" else { "),a}},{}],17:[function(e,r,t){"use strict";r.exports=function(e,r){var t=" ",a=e.schema[r],s=e.schemaPath+"."+r,o=e.errSchemaPath+"/"+r,i=!e.opts.allErrors,n=e.util.copy(e),l="";n.level++;var c=a;if(c)for(var h,u=-1,f=c.length-1;f>u;)h=c[u+=1],e.util.schemaHasRules(h,e.RULES.all)&&(n.schema=h,n.schemaPath=s+"["+u+"]",n.errSchemaPath=o+"/"+u,t+=" "+e.validate(n)+"  ",i&&(t+=" if (valid"+n.level+") { ",l+="}"));return i&&(t+=" "+l.slice(0,-1)),t=e.util.cleanUpCode(t)}},{}],18:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="errs__"+s,d=e.util.copy(e),p="";d.level++;var m=i.every(function(r){return e.util.schemaHasRules(r,e.RULES.all)});if(m){a+=" var "+f+" = errors; var "+u+" = false;  ";var v=e.compositeRule;e.compositeRule=d.compositeRule=!0;var y=i;if(y)for(var g,P=-1,E=y.length-1;E>P;)g=y[P+=1],d.schema=g,d.schemaPath=n+"["+P+"]",d.errSchemaPath=l+"/"+P,a+=" "+e.validate(d)+" "+u+" = "+u+" || valid"+d.level+"; if (!"+u+") { ",p+="}";e.compositeRule=d.compositeRule=v,a+=" "+p+" if (!"+u+") {  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"anyOf")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should match some schema in anyOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } "),a=e.util.cleanUpCode(a)}else c&&(a+=" if (true) { ");return a}},{}],19:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f=e.opts.v5&&i.$data,d=f?e.util.getData(i.$data,o,e.dataPathArr):i;f&&(a+=" var schema"+s+" = "+d+"; ",d="schema"+s),f||(a+=" var schema"+s+" = validate.schema"+n+";"),a+="var "+u+" = equal("+h+", schema"+s+"); if (!"+u+") {   ";var p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"constant")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should be equal to constant' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;return a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }"}},{}],20:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="errs__"+s,f=e.util.copy(e),d="";f.level++;var p={},m={};for(P in i){var v=i[P],y=Array.isArray(v)?m:p;y[P]=v}a+="var "+u+" = errors;";var g=e.errorPath;a+="var missing"+s+";";for(var P in m){y=m[P],a+=" if ("+h+e.util.getProperty(P)+" !== undefined && ( ";var E=y;if(E)for(var b,w=-1,j=E.length-1;j>w;){b=E[w+=1],w&&(a+=" || ");var x=e.util.getProperty(b);a+=" ( "+h+x+" === undefined && (missing"+s+" = "+e.util.toQuotedString(e.opts.jsonPointers?b:x)+") ) "}a+=")) {  ";var $="missing"+s,S="' + "+$+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(g,$,!0):g+" + "+$);var _=_||[];_.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"dependencies")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { property: '"+e.util.escapeQuotes(P)+"', missingProperty: '"+S+"', depsCount: "+y.length+", deps: '"+e.util.escapeQuotes(1==y.length?y[0]:y.join(", "))+"' } ",e.opts.messages!==!1&&(a+=" , message: 'should have ",a+=1==y.length?"property "+e.util.escapeQuotes(y[0]):"properties "+e.util.escapeQuotes(y.join(", ")),a+=" when property "+e.util.escapeQuotes(P)+" is present' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var R=a;a=_.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+R+"]); ":" validate.errors = ["+R+"]; return false; ":" var err = "+R+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }   ",c&&(d+="}",a+=" else { ")}e.errorPath=g;for(var P in p){var v=p[P];e.util.schemaHasRules(v,e.RULES.all)&&(a+=" valid"+f.level+" = true; if ("+h+"['"+P+"'] !== undefined) { ",f.schema=v,f.schemaPath=n+e.util.getProperty(P),f.errSchemaPath=l+"/"+e.util.escapeFragment(P),a+=" "+e.validate(f)+" }  ",c&&(a+=" if (valid"+f.level+") { ",d+="}"))}return c&&(a+="   "+d+" if ("+u+" == errors) {"),a=e.util.cleanUpCode(a)}},{}],21:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f=e.opts.v5&&i.$data,d=f?e.util.getData(i.$data,o,e.dataPathArr):i;f&&(a+=" var schema"+s+" = "+d+"; ",d="schema"+s);var p="i"+s;f||(a+=" var schema"+s+" = validate.schema"+n+";"),a+="var "+u+";",f&&(a+=" if (schema"+s+" === undefined) "+u+" = true; else if (!Array.isArray(schema"+s+")) "+u+" = false; else {"),a+=""+u+" = false;for (var "+p+"=0; "+p+"<schema"+s+".length; "+p+"++) if (equal("+h+", schema"+s+"["+p+"])) { "+u+" = true; break; }",f&&(a+="  }  "),a+=" if (!"+u+") {   ";var m=m||[];m.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"enum")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should be equal to one of the allowed values' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var v=a;return a=m.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+v+"]); ":" validate.errors = ["+v+"]; return false; ":" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",c&&(a+=" else { "),a}},{}],22:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||"");if(e.opts.format===!1)return c&&(a+=" if (true) { "),a;var u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;if(u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s),u){var d="format"+s;a+=" var "+d+" = formats["+f+"]; var isObject"+s+" = typeof "+d+" == 'object' && !("+d+" instanceof RegExp) && "+d+".validate; if (isObject"+s+") { var async"+s+" = "+d+".async; "+d+" = "+d+".validate; } if (  ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'string') || "),a+=" ("+d+" && !(typeof "+d+" == 'function' ? ",a+=e.async?" (async"+s+" ? "+e.yieldAwait+" "+d+"("+h+") : "+d+"("+h+")) ":" "+d+"("+h+") ",a+=" : "+d+".test("+h+")))) {"}else{var d=e.formats[i];if(!d)return c&&(a+=" if (true) { "),a;var p="object"==typeof d&&!(d instanceof RegExp)&&d.validate;if(p){var m=d.async===!0;d=d.validate}if(m){if(!e.async)throw new Error("async format in sync schema");var v="formats"+e.util.getProperty(i)+".validate";a+=" if (!("+e.yieldAwait+" "+v+"("+h+"))) { "}else{a+=" if (! ";var v="formats"+e.util.getProperty(i);p&&(v+=".validate"),a+="function"==typeof d?" "+v+"("+h+") ":" "+v+".test("+h+") ",a+=") { "}}var y=y||[];y.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"format")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { format:  ',a+=u?""+f:""+e.util.toQuotedString(i),a+="  } ",e.opts.messages!==!1&&(a+=" , message: 'should match format \"",a+=u?"' + "+f+" + '":""+e.util.escapeQuotes(i),a+="\"' "),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+e.util.toQuotedString(i),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var g=a;return a=y.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+g+"]); ":" validate.errors = ["+g+"]; return false; ":" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",c&&(a+=" else { "),a}},{}],23:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="errs__"+s,d=e.util.copy(e),p="";d.level++;var m=d.dataLevel=e.dataLevel+1,v="data"+m;if(a+="var "+f+" = errors;var "+u+";",Array.isArray(i)){var y=e.schema.additionalItems;if(y===!1){a+=" "+u+" = "+h+".length <= "+i.length+"; ";var g=l;l=e.errSchemaPath+"/additionalItems",a+="  if (!"+u+") {   ";var P=P||[];P.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"additionalItems")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { limit: '+i.length+" } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have more than "+i.length+" items' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var E=a;a=P.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+E+"]); ":" validate.errors = ["+E+"]; return false; ":" var err = "+E+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",l=g,c&&(p+="}",a+=" else { ")}var b=i;if(b)for(var w,j=-1,x=b.length-1;x>j;)if(w=b[j+=1],e.util.schemaHasRules(w,e.RULES.all)){a+=" valid"+d.level+" = true; if ("+h+".length > "+j+") { ";var $=h+"["+j+"]";d.schema=w,d.schemaPath=n+"["+j+"]",d.errSchemaPath=l+"/"+j,d.errorPath=e.util.getPathExpr(e.errorPath,j,e.opts.jsonPointers,!0),d.dataPathArr[m]=j;var S=e.validate(d);a+=e.util.varOccurences(S,v)<2?" "+e.util.varReplace(S,v,$)+" ":" var "+v+" = "+$+"; "+S+" ",a+=" }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}")}if("object"==typeof y&&e.util.schemaHasRules(y,e.RULES.all)){d.schema=y,d.schemaPath=e.schemaPath+".additionalItems",d.errSchemaPath=e.errSchemaPath+"/additionalItems",a+=" valid"+d.level+" = true; if ("+h+".length > "+i.length+") {  for (var i"+s+" = "+i.length+"; i"+s+" < "+h+".length; i"+s+"++) { ",d.errorPath=e.util.getPathExpr(e.errorPath,"i"+s,e.opts.jsonPointers,!0);var $=h+"[i"+s+"]";d.dataPathArr[m]="i"+s;var S=e.validate(d);a+=e.util.varOccurences(S,v)<2?" "+e.util.varReplace(S,v,$)+" ":" var "+v+" = "+$+"; "+S+" ",c&&(a+=" if (!valid"+d.level+") break; "),a+=" } }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}")}}else if(e.util.schemaHasRules(i,e.RULES.all)){d.schema=i,d.schemaPath=n,d.errSchemaPath=l,a+="  for (var i"+s+" = 0; i"+s+" < "+h+".length; i"+s+"++) { ",d.errorPath=e.util.getPathExpr(e.errorPath,"i"+s,e.opts.jsonPointers,!0);var $=h+"[i"+s+"]";d.dataPathArr[m]="i"+s;var S=e.validate(d);a+=e.util.varOccurences(S,v)<2?" "+e.util.varReplace(S,v,$)+" ":" var "+v+" = "+$+"; "+S+" ",c&&(a+=" if (!valid"+d.level+") break; "),a+=" }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}")}return c&&(a+=" "+p+" if ("+f+" == errors) {"),a=e.util.cleanUpCode(a)}},{}],24:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s),a+="var division"+s+";if (",u&&(a+=" "+f+" !== undefined && ( typeof "+f+" != 'number' || "),a+=" (division"+s+" = "+h+" / "+f+", ",a+=e.opts.multipleOfPrecision?" Math.abs(Math.round(division"+s+") - division"+s+") > 1e-"+e.opts.multipleOfPrecision+" ":" division"+s+" !== parseInt(division"+s+") ",a+=" ) ",u&&(a+="  )  "),a+=" ) {   ";var d=d||[];d.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"multipleOf")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { multipleOf: '+f+" } ",e.opts.messages!==!1&&(a+=" , message: 'should be multiple of ",a+=u?"' + "+f:""+i+"'"),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var p=a;return a=d.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+p+"]); ":" validate.errors = ["+p+"]; return false; ":" var err = "+p+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} ",c&&(a+=" else { "),a}},{}],25:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="errs__"+s,f=e.util.copy(e);if(f.level++,e.util.schemaHasRules(i,e.RULES.all)){f.schema=i,f.schemaPath=n,f.errSchemaPath=l,a+=" var "+u+" = errors;  ";var d=e.compositeRule;e.compositeRule=f.compositeRule=!0,f.createErrors=!1;var p;f.opts.allErrors&&(p=f.opts.allErrors,f.opts.allErrors=!1),a+=" "+e.validate(f)+" ",f.createErrors=!0,p&&(f.opts.allErrors=p),e.compositeRule=f.compositeRule=d,a+=" if (valid"+f.level+") {   ";var m=m||[];m.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"not")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var v=a;a=m.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+v+"]); ":" validate.errors = ["+v+"]; return false; ":" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else {  errors = "+u+"; if (vErrors !== null) { if ("+u+") vErrors.length = "+u+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } ")}else a+="  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"not")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",c&&(a+=" if (false) { ");return a}},{}],26:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="errs__"+s,d=e.util.copy(e),p="";d.level++,a+="var "+f+" = errors;var prevValid"+s+" = false;var "+u+" = false; ";var m=e.compositeRule;e.compositeRule=d.compositeRule=!0;var v=i;if(v)for(var y,g=-1,P=v.length-1;P>g;)y=v[g+=1],e.util.schemaHasRules(y,e.RULES.all)?(d.schema=y,d.schemaPath=n+"["+g+"]",d.errSchemaPath=l+"/"+g,a+=" "+e.validate(d)+" "):a+=" var valid"+d.level+" = true; ",g&&(a+=" if (valid"+d.level+" && prevValid"+s+") "+u+" = false; else { ",p+="}"),a+=" if (valid"+d.level+") "+u+" = prevValid"+s+" = true;";e.compositeRule=d.compositeRule=m,a+=""+p+"if (!"+u+") {   ";var E=E||[];E.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"oneOf")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: {} ',e.opts.messages!==!1&&(a+=" , message: 'should match exactly one schema in oneOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var b=a;return a=E.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+b+"]); ":" validate.errors = ["+b+"]; return false; ":" var err = "+b+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; }",e.opts.allErrors&&(a+=" } "),a}},{}],27:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u=e.opts.v5&&i.$data,f=u?e.util.getData(i.$data,o,e.dataPathArr):i;u&&(a+=" var schema"+s+" = "+f+"; ",f="schema"+s);var d=u?"(new RegExp("+f+"))":e.usePattern(i);a+="if ( ",u&&(a+=" ("+f+" !== undefined && typeof "+f+" != 'string') || "),a+=" !"+d+".test("+h+") ) {   ";var p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"pattern")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { pattern:  ',a+=u?""+f:""+e.util.toQuotedString(i),a+="  } ",e.opts.messages!==!1&&(a+=" , message: 'should match pattern \"",a+=u?"' + "+f+" + '":""+e.util.escapeQuotes(i),a+="\"' "),e.opts.verbose&&(a+=" , schema:  ",a+=u?"validate.schema"+n:""+e.util.toQuotedString(i),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;return a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+="} ",c&&(a+=" else { "),a}},{}],28:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="key"+s,d="patternMatched"+s,p="";a+="var "+u+" = true;";var m=i;if(m)for(var v,y=-1,g=m.length-1;g>y;){v=m[y+=1],a+=" var "+d+" = false; for (var "+f+" in "+h+") { "+d+" = "+e.usePattern(v)+".test("+f+"); if ("+d+") break; } ";var P=e.util.escapeQuotes(v);a+=" if (!"+d+") { "+u+" = false;  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"patternRequired")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingPattern: '"+P+"' } ",e.opts.messages!==!1&&(a+=" , message: 'should have property matching pattern \\'"+P+"\\'' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ",c&&(p+="}",a+=" else { ")}return a+=""+p}},{}],29:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="errs__"+s,d=e.util.copy(e),p="";d.level++;var m=d.dataLevel=e.dataLevel+1,v="data"+m,y=Object.keys(i||{}),g=e.schema.patternProperties||{},P=Object.keys(g),E=e.schema.additionalProperties,b=y.length||P.length,w=E===!1,j="object"==typeof E&&Object.keys(E).length,x=e.opts.removeAdditional,$=w||j||x,S=e.schema.required;if(S&&(!e.opts.v5||!S.$data)&&e.opts.loopRequired>S.length)var _=e.util.toHash(S);if(e.opts.v5)var R=e.schema.patternGroups||{},O=Object.keys(R);if(a+="var "+f+" = errors;var valid"+d.level+" = true;",$){if(a+=" for (var key"+s+" in "+h+") { ",b){if(a+=" var isAdditional"+s+" = !(false ",y.length)if(y.length>5)a+=" || validate.schema"+n+"[key"+s+"] ";else{var k=y;if(k)for(var A,I=-1,q=k.length-1;q>I;)A=k[I+=1],a+=" || key"+s+" == "+e.util.toQuotedString(A)+" "}if(P.length){var L=P;if(L)for(var C,D=-1,V=L.length-1;V>D;)C=L[D+=1],a+=" || "+e.usePattern(C)+".test(key"+s+") "}if(e.opts.v5&&O&&O.length){var U=O;if(U)for(var z,D=-1,T=U.length-1;T>D;)z=U[D+=1],a+=" || "+e.usePattern(z)+".test(key"+s+") "}a+=" ); if (isAdditional"+s+") { "}if("all"==x)a+=" delete "+h+"[key"+s+"]; ";else{var M=e.errorPath,N="' + key"+s+" + '";if(e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(e.errorPath,"key"+s,e.opts.jsonPointers)),w)if(x)a+=" delete "+h+"[key"+s+"]; ";else{a+=" valid"+d.level+" = false; ";var F=l;l=e.errSchemaPath+"/additionalProperties";var Q=Q||[];Q.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"additionalProperties")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { additionalProperty: '"+N+"' } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have additional properties' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var H=a;a=Q.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+H+"]); ":" validate.errors = ["+H+"]; return false; ":" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l=F,c&&(a+=" break; ")}else if(j)if("failing"==x){a+=" var "+f+" = errors;  ";var G=e.compositeRule;e.compositeRule=d.compositeRule=!0,d.schema=E,d.schemaPath=e.schemaPath+".additionalProperties",d.errSchemaPath=e.errSchemaPath+"/additionalProperties",d.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,"key"+s,e.opts.jsonPointers);var J=h+"[key"+s+"]";d.dataPathArr[m]="key"+s;var K=e.validate(d);a+=e.util.varOccurences(K,v)<2?" "+e.util.varReplace(K,v,J)+" ":" var "+v+" = "+J+"; "+K+" ",a+=" if (!valid"+d.level+") { errors = "+f+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+h+"[key"+s+"]; }  ",e.compositeRule=d.compositeRule=G}else{d.schema=E,d.schemaPath=e.schemaPath+".additionalProperties",d.errSchemaPath=e.errSchemaPath+"/additionalProperties",d.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,"key"+s,e.opts.jsonPointers);var J=h+"[key"+s+"]";d.dataPathArr[m]="key"+s;var K=e.validate(d);a+=e.util.varOccurences(K,v)<2?" "+e.util.varReplace(K,v,J)+" ":" var "+v+" = "+J+"; "+K+" ",c&&(a+=" if (!valid"+d.level+") break; ")}e.errorPath=M}b&&(a+=" } "),a+=" }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}")}var B=e.opts.useDefaults&&!e.compositeRule;if(y.length){var Y=y;if(Y)for(var A,Z=-1,W=Y.length-1;W>Z;){A=Y[Z+=1];var X=i[A];if(e.util.schemaHasRules(X,e.RULES.all)){var ee=e.util.getProperty(A),J=h+ee,re=B&&void 0!==X["default"];d.schema=X,d.schemaPath=n+ee,d.errSchemaPath=l+"/"+e.util.escapeFragment(A),d.errorPath=e.util.getPath(e.errorPath,A,e.opts.jsonPointers),d.dataPathArr[m]=e.util.toQuotedString(A);var K=e.validate(d);if(e.util.varOccurences(K,v)<2){K=e.util.varReplace(K,v,J);var te=J}else{var te=v;a+=" var "+v+" = "+J+"; "}if(re)a+=" "+K+" ";else{if(_&&_[A]){a+=" if ("+te+" === undefined) { valid"+d.level+" = false; ";var M=e.errorPath,F=l,ae=e.util.escapeQuotes(A);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(M,A,e.opts.jsonPointers)),l=e.errSchemaPath+"/required";var Q=Q||[];Q.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+ae+"' } ",e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+ae+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var H=a;a=Q.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+H+"]); ":" validate.errors = ["+H+"]; return false; ":" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l=F,e.errorPath=M,a+=" } else { "}else a+=c?" if ("+te+" === undefined) { valid"+d.level+" = true; } else { ":" if ("+te+" !== undefined) { ";a+=" "+K+" } "}}c&&(a+=" if (valid"+d.level+") { ",p+="}")}}var se=P;if(se)for(var C,oe=-1,ie=se.length-1;ie>oe;){C=se[oe+=1];var X=g[C];if(e.util.schemaHasRules(X,e.RULES.all)){d.schema=X,d.schemaPath=e.schemaPath+".patternProperties"+e.util.getProperty(C),d.errSchemaPath=e.errSchemaPath+"/patternProperties/"+e.util.escapeFragment(C),a+=" for (var key"+s+" in "+h+") { if ("+e.usePattern(C)+".test(key"+s+")) { ",d.errorPath=e.util.getPathExpr(e.errorPath,"key"+s,e.opts.jsonPointers);var J=h+"[key"+s+"]";d.dataPathArr[m]="key"+s;var K=e.validate(d);a+=e.util.varOccurences(K,v)<2?" "+e.util.varReplace(K,v,J)+" ":" var "+v+" = "+J+"; "+K+" ",c&&(a+=" if (!valid"+d.level+") break; "),a+=" } ",c&&(a+=" else valid"+d.level+" = true; "),a+=" }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}")}}if(e.opts.v5){var ne=O;if(ne)for(var z,le=-1,ce=ne.length-1;ce>le;){z=ne[le+=1];var he=R[z],X=he.schema;if(e.util.schemaHasRules(X,e.RULES.all)){d.schema=X,d.schemaPath=e.schemaPath+".patternGroups"+e.util.getProperty(z)+".schema",d.errSchemaPath=e.errSchemaPath+"/patternGroups/"+e.util.escapeFragment(z)+"/schema",a+=" var pgPropCount"+s+" = 0; for (var key"+s+" in "+h+") { if ("+e.usePattern(z)+".test(key"+s+")) { pgPropCount"+s+"++; ",d.errorPath=e.util.getPathExpr(e.errorPath,"key"+s,e.opts.jsonPointers);var J=h+"[key"+s+"]";d.dataPathArr[m]="key"+s;var K=e.validate(d);a+=e.util.varOccurences(K,v)<2?" "+e.util.varReplace(K,v,J)+" ":" var "+v+" = "+J+"; "+K+" ",c&&(a+=" if (!valid"+d.level+") break; "),a+=" } ",c&&(a+=" else valid"+d.level+" = true; "),a+=" }  ",c&&(a+=" if (valid"+d.level+") { ",p+="}");var ue=he.minimum,fe=he.maximum;if(void 0!==ue||void 0!==fe){a+=" var "+u+" = true; ";var F=l;if(void 0!==ue){var de=ue,pe="minimum",me="less";a+=" "+u+" = pgPropCount"+s+" >= "+ue+"; ",l=e.errSchemaPath+"/patternGroups/minimum",a+="  if (!"+u+") {   ";var Q=Q||[];Q.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"patternGroups")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { reason: '"+pe+"', limit: "+de+", pattern: '"+e.util.escapeQuotes(z)+"' } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have "+me+" than "+de+' properties matching pattern "'+e.util.escapeQuotes(z)+"\"' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var H=a;a=Q.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+H+"]); ":" validate.errors = ["+H+"]; return false; ":" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",void 0!==fe&&(a+=" else ")}if(void 0!==fe){var de=fe,pe="maximum",me="more";a+=" "+u+" = pgPropCount"+s+" <= "+fe+"; ",l=e.errSchemaPath+"/patternGroups/maximum",a+="  if (!"+u+") {   ";var Q=Q||[];Q.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"patternGroups")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { reason: '"+pe+"', limit: "+de+", pattern: '"+e.util.escapeQuotes(z)+"' } ",e.opts.messages!==!1&&(a+=" , message: 'should NOT have "+me+" than "+de+' properties matching pattern "'+e.util.escapeQuotes(z)+"\"' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var H=a;a=Q.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+H+"]); ":" validate.errors = ["+H+"]; return false; ":" var err = "+H+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } "}l=F,c&&(a+=" if ("+u+") { ",p+="}")}}}}return c&&(a+=" "+p+" if ("+f+" == errors) {"),a=e.util.cleanUpCode(a)}},{}],30:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a,s,o=" ",i=e.level,n=e.dataLevel,l=e.schema[r],c=e.errSchemaPath+"/"+r,h=!e.opts.allErrors,u="data"+(n||""),f="valid"+i;if("#"==l||"#/"==l)e.isRoot?(a=e.async,s="validate"):(a=e.root.schema.$async===!0,s="root.refVal[0]");else{var d=e.resolveRef(e.baseId,l,e.isRoot);if(void 0===d){var p="can't resolve reference "+l+" from id "+e.baseId;if("fail"==e.opts.missingRefs){console.log(p);var m=m||[];m.push(o),o="",e.createErrors!==!1?(o+=" { keyword: '"+(t||"$ref")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+c+"\" , params: { ref: '"+e.util.escapeQuotes(l)+"' } ",e.opts.messages!==!1&&(o+=" , message: 'can\\'t resolve reference "+e.util.escapeQuotes(l)+"' "),e.opts.verbose&&(o+=" , schema: "+e.util.toQuotedString(l)+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+u+" "),o+=" } "):o+=" {} ";var v=o;o=m.pop(),o+=!e.compositeRule&&h?e.async?" throw new ValidationError(["+v+"]); ":" validate.errors = ["+v+"]; return false; ":" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",h&&(o+=" if (false) { ")}else{if("ignore"!=e.opts.missingRefs){var y=new Error(p);throw y.missingRef=e.resolve.url(e.baseId,l),y.missingSchema=e.resolve.normalizeId(e.resolve.fullPath(y.missingRef)),y}console.log(p),h&&(o+=" if (true) { ")}}else if(d.inline){var g=e.util.copy(e);g.level++,g.schema=d.schema,g.schemaPath="",g.errSchemaPath=l;var P=e.validate(g).replace(/validate\.schema/g,d.code);o+=" "+P+" ",h&&(o+=" if (valid"+g.level+") { ")}else a=d.async===!0,s=d.code}if(s){var m=m||[];m.push(o),o="",o+=e.opts.passContext?" "+s+".call(this, ":" "+s+"( ",o+=" "+u+", (dataPath || '')",'""'!=e.errorPath&&(o+=" + "+e.errorPath),o+=n?" , data"+(n-1||"")+" , "+e.dataPathArr[n]+" ":" , parentData , parentDataProperty ",o+=")  ";var E=o;if(o=m.pop(),a){if(!e.async)throw new Error("async schema referenced by sync schema");o+=" try { ",h&&(o+="var "+f+" ="),o+=" "+e.yieldAwait+" "+E+"; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } ",h&&(o+=" if ("+f+") { ")}else o+=" if (!"+E+") { if (vErrors === null) vErrors = "+s+".errors; else vErrors = vErrors.concat("+s+".errors); errors = vErrors.length; } ",h&&(o+=" else { ")}return o}},{}],31:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f=e.opts.v5&&i.$data,d=f?e.util.getData(i.$data,o,e.dataPathArr):i;if(f&&(a+=" var schema"+s+" = "+d+"; ",d="schema"+s),!f)if(e.opts.loopRequired>i.length&&e.schema.properties&&Object.keys(e.schema.properties).length){var p=[],m=i;if(m)for(var v,y=-1,g=m.length-1;g>y;){v=m[y+=1];var P=e.schema.properties[v];P&&e.util.schemaHasRules(P,e.RULES.all)||(p[p.length]=v)}}else var p=i;if(f||p.length){var E=e.errorPath,b=f||p.length>=e.opts.loopRequired;if(c)if(a+=" var missing"+s+"; ",b){f||(a+=" var schema"+s+" = validate.schema"+n+"; ");var w="i"+s,j="schema"+s+"["+w+"]",x="' + "+j+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(E,j,e.opts.jsonPointers)),a+=" var "+u+" = true; ",f&&(a+=" if (schema"+s+" === undefined) "+u+" = true; else if (!Array.isArray(schema"+s+")) "+u+" = false; else {"),a+=" for (var "+w+" = 0; "+w+" < schema"+s+".length; "+w+"++) { "+u+" = "+h+"[schema"+s+"["+w+"]] !== undefined; if (!"+u+") break; } ",f&&(a+="  }  "),a+="  if (!"+u+") {   ";var $=$||[];$.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+x+"' } ",
        e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+x+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var S=a;a=$.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+S+"]); ":" validate.errors = ["+S+"]; return false; ":" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}else{a+=" if ( ";var _=p;if(_)for(var R,w=-1,O=_.length-1;O>w;){R=_[w+=1],w&&(a+=" || ");var k=e.util.getProperty(R);a+=" ( "+h+k+" === undefined && (missing"+s+" = "+e.util.toQuotedString(e.opts.jsonPointers?R:k)+") ) "}a+=") {  ";var j="missing"+s,x="' + "+j+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(E,j,!0):E+" + "+j);var $=$||[];$.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+x+"' } ",e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+x+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var S=a;a=$.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+S+"]); ":" validate.errors = ["+S+"]; return false; ":" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { "}else if(b){f||(a+=" var schema"+s+" = validate.schema"+n+"; ");var w="i"+s,j="schema"+s+"["+w+"]",x="' + "+j+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(E,j,e.opts.jsonPointers)),f&&(a+=" if (schema"+s+" && !Array.isArray(schema"+s+")) {  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+x+"' } ",e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+x+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (schema"+s+" !== undefined) { "),a+=" for (var "+w+" = 0; "+w+" < schema"+s+".length; "+w+"++) { if ("+h+"[schema"+s+"["+w+"]] === undefined) {  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+x+"' } ",e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+x+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",f&&(a+="  }  ")}else{var A=p;if(A)for(var v,w=-1,I=A.length-1;I>w;){v=A[w+=1];var k=e.util.getProperty(v),x=e.util.escapeQuotes(v);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(E,v,e.opts.jsonPointers)),a+=" if ("+h+k+" === undefined) {  var err =   ",e.createErrors!==!1?(a+=" { keyword: '"+(t||"required")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+"\" , params: { missingProperty: '"+x+"' } ",e.opts.messages!==!1&&(a+=" , message: '",a+=e.opts._errorDataPathProperty?"is a required property":"should have required property \\'"+x+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } "}}e.errorPath=E}else c&&(a+=" if (true) {");return a}},{}],32:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f="errs__"+s,d=e.util.copy(e),p="";d.level++;var m,v="ifPassed"+e.level;a+="var "+v+";";var y=i;if(y)for(var g,P=-1,E=y.length-1;E>P;){if(g=y[P+=1],P&&!m&&(a+=" if (!"+v+") { ",p+="}"),g["if"]&&e.util.schemaHasRules(g["if"],e.RULES.all)){a+=" var "+f+" = errors;   ";var b=e.compositeRule;if(e.compositeRule=d.compositeRule=!0,d.createErrors=!1,d.schema=g["if"],d.schemaPath=n+"["+P+"].if",d.errSchemaPath=l+"/"+P+"/if",a+=" "+e.validate(d)+" ",d.createErrors=!0,e.compositeRule=d.compositeRule=b,a+=" "+v+" = valid"+d.level+"; if ("+v+") {  ","boolean"==typeof g.then){if(g.then===!1){var w=w||[];w.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"switch")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { caseIndex: '+P+" } ",e.opts.messages!==!1&&(a+=" , message: 'should pass \"switch\" keyword validation' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var j=a;a=w.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+j+"]); ":" validate.errors = ["+j+"]; return false; ":" var err = "+j+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}a+=" var valid"+d.level+" = "+g.then+"; "}else d.schema=g.then,d.schemaPath=n+"["+P+"].then",d.errSchemaPath=l+"/"+P+"/then",a+=" "+e.validate(d)+" ";a+="  } else {  errors = "+f+"; if (vErrors !== null) { if ("+f+") vErrors.length = "+f+"; else vErrors = null; } } "}else if(a+=" "+v+" = true;  ","boolean"==typeof g.then){if(g.then===!1){var w=w||[];w.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"switch")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { caseIndex: '+P+" } ",e.opts.messages!==!1&&(a+=" , message: 'should pass \"switch\" keyword validation' "),e.opts.verbose&&(a+=" , schema: validate.schema"+n+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var j=a;a=w.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+j+"]); ":" validate.errors = ["+j+"]; return false; ":" var err = "+j+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; "}a+=" var valid"+d.level+" = "+g.then+"; "}else d.schema=g.then,d.schemaPath=n+"["+P+"].then",d.errSchemaPath=l+"/"+P+"/then",a+=" "+e.validate(d)+" ";m=g["continue"]}return a+=""+p+"var "+u+" = valid"+d.level+"; ",a=e.util.cleanUpCode(a)}},{}],33:[function(e,r,t){"use strict";r.exports=function(e,r){var t,a=" ",s=e.level,o=e.dataLevel,i=e.schema[r],n=e.schemaPath+"."+r,l=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,h="data"+(o||""),u="valid"+s,f=e.opts.v5&&i.$data,d=f?e.util.getData(i.$data,o,e.dataPathArr):i;if(f&&(a+=" var schema"+s+" = "+d+"; ",d="schema"+s),(i||f)&&e.opts.uniqueItems!==!1){f&&(a+=" var "+u+"; if ("+d+" === false || "+d+" === undefined) "+u+" = true; else if (typeof "+d+" != 'boolean') "+u+" = false; else { "),a+=" var "+u+" = true; if ("+h+".length > 1) { var i = "+h+".length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal("+h+"[i], "+h+"[j])) { "+u+" = false; break outer; } } } } ",f&&(a+="  }  "),a+=" if (!"+u+") {   ";var p=p||[];p.push(a),a="",e.createErrors!==!1?(a+=" { keyword: '"+(t||"uniqueItems")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+l+'" , params: { i: i, j: j } ',e.opts.messages!==!1&&(a+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),e.opts.verbose&&(a+=" , schema:  ",a+=f?"validate.schema"+n:""+i,a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var m=a;a=p.pop(),a+=!e.compositeRule&&c?e.async?" throw new ValidationError(["+m+"]); ":" validate.errors = ["+m+"]; return false; ":" var err = "+m+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",c&&(a+=" else { ")}else c&&(a+=" if (true) { ");return a}},{}],34:[function(e,r,t){"use strict";r.exports=function(e,r){function t(e){for(var r=0;e.rules.length>r;r++)if(a(e.rules[r]))return!0}function a(r){return void 0!==e.schema[r.keyword]||"properties"==r.keyword&&(e.schema.additionalProperties===!1||"object"==typeof e.schema.additionalProperties||e.schema.patternProperties&&Object.keys(e.schema.patternProperties).length||e.opts.v5&&e.schema.patternGroups&&Object.keys(e.schema.patternGroups).length)}var s="",o=e.schema.$async===!0;if(e.isTop){var i=e.isTop,n=e.level=0,l=e.dataLevel=0,c="data";if(e.rootId=e.resolve.fullPath(e.root.schema.id),e.baseId=e.baseId||e.rootId,o){e.async=!0;var h="es7"==e.opts.async;e.yieldAwait=h?"await":"yield"}delete e.isTop,e.dataPathArr=[void 0],s+=" validate = ",o?h?s+=" (async function ":("co*"==e.opts.async&&(s+="co.wrap"),s+="(function* "):s+=" (function ",s+=" (data, dataPath, parentData, parentDataProperty) { 'use strict'; var vErrors = null; ",s+=" var errors = 0;     "}else{var n=e.level,l=e.dataLevel,c="data"+(l||"");if(e.schema.id&&(e.baseId=e.resolve.url(e.baseId,e.schema.id)),o&&!e.async)throw new Error("async schema in sync schema");s+=" var errs_"+n+" = errors;"}var u,f="valid"+n,d=!e.opts.allErrors,p="",m="",v=e.schema.type,y=Array.isArray(v);if(v&&e.opts.coerceTypes){var g=e.util.coerceToTypes(v);if(g){var P=e.schemaPath+".type",E=e.errSchemaPath+"/type",b=y?"checkDataTypes":"checkDataType";s+=" if ("+e.util[b](v,c,!0)+") {  ";var w="dataType"+n,j="coerced"+n;s+=" var "+w+" = typeof "+c+"; var "+j+" = undefined; ";var x="",$=g;if($)for(var S,_=-1,R=$.length-1;R>_;)S=$[_+=1],_&&(s+=" if ("+j+" === undefined) { ",x+="}"),"string"==S?s+=" if ("+w+" == 'number' || "+w+" == 'boolean') "+j+" = '' + "+c+"; else if ("+c+" === null) "+j+" = ''; ":"number"==S||"integer"==S?(s+=" if ("+w+" == 'boolean' || "+c+" === null || ("+w+" == 'string' && "+c+" && "+c+" == +"+c+" ","integer"==S&&(s+=" && !("+c+" % 1)"),s+=")) "+j+" = +"+c+"; "):"boolean"==S?s+=" if ("+c+" === 'false' || "+c+" === 0 || "+c+" === null) "+j+" = false; else if ("+c+" === 'true' || "+c+" === 1) "+j+" = true; ":"null"==S&&(s+=" if ("+c+" === '' || "+c+" === 0 || "+c+" === false) "+j+" = null; ");s+=" "+x+" if ("+j+" === undefined) {   ";var O=O||[];O.push(s),s="",e.createErrors!==!1?(s+=" { keyword: '"+(u||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+E+"\" , params: { type: '",s+=y?""+v.join(","):""+v,s+="' } ",e.opts.messages!==!1&&(s+=" , message: 'should be ",s+=y?""+v.join(","):""+v,s+="' "),e.opts.verbose&&(s+=" , schema: validate.schema"+P+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),s+=" } "):s+=" {} ";var k=s;if(s=O.pop(),s+=!e.compositeRule&&d?e.async?" throw new ValidationError(["+k+"]); ":" validate.errors = ["+k+"]; return false; ":" var err = "+k+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",s+=" } else { ",l){var A="data"+(l-1||""),I=e.dataPathArr[l];s+=" "+c+" = "+A+"["+I+"] = "+j+"; "}else s+=" data = "+j+"; if (parentData !== undefined) parentData[parentDataProperty] = "+j+"; ";s+=" } } "}}var q=e.RULES;if(q)for(var L,C=-1,D=q.length-1;D>C;)if(L=q[C+=1],t(L)){if(L.type&&(s+=" if ("+e.util.checkDataType(L.type,c)+") { "),e.opts.useDefaults&&!e.compositeRule)if("object"==L.type&&e.schema.properties){var V=e.schema.properties,U=Object.keys(V),z=U;if(z)for(var T,M=-1,N=z.length-1;N>M;){T=z[M+=1];var F=V[T];if(void 0!==F["default"]){var Q=c+e.util.getProperty(T);s+="  if ("+Q+" === undefined) "+Q+" = ",s+="clone"==e.opts.useDefaults?" "+JSON.stringify(F["default"])+" ":" "+e.useDefault(F["default"])+" ",s+="; "}}}else if("array"==L.type&&Array.isArray(e.schema.items)){var H=e.schema.items;if(H)for(var F,_=-1,G=H.length-1;G>_;)if(F=H[_+=1],void 0!==F["default"]){var Q=c+"["+_+"]";s+="  if ("+Q+" === undefined) "+Q+" = ",s+="clone"==e.opts.useDefaults?" "+JSON.stringify(F["default"])+" ":" "+e.useDefault(F["default"])+" ",s+="; "}}var J=L.rules;if(J)for(var K,B=-1,Y=J.length-1;Y>B;)if(K=J[B+=1],a(K)){if(K.custom){var V=e.schema[K.keyword],Z=e.useCustomRule(K,V,e.schema,e),W=Z.code+".errors",P=e.schemaPath+"."+K.keyword,E=e.errSchemaPath+"/"+K.keyword,X="errs"+n,_="i"+n,ee="ruleErr"+n,re=K.definition,te=re.async,ae=re.inline,se=re.macro;if(te&&!e.async)throw new Error("async keyword in sync schema");if(ae||se||(s+=""+W+" = null;"),s+="var "+X+" = errors;var valid"+n+";",ae&&re.statements)s+=" "+Z.validate;else if(se){var oe=e.util.copy(e);oe.level++,oe.schema=Z.validate,oe.schemaPath="";var ie=e.compositeRule;e.compositeRule=oe.compositeRule=!0;var ne=e.validate(oe).replace(/validate\.schema/g,Z.code);e.compositeRule=oe.compositeRule=ie,s+=" "+ne}else if(re.compile||re.validate){var O=O||[];O.push(s),s="",s+="  "+Z.code+".call( ",s+=e.opts.passContext?"this":"self";s+=re.compile||re.schema===!1?" , "+c+" ":" , validate.schema"+P+" , "+c+" , validate.schema"+e.schemaPath+" ",s+=" , (dataPath || '')",'""'!=e.errorPath&&(s+=" + "+e.errorPath),s+=l?" , data"+(l-1||"")+" , "+e.dataPathArr[l]+" ":" , parentData , parentDataProperty ",s+=" )  ";var le=s;s=O.pop(),re.errors!==!1&&(te?(W="customErrors"+n,s+=" var "+W+" = null; try { valid"+n+" = "+e.yieldAwait+le+"; } catch (e) { valid"+n+" = false; if (e instanceof ValidationError) "+W+" = e.errors; else throw e; } "):s+=" "+Z.code+".errors = null; ")}s+="if (! ",s+=ae?re.statements?" valid"+n+" ":" ("+Z.validate+") ":se?" valid"+oe.level+" ":te?re.errors===!1?" ("+e.yieldAwait+le+") ":" valid"+n+" ":" "+le+" ",s+=") { ",u=K.keyword;var O=O||[];O.push(s),s="";var O=O||[];O.push(s),s="",e.createErrors!==!1?(s+=" { keyword: '"+(u||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+E+"\" , params: { keyword: '"+K.keyword+"' } ",e.opts.messages!==!1&&(s+=" , message: 'should pass \""+K.keyword+"\" keyword validation' "),e.opts.verbose&&(s+=" , schema: validate.schema"+P+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),s+=" } "):s+=" {} ";var k=s;s=O.pop(),s+=!e.compositeRule&&d?e.async?" throw new ValidationError(["+k+"]); ":" validate.errors = ["+k+"]; return false; ":" var err = "+k+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";var ce=s;s=O.pop(),ae?re.errors?"full"!=re.errors&&(s+="  for (var "+_+"="+X+"; "+_+"<errors; "+_+"++) { var "+ee+" = vErrors["+_+"]; if ("+ee+".dataPath === undefined) { "+ee+".dataPath = (dataPath || '') + "+e.errorPath+"; } if ("+ee+".schemaPath === undefined) { "+ee+'.schemaPath = "'+E+'"; } ',e.opts.verbose&&(s+=" "+ee+".schema = validate.schema"+P+"; "+ee+".data = "+c+"; "),s+=" } "):re.errors===!1?s+=" "+ce+" ":(s+=" if ("+X+" == errors) { "+ce+" } else {  for (var "+_+"="+X+"; "+_+"<errors; "+_+"++) { var "+ee+" = vErrors["+_+"]; if ("+ee+".dataPath === undefined) { "+ee+".dataPath = (dataPath || '') + "+e.errorPath+"; } if ("+ee+".schemaPath === undefined) { "+ee+'.schemaPath = "'+E+'"; } ',e.opts.verbose&&(s+=" "+ee+".schema = validate.schema"+P+"; "+ee+".data = "+c+"; "),s+=" } } "):se?(s+="   var err =   ",e.createErrors!==!1?(s+=" { keyword: '"+(u||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+E+"\" , params: { keyword: '"+K.keyword+"' } ",e.opts.messages!==!1&&(s+=" , message: 'should pass \""+K.keyword+"\" keyword validation' "),e.opts.verbose&&(s+=" , schema: validate.schema"+P+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),s+=" } "):s+=" {} ",s+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&d&&(s+=e.async?" throw new ValidationError(vErrors); ":" validate.errors = vErrors; return false ")):re.errors===!1?s+=" "+ce+" ":(s+=" if (Array.isArray("+W+")) { if (vErrors === null) vErrors = "+W+"; else vErrors.concat("+W+"); errors = vErrors.length;  for (var "+_+"="+X+"; "+_+"<errors; "+_+"++) { var "+ee+" = vErrors["+_+"];  "+ee+".dataPath = (dataPath || '') + "+e.errorPath+";   "+ee+'.schemaPath = "'+E+'";  ',e.opts.verbose&&(s+=" "+ee+".schema = validate.schema"+P+"; "+ee+".data = "+c+"; "),s+=" } } else { "+ce+" } "),u=void 0,s+=" } ",d&&(s+=" else { ")}else s+=" "+K.code(e,K.keyword)+" ";d&&(p+="}")}if(d&&(s+=" "+p+" ",p=""),L.type&&(s+=" } ",v&&v===L.type)){var he=!0;s+=" else { ";var P=e.schemaPath+".type",E=e.errSchemaPath+"/type",O=O||[];O.push(s),s="",e.createErrors!==!1?(s+=" { keyword: '"+(u||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+E+"\" , params: { type: '",s+=y?""+v.join(","):""+v,s+="' } ",e.opts.messages!==!1&&(s+=" , message: 'should be ",s+=y?""+v.join(","):""+v,s+="' "),e.opts.verbose&&(s+=" , schema: validate.schema"+P+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),s+=" } "):s+=" {} ";var k=s;s=O.pop(),s+=!e.compositeRule&&d?e.async?" throw new ValidationError(["+k+"]); ":" validate.errors = ["+k+"]; return false; ":" var err = "+k+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",s+=" } "}d&&(s+=" if (errors === ",s+=i?"0":"errs_"+n,s+=") { ",m+="}")}if(v&&!he&&(!e.opts.coerceTypes||!g)){var P=e.schemaPath+".type",E=e.errSchemaPath+"/type",b=y?"checkDataTypes":"checkDataType";s+=" if ("+e.util[b](v,c,!0)+") {   ";var O=O||[];O.push(s),s="",e.createErrors!==!1?(s+=" { keyword: '"+(u||"type")+"' , dataPath: (dataPath || '') + "+e.errorPath+' , schemaPath: "'+E+"\" , params: { type: '",s+=y?""+v.join(","):""+v,s+="' } ",e.opts.messages!==!1&&(s+=" , message: 'should be ",s+=y?""+v.join(","):""+v,s+="' "),e.opts.verbose&&(s+=" , schema: validate.schema"+P+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),s+=" } "):s+=" {} ";var k=s;s=O.pop(),s+=!e.compositeRule&&d?e.async?" throw new ValidationError(["+k+"]); ":" validate.errors = ["+k+"]; return false; ":" var err = "+k+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",s+=" }"}return d&&(s+=" "+m+" "),i?(o?(s+=" if (errors === 0) return true;           ",s+=" else throw new ValidationError(vErrors); "):(s+=" validate.errors = vErrors; ",s+=" return errors === 0;       "),s+=" });"):s+=" var "+f+" = errors === errs_"+n+";",s=e.util.cleanUpCode(s),i&&d&&(s=e.util.cleanUpVarErrors(s,o)),s}},{}],35:[function(e,r,t){"use strict";var a=/^[a-z_$][a-z0-9_$]*$/i;r.exports=function(e,r){function t(e,r,t){for(var a,s=0;o.RULES.length>s;s++){var i=o.RULES[s];if(i.type==r){a=i;break}}a||(a={type:r,rules:[]},o.RULES.push(a));var n={keyword:e,definition:t,custom:!0};a.rules.push(n)}function s(e){if(!o.RULES.types[e])throw new Error("Unknown type "+e)}var o=this;if(this.RULES.keywords[e])throw new Error("Keyword "+e+" is already defined");if(!a.test(e))throw new Error("Keyword "+e+" is not a valid identifier");if(r){var i=r.type;if(Array.isArray(i)){var n,l=i.length;for(n=0;l>n;n++)s(i[n]);for(n=0;l>n;n++)t(e,i[n],r)}else i&&s(i),t(e,i,r)}this.RULES.keywords[e]=!0,this.RULES.all[e]=!0}},{}],36:[function(e,r,t){r.exports={id:"http://json-schema.org/draft-04/schema#",$schema:"http://json-schema.org/draft-04/schema#",description:"Core schema meta-schema",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},positiveInteger:{type:"integer",minimum:0},positiveIntegerDefault0:{allOf:[{$ref:"#/definitions/positiveInteger"},{"default":0}]},simpleTypes:{"enum":["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},minItems:1,uniqueItems:!0}},type:"object",properties:{id:{type:"string",format:"uri"},$schema:{type:"string",format:"uri"},title:{type:"string"},description:{type:"string"},"default":{},multipleOf:{type:"number",minimum:0,exclusiveMinimum:!0},maximum:{type:"number"},exclusiveMaximum:{type:"boolean","default":!1},minimum:{type:"number"},exclusiveMinimum:{type:"boolean","default":!1},maxLength:{$ref:"#/definitions/positiveInteger"},minLength:{$ref:"#/definitions/positiveIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{anyOf:[{type:"boolean"},{$ref:"#"}],"default":{}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],"default":{}},maxItems:{$ref:"#/definitions/positiveInteger"},minItems:{$ref:"#/definitions/positiveIntegerDefault0"},uniqueItems:{type:"boolean","default":!1},maxProperties:{$ref:"#/definitions/positiveInteger"},minProperties:{$ref:"#/definitions/positiveIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{anyOf:[{type:"boolean"},{$ref:"#"}],"default":{}},definitions:{type:"object",additionalProperties:{$ref:"#"},"default":{}},properties:{type:"object",additionalProperties:{$ref:"#"},"default":{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},"default":{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},"enum":{type:"array",minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},dependencies:{exclusiveMaximum:["maximum"],exclusiveMinimum:["minimum"]},"default":{}}},{}],37:[function(e,r,t){r.exports={id:"https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#",$schema:"http://json-schema.org/draft-04/schema#",description:"Core schema meta-schema (v5 proposals)",definitions:{schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},positiveInteger:{type:"integer",minimum:0},positiveIntegerDefault0:{allOf:[{$ref:"#/definitions/positiveInteger"},{"default":0}]},simpleTypes:{"enum":["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},minItems:1,uniqueItems:!0},$data:{type:"object",required:["$data"],properties:{$data:{type:"string",format:"relative-json-pointer"}},additionalProperties:!1}},type:"object",properties:{id:{type:"string",format:"uri"},$schema:{type:"string",format:"uri"},title:{type:"string"},description:{type:"string"},"default":{},multipleOf:{anyOf:[{type:"number",minimum:0,exclusiveMinimum:!0},{$ref:"#/definitions/$data"}]},maximum:{anyOf:[{type:"number"},{$ref:"#/definitions/$data"}]},exclusiveMaximum:{anyOf:[{type:"boolean","default":!1},{$ref:"#/definitions/$data"}]},minimum:{anyOf:[{type:"number"},{$ref:"#/definitions/$data"}]},exclusiveMinimum:{anyOf:[{type:"boolean","default":!1},{$ref:"#/definitions/$data"}]},maxLength:{anyOf:[{$ref:"#/definitions/positiveInteger"},{$ref:"#/definitions/$data"}]},minLength:{anyOf:[{$ref:"#/definitions/positiveIntegerDefault0"},{$ref:"#/definitions/$data"}]},pattern:{anyOf:[{type:"string",format:"regex"},{$ref:"#/definitions/$data"}]},additionalItems:{anyOf:[{type:"boolean"},{$ref:"#"},{$ref:"#/definitions/$data"}],"default":{}},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],"default":{}},maxItems:{anyOf:[{$ref:"#/definitions/positiveInteger"},{$ref:"#/definitions/$data"}]},minItems:{anyOf:[{$ref:"#/definitions/positiveIntegerDefault0"},{$ref:"#/definitions/$data"}]},uniqueItems:{anyOf:[{type:"boolean","default":!1},{$ref:"#/definitions/$data"}]},maxProperties:{anyOf:[{$ref:"#/definitions/positiveInteger"},{$ref:"#/definitions/$data"}]},minProperties:{anyOf:[{$ref:"#/definitions/positiveIntegerDefault0"},{$ref:"#/definitions/$data"}]},required:{anyOf:[{$ref:"#/definitions/stringArray"},{$ref:"#/definitions/$data"}]},additionalProperties:{anyOf:[{type:"boolean"},{$ref:"#"},{$ref:"#/definitions/$data"}],"default":{}},definitions:{type:"object",additionalProperties:{$ref:"#"},"default":{}},properties:{type:"object",additionalProperties:{$ref:"#"},"default":{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},"default":{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},"enum":{anyOf:[{type:"array",minItems:1,uniqueItems:!0},{$ref:"#/definitions/$data"}]},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"},format:{anyOf:[{type:"string"},{$ref:"#/definitions/$data"}]},formatMaximum:{anyOf:[{type:"string"},{$ref:"#/definitions/$data"}]},formatMinimum:{anyOf:[{type:"string"},{$ref:"#/definitions/$data"}]},exclusiveFormatMaximum:{anyOf:[{type:"boolean","default":!1},{$ref:"#/definitions/$data"}]},exclusiveFormatMinimum:{anyOf:[{type:"boolean","default":!1},{$ref:"#/definitions/$data"}]},constant:{anyOf:[{},{$ref:"#/definitions/$data"}]},contains:{$ref:"#"},patternGroups:{type:"object",additionalProperties:{type:"object",required:["schema"],properties:{maximum:{anyOf:[{$ref:"#/definitions/positiveInteger"},{$ref:"#/definitions/$data"}]},minimum:{anyOf:[{$ref:"#/definitions/positiveIntegerDefault0"},{$ref:"#/definitions/$data"}]},schema:{$ref:"#"}},additionalProperties:!1},"default":{}},"switch":{type:"array",items:{required:["then"],properties:{"if":{$ref:"#"},then:{anyOf:[{type:"boolean"},{$ref:"#"}]},"continue":{type:"boolean"}},additionalProperties:!1,dependencies:{"continue":["if"]}}}},dependencies:{exclusiveMaximum:["maximum"],exclusiveMinimum:["minimum"],formatMaximum:["format"],formatMinimum:["format"],exclusiveFormatMaximum:["formatMaximum"],exclusiveFormatMinimum:["formatMinimum"]},"default":{}}},{}],38:[function(e,r,t){"use strict";function a(r){function t(e,t,s){var o={inline:s||a[e],statements:!0,errors:"full"};t&&(o.type=t),r.addKeyword(e,o)}var a={"switch":e("./dotjs/switch"),constant:e("./dotjs/constant"),_formatLimit:e("./dotjs/_formatLimit"),patternRequired:e("./dotjs/patternRequired")};if(r._opts.meta!==!1){var i=e("./refs/json-schema-v5.json");r.addMetaSchema(i,o)}t("constant"),r.addKeyword("contains",{type:"array",macro:s}),t("formatMaximum","string",a._formatLimit),t("formatMinimum","string",a._formatLimit),r.addKeyword("exclusiveFormatMaximum"),r.addKeyword("exclusiveFormatMinimum"),r.addKeyword("patternGroups"),t("patternRequired","object"),t("switch")}function s(e){return{not:{items:{not:e}}}}var o="https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json";r.exports={enable:a,META_SCHEMA_ID:o}},{"./dotjs/_formatLimit":12,"./dotjs/constant":19,"./dotjs/patternRequired":28,"./dotjs/switch":32,"./refs/json-schema-v5.json":37}],39:[function(e,r,t){(function(e){!function(a){function s(e){throw new RangeError(q[e])}function o(e,r){for(var t=e.length,a=[];t--;)a[t]=r(e[t]);return a}function i(e,r){var t=e.split("@"),a="";t.length>1&&(a=t[0]+"@",e=t[1]),e=e.replace(I,".");var s=e.split("."),i=o(s,r).join(".");return a+i}function n(e){for(var r,t,a=[],s=0,o=e.length;o>s;)r=e.charCodeAt(s++),r>=55296&&56319>=r&&o>s?(t=e.charCodeAt(s++),56320==(64512&t)?a.push(((1023&r)<<10)+(1023&t)+65536):(a.push(r),s--)):a.push(r);return a}function l(e){return o(e,function(e){var r="";return e>65535&&(e-=65536,r+=D(e>>>10&1023|55296),e=56320|1023&e),r+=D(e)}).join("")}function c(e){return 10>e-48?e-22:26>e-65?e-65:26>e-97?e-97:w}function h(e,r){return e+22+75*(26>e)-((0!=r)<<5)}function u(e,r,t){var a=0;for(e=t?C(e/S):e>>1,e+=C(e/r);e>L*x>>1;a+=w)e=C(e/L);return C(a+(L+1)*e/(e+$))}function f(e){var r,t,a,o,i,n,h,f,d,p,m=[],v=e.length,y=0,g=R,P=_;for(t=e.lastIndexOf(O),0>t&&(t=0),a=0;t>a;++a)e.charCodeAt(a)>=128&&s("not-basic"),m.push(e.charCodeAt(a));for(o=t>0?t+1:0;v>o;){for(i=y,n=1,h=w;o>=v&&s("invalid-input"),f=c(e.charCodeAt(o++)),(f>=w||f>C((b-y)/n))&&s("overflow"),y+=f*n,d=P>=h?j:h>=P+x?x:h-P,!(d>f);h+=w)p=w-d,n>C(b/p)&&s("overflow"),n*=p;r=m.length+1,P=u(y-i,r,0==i),C(y/r)>b-g&&s("overflow"),g+=C(y/r),y%=r,m.splice(y++,0,g)}return l(m)}function d(e){var r,t,a,o,i,l,c,f,d,p,m,v,y,g,P,E=[];for(e=n(e),v=e.length,r=R,t=0,i=_,l=0;v>l;++l)m=e[l],128>m&&E.push(D(m));for(a=o=E.length,o&&E.push(O);v>a;){for(c=b,l=0;v>l;++l)m=e[l],m>=r&&c>m&&(c=m);for(y=a+1,c-r>C((b-t)/y)&&s("overflow"),t+=(c-r)*y,r=c,l=0;v>l;++l)if(m=e[l],r>m&&++t>b&&s("overflow"),m==r){for(f=t,d=w;p=i>=d?j:d>=i+x?x:d-i,!(p>f);d+=w)P=f-p,g=w-p,E.push(D(h(p+P%g,0))),f=C(P/g);E.push(D(h(f,0))),i=u(t,y,a==o),t=0,++a}++t,++r}return E.join("")}function p(e){return i(e,function(e){return k.test(e)?f(e.slice(4).toLowerCase()):e})}function m(e){return i(e,function(e){return A.test(e)?"xn--"+d(e):e})}var v="object"==typeof t&&t&&!t.nodeType&&t,y="object"==typeof r&&r&&!r.nodeType&&r,g="object"==typeof e&&e;g.global!==g&&g.window!==g&&g.self!==g||(a=g);var P,E,b=2147483647,w=36,j=1,x=26,$=38,S=700,_=72,R=128,O="-",k=/^xn--/,A=/[^\x20-\x7E]/,I=/[\x2E\u3002\uFF0E\uFF61]/g,q={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},L=w-j,C=Math.floor,D=String.fromCharCode;if(P={version:"1.4.1",ucs2:{decode:n,encode:l},decode:f,encode:d,toASCII:m,toUnicode:p},"function"==typeof define&&"object"==typeof define.amd&&define.amd)define("punycode",function(){return P});else if(v&&y)if(r.exports==v)y.exports=P;else for(E in P)P.hasOwnProperty(E)&&(v[E]=P[E]);else a.punycode=P}(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],40:[function(e,r,t){"use strict";function a(e,r){return Object.prototype.hasOwnProperty.call(e,r)}r.exports=function(e,r,t,o){r=r||"&",t=t||"=";var i={};if("string"!=typeof e||0===e.length)return i;var n=/\+/g;e=e.split(r);var l=1e3;o&&"number"==typeof o.maxKeys&&(l=o.maxKeys);var c=e.length;l>0&&c>l&&(c=l);for(var h=0;c>h;++h){var u,f,d,p,m=e[h].replace(n,"%20"),v=m.indexOf(t);v>=0?(u=m.substr(0,v),f=m.substr(v+1)):(u=m,f=""),d=decodeURIComponent(u),p=decodeURIComponent(f),a(i,d)?s(i[d])?i[d].push(p):i[d]=[i[d],p]:i[d]=p}return i};var s=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)}},{}],41:[function(e,r,t){"use strict";function a(e,r){if(e.map)return e.map(r);for(var t=[],a=0;e.length>a;a++)t.push(r(e[a],a));return t}var s=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}};r.exports=function(e,r,t,n){return r=r||"&",t=t||"=",null===e&&(e=void 0),"object"==typeof e?a(i(e),function(i){var n=encodeURIComponent(s(i))+t;return o(e[i])?a(e[i],function(e){return n+encodeURIComponent(s(e))}).join(r):n+encodeURIComponent(s(e[i]))}).join(r):n?encodeURIComponent(s(n))+t+encodeURIComponent(s(e)):""};var o=Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},i=Object.keys||function(e){var r=[];for(var t in e)Object.prototype.hasOwnProperty.call(e,t)&&r.push(t);return r}},{}],42:[function(e,r,t){"use strict";t.decode=t.parse=e("./decode"),t.encode=t.stringify=e("./encode")},{"./decode":40,"./encode":41}],43:[function(e,r,t){"use strict";function a(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}function s(e,r,t){if(e&&c.isObject(e)&&e instanceof a)return e;var s=new a;return s.parse(e,r,t),s}function o(e){return c.isString(e)&&(e=s(e)),e instanceof a?e.format():a.prototype.format.call(e)}function i(e,r){return s(e,!1,!0).resolve(r)}function n(e,r){return e?s(e,!1,!0).resolveObject(r):r}var l=e("punycode"),c=e("./util");t.parse=s,t.resolve=i,t.resolveObject=n,t.format=o,t.Url=a;var h=/^([a-z0-9.+-]+:)/i,u=/:[0-9]*$/,f=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,d=["<",">",'"',"`"," ","\r","\n","	"],p=["{","}","|","\\","^","`"].concat(d),m=["'"].concat(p),v=["%","/","?",";","#"].concat(m),y=["/","?","#"],g=255,P=/^[+a-z0-9A-Z_-]{0,63}$/,E=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,b={javascript:!0,"javascript:":!0},w={javascript:!0,"javascript:":!0},j={http:!0,https:!0,
        ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0},x=e("querystring");a.prototype.parse=function(e,r,t){if(!c.isString(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var a=e.indexOf("?"),s=-1!==a&&a<e.indexOf("#")?"?":"#",o=e.split(s),i=/\\/g;o[0]=o[0].replace(i,"/"),e=o.join(s);var n=e;if(n=n.trim(),!t&&1===e.split("#").length){var u=f.exec(n);if(u)return this.path=n,this.href=n,this.pathname=u[1],u[2]?(this.search=u[2],this.query=r?x.parse(this.search.substr(1)):this.search.substr(1)):r&&(this.search="",this.query={}),this}var d=h.exec(n);if(d){d=d[0];var p=d.toLowerCase();this.protocol=p,n=n.substr(d.length)}if(t||d||n.match(/^\/\/[^@\/]+@[^@\/]+/)){var $="//"===n.substr(0,2);!$||d&&w[d]||(n=n.substr(2),this.slashes=!0)}if(!w[d]&&($||d&&!j[d])){for(var S=-1,_=0;y.length>_;_++){var R=n.indexOf(y[_]);-1!==R&&(-1===S||S>R)&&(S=R)}var O,k;k=-1===S?n.lastIndexOf("@"):n.lastIndexOf("@",S),-1!==k&&(O=n.slice(0,k),n=n.slice(k+1),this.auth=decodeURIComponent(O)),S=-1;for(var _=0;v.length>_;_++){var R=n.indexOf(v[_]);-1!==R&&(-1===S||S>R)&&(S=R)}-1===S&&(S=n.length),this.host=n.slice(0,S),n=n.slice(S),this.parseHost(),this.hostname=this.hostname||"";var A="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!A)for(var I=this.hostname.split(/\./),_=0,q=I.length;q>_;_++){var L=I[_];if(L&&!L.match(P)){for(var C="",D=0,V=L.length;V>D;D++)C+=L.charCodeAt(D)>127?"x":L[D];if(!C.match(P)){var U=I.slice(0,_),z=I.slice(_+1),T=L.match(E);T&&(U.push(T[1]),z.unshift(T[2])),z.length&&(n="/"+z.join(".")+n),this.hostname=U.join(".");break}}}this.hostname=this.hostname.length>g?"":this.hostname.toLowerCase(),A||(this.hostname=l.toASCII(this.hostname));var M=this.port?":"+this.port:"",N=this.hostname||"";this.host=N+M,this.href+=this.host,A&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==n[0]&&(n="/"+n))}if(!b[p])for(var _=0,q=m.length;q>_;_++){var F=m[_];if(-1!==n.indexOf(F)){var Q=encodeURIComponent(F);Q===F&&(Q=escape(F)),n=n.split(F).join(Q)}}var H=n.indexOf("#");-1!==H&&(this.hash=n.substr(H),n=n.slice(0,H));var G=n.indexOf("?");if(-1!==G?(this.search=n.substr(G),this.query=n.substr(G+1),r&&(this.query=x.parse(this.query)),n=n.slice(0,G)):r&&(this.search="",this.query={}),n&&(this.pathname=n),j[p]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){var M=this.pathname||"",J=this.search||"";this.path=M+J}return this.href=this.format(),this},a.prototype.format=function(){var e=this.auth||"";e&&(e=encodeURIComponent(e),e=e.replace(/%3A/i,":"),e+="@");var r=this.protocol||"",t=this.pathname||"",a=this.hash||"",s=!1,o="";this.host?s=e+this.host:this.hostname&&(s=e+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(s+=":"+this.port)),this.query&&c.isObject(this.query)&&Object.keys(this.query).length&&(o=x.stringify(this.query));var i=this.search||o&&"?"+o||"";return r&&":"!==r.substr(-1)&&(r+=":"),this.slashes||(!r||j[r])&&s!==!1?(s="//"+(s||""),t&&"/"!==t.charAt(0)&&(t="/"+t)):s||(s=""),a&&"#"!==a.charAt(0)&&(a="#"+a),i&&"?"!==i.charAt(0)&&(i="?"+i),t=t.replace(/[?#]/g,function(e){return encodeURIComponent(e)}),i=i.replace("#","%23"),r+s+t+i+a},a.prototype.resolve=function(e){return this.resolveObject(s(e,!1,!0)).format()},a.prototype.resolveObject=function(e){if(c.isString(e)){var r=new a;r.parse(e,!1,!0),e=r}for(var t=new a,s=Object.keys(this),o=0;s.length>o;o++){var i=s[o];t[i]=this[i]}if(t.hash=e.hash,""===e.href)return t.href=t.format(),t;if(e.slashes&&!e.protocol){for(var n=Object.keys(e),l=0;n.length>l;l++){var h=n[l];"protocol"!==h&&(t[h]=e[h])}return j[t.protocol]&&t.hostname&&!t.pathname&&(t.path=t.pathname="/"),t.href=t.format(),t}if(e.protocol&&e.protocol!==t.protocol){if(!j[e.protocol]){for(var u=Object.keys(e),f=0;u.length>f;f++){var d=u[f];t[d]=e[d]}return t.href=t.format(),t}if(t.protocol=e.protocol,e.host||w[e.protocol])t.pathname=e.pathname;else{for(var p=(e.pathname||"").split("/");p.length&&!(e.host=p.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==p[0]&&p.unshift(""),2>p.length&&p.unshift(""),t.pathname=p.join("/")}if(t.search=e.search,t.query=e.query,t.host=e.host||"",t.auth=e.auth,t.hostname=e.hostname||e.host,t.port=e.port,t.pathname||t.search){var m=t.pathname||"",v=t.search||"";t.path=m+v}return t.slashes=t.slashes||e.slashes,t.href=t.format(),t}var y=t.pathname&&"/"===t.pathname.charAt(0),g=e.host||e.pathname&&"/"===e.pathname.charAt(0),P=g||y||t.host&&e.pathname,E=P,b=t.pathname&&t.pathname.split("/")||[],p=e.pathname&&e.pathname.split("/")||[],x=t.protocol&&!j[t.protocol];if(x&&(t.hostname="",t.port=null,t.host&&(""===b[0]?b[0]=t.host:b.unshift(t.host)),t.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===p[0]?p[0]=e.host:p.unshift(e.host)),e.host=null),P=P&&(""===p[0]||""===b[0])),g)t.host=e.host||""===e.host?e.host:t.host,t.hostname=e.hostname||""===e.hostname?e.hostname:t.hostname,t.search=e.search,t.query=e.query,b=p;else if(p.length)b||(b=[]),b.pop(),b=b.concat(p),t.search=e.search,t.query=e.query;else if(!c.isNullOrUndefined(e.search)){if(x){t.hostname=t.host=b.shift();var $=t.host&&t.host.indexOf("@")>0?t.host.split("@"):!1;$&&(t.auth=$.shift(),t.host=t.hostname=$.shift())}return t.search=e.search,t.query=e.query,c.isNull(t.pathname)&&c.isNull(t.search)||(t.path=(t.pathname?t.pathname:"")+(t.search?t.search:"")),t.href=t.format(),t}if(!b.length)return t.pathname=null,t.path=t.search?"/"+t.search:null,t.href=t.format(),t;for(var S=b.slice(-1)[0],_=(t.host||e.host||b.length>1)&&("."===S||".."===S)||""===S,R=0,O=b.length;O>=0;O--)S=b[O],"."===S?b.splice(O,1):".."===S?(b.splice(O,1),R++):R&&(b.splice(O,1),R--);if(!P&&!E)for(;R--;R)b.unshift("..");!P||""===b[0]||b[0]&&"/"===b[0].charAt(0)||b.unshift(""),_&&"/"!==b.join("/").substr(-1)&&b.push("");var k=""===b[0]||b[0]&&"/"===b[0].charAt(0);if(x){t.hostname=t.host=k?"":b.length?b.shift():"";var $=t.host&&t.host.indexOf("@")>0?t.host.split("@"):!1;$&&(t.auth=$.shift(),t.host=t.hostname=$.shift())}return P=P||t.host&&b.length,P&&!k&&b.unshift(""),b.length?t.pathname=b.join("/"):(t.pathname=null,t.path=null),c.isNull(t.pathname)&&c.isNull(t.search)||(t.path=(t.pathname?t.pathname:"")+(t.search?t.search:"")),t.auth=e.auth||t.auth,t.slashes=t.slashes||e.slashes,t.href=t.format(),t},a.prototype.parseHost=function(){var e=this.host,r=u.exec(e);r&&(r=r[0],":"!==r&&(this.port=r.substr(1)),e=e.substr(0,e.length-r.length)),e&&(this.hostname=e)}},{"./util":44,punycode:39,querystring:42}],44:[function(e,r,t){"use strict";r.exports={isString:function(e){return"string"==typeof e},isObject:function(e){return"object"==typeof e&&null!==e},isNull:function(e){return null===e},isNullOrUndefined:function(e){return null==e}}},{}],45:[function(e,r,t){function a(e){var r=this,t=f.call(arguments,1);return new Promise(function(a,o){function i(r){var t;try{t=e.next(r)}catch(a){return o(a)}c(t)}function n(r){var t;try{t=e["throw"](r)}catch(a){return o(a)}c(t)}function c(e){if(e.done)return a(e.value);var t=s.call(r,e.value);return t&&l(t)?t.then(i,n):n(new TypeError('You may only yield a function, promise, generator, array, or object, but the following object was passed: "'+String(e.value)+'"'))}return"function"==typeof e&&(e=e.apply(r,t)),e&&"function"==typeof e.next?void i():a(e)})}function s(e){return e?l(e)?e:h(e)||c(e)?a.call(this,e):"function"==typeof e?o.call(this,e):Array.isArray(e)?i.call(this,e):u(e)?n.call(this,e):e:e}function o(e){var r=this;return new Promise(function(t,a){e.call(r,function(e,r){return e?a(e):(arguments.length>2&&(r=f.call(arguments,1)),void t(r))})})}function i(e){return Promise.all(e.map(s,this))}function n(e){function r(e,r){t[r]=void 0,o.push(e.then(function(e){t[r]=e}))}for(var t=new e.constructor,a=Object.keys(e),o=[],i=0;a.length>i;i++){var n=a[i],c=s.call(this,e[n]);c&&l(c)?r(c,n):t[n]=e[n]}return Promise.all(o).then(function(){return t})}function l(e){return"function"==typeof e.then}function c(e){return"function"==typeof e.next&&"function"==typeof e["throw"]}function h(e){var r=e.constructor;return r?"GeneratorFunction"===r.name||"GeneratorFunction"===r.displayName?!0:c(r.prototype):!1}function u(e){return Object==e.constructor}var f=Array.prototype.slice;r.exports=a["default"]=a.co=a,a.wrap=function(e){function r(){return a.call(this,e.apply(this,arguments))}return r.__generatorFunction__=e,r}},{}],46:[function(e,r,t){var a="undefined"!=typeof JSON?JSON:e("jsonify");r.exports=function(e,r){r||(r={}),"function"==typeof r&&(r={cmp:r});var t=r.space||"";"number"==typeof t&&(t=Array(t+1).join(" "));var i="boolean"==typeof r.cycles?r.cycles:!1,n=r.replacer||function(e,r){return r},l=r.cmp&&function(e){return function(r){return function(t,a){var s={key:t,value:r[t]},o={key:a,value:r[a]};return e(s,o)}}}(r.cmp),c=[];return function h(e,r,u,f){var d=t?"\n"+new Array(f+1).join(t):"",p=t?": ":":";if(u&&u.toJSON&&"function"==typeof u.toJSON&&(u=u.toJSON()),u=n.call(e,r,u),void 0!==u){if("object"!=typeof u||null===u)return a.stringify(u);if(s(u)){for(var m=[],v=0;u.length>v;v++){var y=h(u,v,u[v],f+1)||a.stringify(null);m.push(d+t+y)}return"["+m.join(",")+d+"]"}if(-1!==c.indexOf(u)){if(i)return a.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}c.push(u);for(var g=o(u).sort(l&&l(u)),m=[],v=0;g.length>v;v++){var r=g[v],P=h(u,r,u[r],f+1);if(P){var E=a.stringify(r)+p+P;m.push(d+t+E)}}return c.splice(c.indexOf(u),1),"{"+m.join(",")+d+"}"}}({"":e},"",e,0)};var s=Array.isArray||function(e){return"[object Array]"==={}.toString.call(e)},o=Object.keys||function(e){var r=Object.prototype.hasOwnProperty||function(){return!0},t=[];for(var a in e)r.call(e,a)&&t.push(a);return t}},{jsonify:47}],47:[function(e,r,t){t.parse=e("./lib/parse"),t.stringify=e("./lib/stringify")},{"./lib/parse":48,"./lib/stringify":49}],48:[function(e,r,t){var a,s,o,i,n={'"':'"',"\\":"\\","/":"/",b:"\b",f:"\f",n:"\n",r:"\r",t:"	"},l=function(e){throw{name:"SyntaxError",message:e,at:a,text:o}},c=function(e){return e&&e!==s&&l("Expected '"+e+"' instead of '"+s+"'"),s=o.charAt(a),a+=1,s},h=function(){var e,r="";for("-"===s&&(r="-",c("-"));s>="0"&&"9">=s;)r+=s,c();if("."===s)for(r+=".";c()&&s>="0"&&"9">=s;)r+=s;if("e"===s||"E"===s)for(r+=s,c(),"-"!==s&&"+"!==s||(r+=s,c());s>="0"&&"9">=s;)r+=s,c();return e=+r,isFinite(e)?e:void l("Bad number")},u=function(){var e,r,t,a="";if('"'===s)for(;c();){if('"'===s)return c(),a;if("\\"===s)if(c(),"u"===s){for(t=0,r=0;4>r&&(e=parseInt(c(),16),isFinite(e));r+=1)t=16*t+e;a+=String.fromCharCode(t)}else{if("string"!=typeof n[s])break;a+=n[s]}else a+=s}l("Bad string")},f=function(){for(;s&&" ">=s;)c()},d=function(){switch(s){case"t":return c("t"),c("r"),c("u"),c("e"),!0;case"f":return c("f"),c("a"),c("l"),c("s"),c("e"),!1;case"n":return c("n"),c("u"),c("l"),c("l"),null}l("Unexpected '"+s+"'")},p=function(){var e=[];if("["===s){if(c("["),f(),"]"===s)return c("]"),e;for(;s;){if(e.push(i()),f(),"]"===s)return c("]"),e;c(","),f()}}l("Bad array")},m=function(){var e,r={};if("{"===s){if(c("{"),f(),"}"===s)return c("}"),r;for(;s;){if(e=u(),f(),c(":"),Object.hasOwnProperty.call(r,e)&&l('Duplicate key "'+e+'"'),r[e]=i(),f(),"}"===s)return c("}"),r;c(","),f()}}l("Bad object")};i=function(){switch(f(),s){case"{":return m();case"[":return p();case'"':return u();case"-":return h();default:return s>="0"&&"9">=s?h():d()}},r.exports=function(e,r){var t;return o=e,a=0,s=" ",t=i(),f(),s&&l("Syntax error"),"function"==typeof r?function n(e,t){var a,s,o=e[t];if(o&&"object"==typeof o)for(a in o)Object.prototype.hasOwnProperty.call(o,a)&&(s=n(o,a),void 0!==s?o[a]=s:delete o[a]);return r.call(e,t,o)}({"":t},""):t}},{}],49:[function(e,r,t){function a(e){return l.lastIndex=0,l.test(e)?'"'+e.replace(l,function(e){var r=c[e];return"string"==typeof r?r:"\\u"+("0000"+e.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+e+'"'}function s(e,r){var t,l,c,h,u,f=o,d=r[e];switch(d&&"object"==typeof d&&"function"==typeof d.toJSON&&(d=d.toJSON(e)),"function"==typeof n&&(d=n.call(r,e,d)),typeof d){case"string":return a(d);case"number":return isFinite(d)?String(d):"null";case"boolean":case"null":return String(d);case"object":if(!d)return"null";if(o+=i,u=[],"[object Array]"===Object.prototype.toString.apply(d)){for(h=d.length,t=0;h>t;t+=1)u[t]=s(t,d)||"null";return c=0===u.length?"[]":o?"[\n"+o+u.join(",\n"+o)+"\n"+f+"]":"["+u.join(",")+"]",o=f,c}if(n&&"object"==typeof n)for(h=n.length,t=0;h>t;t+=1)l=n[t],"string"==typeof l&&(c=s(l,d),c&&u.push(a(l)+(o?": ":":")+c));else for(l in d)Object.prototype.hasOwnProperty.call(d,l)&&(c=s(l,d),c&&u.push(a(l)+(o?": ":":")+c));return c=0===u.length?"{}":o?"{\n"+o+u.join(",\n"+o)+"\n"+f+"}":"{"+u.join(",")+"}",o=f,c}}var o,i,n,l=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,c={"\b":"\\b","	":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};r.exports=function(e,r,t){var a;if(o="",i="","number"==typeof t)for(a=0;t>a;a+=1)i+=" ";else"string"==typeof t&&(i=t);if(n=r,r&&"function"!=typeof r&&("object"!=typeof r||"number"!=typeof r.length))throw new Error("JSON.stringify");return s("",{"":e})}},{}],ajv:[function(e,r,t){"use strict";function a(e){return v.test(e)}function Ajv(r){function t(e,r){var t;if("string"==typeof e){if(t=j(e),!t)throw new Error('no schema with key or ref "'+e+'"')}else{var a=_(e);t=a.validate||R(a)}var s=t(r);return t.async===!0?"*"==C._opts.async?p(s):s:(C.errors=t.errors,s)}function g(e){var r=_(e);return r.validate||R(r)}function P(e,r,t,a){if(Array.isArray(e))for(var s=0;e.length>s;s++)P(e[s],void 0,t,a);else{r=o.normalizeId(r||e.id),q(r);var i=C._schemas[r]=_(e,t,!0);i.meta=a}}function E(e,r,t){P(e,r,t,!0)}function b(e,r){var s=e.$schema||C._opts.defaultMeta||w(),o=C._formats.uri;C._formats.uri="function"==typeof o?a:v;var i=t(s,e);if(C._formats.uri=o,!i&&r){var n="schema is invalid:"+O();if("log"!=C._opts.validateSchema)throw new Error(n);console.error(n)}return i}function w(){var e=C._opts.meta;return C._opts.defaultMeta="object"==typeof e?e.id||e:C._opts.v5?u.META_SCHEMA_ID:m}function j(e){var r=x(e);switch(typeof r){case"object":return r.validate||R(r);case"string":return j(r)}}function x(e){return e=o.normalizeId(e),C._schemas[e]||C._refs[e]}function $(e){switch(typeof e){case"undefined":return S(C._schemas),S(C._refs),void C._cache.clear();case"string":var r=x(e);return r&&C._cache.del(r.jsonStr),delete C._schemas[e],void delete C._refs[e];case"object":if(e instanceof RegExp)return S(C._schemas,e),void S(C._refs,e);var t=l(e);C._cache.del(t);var a=e.id;a&&(a=o.normalizeId(a),delete C._schemas[a],delete C._refs[a])}}function S(e,r){for(var t in e){var a=e[t];a.meta||r&&!r.test(t)||(C._cache.del(a.jsonStr),delete e[t])}}function _(e,r,t){if("object"!=typeof e)throw new Error("schema should be object");var a=l(e),s=C._cache.get(a);if(s)return s;t=t||C._opts.addUsedSchema!==!1;var i=o.normalizeId(e.id);i&&t&&q(i),C._opts.validateSchema===!1||r||b(e,!0);var c=o.ids.call(C,e),h=new n({id:i,schema:e,localRefs:c,jsonStr:a});return"#"!=i[0]&&t&&(C._refs[i]=h),C._cache.put(a,h),h}function R(e,r){function t(){var r=e.validate,a=r.apply(null,arguments);return t.errors=r.errors,a}if(e.compiling)return e.validate=t,t.schema=e.schema,t.errors=null,t.root=r?r:t,e.schema.$async===!0&&(t.async=!0),t;e.compiling=!0;var a;e.meta&&(a=C._opts,C._opts=C._metaOpts);var o;try{o=s.call(C,e.schema,r,e.localRefs)}finally{e.compiling=!1,e.meta&&(C._opts=a)}return e.validate=o,e.refs=o.refs,e.refVal=o.refVal,e.root=o.root,o}function O(e,r){if(e=e||C.errors,!e)return"No errors";r=r||{};for(var t=void 0===r.separator?", ":r.separator,a=void 0===r.dataVar?"data":r.dataVar,s="",o=0;e.length>o;o++){var i=e[o];i&&(s+=a+i.dataPath+" "+i.message+t)}return s.slice(0,-t.length)}function k(e,r){"string"==typeof r&&(r=new RegExp(r)),C._formats[e]=r}function A(){if(C._opts.meta!==!1){var r=e("./refs/json-schema-draft-04.json");E(r,m,!0),C._refs["http://json-schema.org/schema"]=m}var t=C._opts.schemas;if(t)if(Array.isArray(t))P(t);else for(var a in t)P(t[a],a)}function I(){for(var e in C._opts.formats){var r=C._opts.formats[e];k(e,r)}}function q(e){if(C._schemas[e]||C._refs[e])throw new Error('schema with key or id "'+e+'" already exists')}function L(){for(var e=f.copy(C._opts),r=0;y.length>r;r++)delete e[y[r]];return e}if(!(this instanceof Ajv))return new Ajv(r);var C=this;r=this._opts=f.copy(r)||{},this._schemas={},this._refs={},this._formats=c(r.format),this._cache=r.cache||new i,this._loadingSchemas={},this.RULES=h(),this.validate=t,this.compile=g,this.addSchema=P,this.addMetaSchema=E,this.validateSchema=b,this.getSchema=j,this.removeSchema=$,this.addFormat=k,this.errorsText=O,this._addSchema=_,this._compile=R,r.loopRequired=r.loopRequired||1/0,(r.async||r.transpile)&&d.setup(r),r.beautify===!0&&(r.beautify={indent_size:2}),"property"==r.errorDataPath&&(r._errorDataPathProperty=!0),this._metaOpts=L(),A(),r.formats&&I(),r.v5&&u.enable(this),"object"==typeof r.meta&&E(r.meta)}var s=e("./compile"),o=e("./compile/resolve"),i=e("./cache"),n=e("./compile/schema_obj"),l=e("json-stable-stringify"),c=e("./compile/formats"),h=e("./compile/rules"),u=e("./v5"),f=e("./compile/util"),d=e("./async"),p=e("co");r.exports=Ajv,Ajv.prototype.compileAsync=d.compile,Ajv.prototype.addKeyword=e("./keyword"),Ajv.ValidationError=e("./compile/validation_error");var m="http://json-schema.org/draft-04/schema",v=/^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,y=["removeAdditional","useDefaults","coerceTypes"]},{"./async":1,"./cache":2,"./compile":6,"./compile/formats":5,"./compile/resolve":7,"./compile/rules":8,"./compile/schema_obj":9,"./compile/util":10,"./compile/validation_error":11,"./keyword":35,"./refs/json-schema-draft-04.json":36,"./v5":38,co:45,"json-stable-stringify":46}]},{},[])("ajv")});
        });

        var Ajv = (ajv_min && typeof ajv_min === 'object' && 'default' in ajv_min ? ajv_min['default'] : ajv_min);

        var $schema = "http://json-schema.org/draft-04/schema#";
        var scene = {"type":"object","properties":{"primitive":{"enum":["scene"]},"version":{"type":"string"},"elements":{"$ref":"#/scene/elements"}},"required":["elements","version","primitive"],"additionalProperties":false,"elements":{"type":"array","items":{"$ref":"#/scene/element"},"additionalItems":false},"entity":{"anyOf":[{"$ref":"#/entities/empty"},{"$ref":"#/entities/number"},{"$ref":"#/entities/brep"},{"$ref":"#/entities/vector"},{"$ref":"#/entities/point"},{"$ref":"#/entities/plane"},{"$ref":"#/entities/affineTransform"},{"$ref":"#/entities/massProps"},{"$ref":"#/entities/line"},{"$ref":"#/entities/polyline"},{"$ref":"#/entities/circle"},{"$ref":"#/entities/ellipse"},{"$ref":"#/entities/curve"},{"$ref":"#/entities/arc"},{"$ref":"#/entities/rectangle"},{"$ref":"#/entities/polycurve"},{"$ref":"#/entities/polygonSet"},{"$ref":"#/entities/surface"},{"$ref":"#/entities/polysurface"},{"$ref":"#/entities/block"},{"$ref":"#/entities/torus"},{"$ref":"#/entities/sphere"},{"$ref":"#/entities/cylinder"},{"$ref":"#/entities/cone"},{"$ref":"#/entities/mesh"}]},"element":{"anyOf":[{"$ref":"#/scene/entity"},{"$ref":"#/assembly"},{"$ref":"#/instance"},{"$ref":"#/alphaGeometryContainer"},{"$ref":"#/layer"}]}};
        var types = {"brep_format":{"enum":["x_b","x_t","iges","step","sat","sab","stl"]},"index":{"type":"integer","minimum":0},"indexNonzero":{"type":"integer","minimum":0,"exclusiveMinimum":true},"direction":{"type":"array","items":{"type":"number"},"minItems":3,"maxItems":3},"fluxid":{"type":"string"},"angle":{"type":"number","fluxDimension":"angle"},"coordinate":{"type":"number","fluxDimension":"length"},"distance":{"type":"number","minimum":0,"fluxDimension":"length"},"area":{"type":"number","minimum":0,"fluxDimension":"area"},"volume":{"type":"number","minimum":0,"fluxDimension":"volume"},"distanceNonzero":{"type":"number","minimum":0,"exclusiveMinimum":true,"fluxDimension":"length"},"position":{"type":"array","items":{"$ref":"#/types/coordinate"},"minItems":3,"maxItems":3},"dimensions":{"type":"array","items":{"$ref":"#/types/distanceNonzero"},"minItems":3,"maxItems":3},"units":{"type":"object","additionalProperties":false,"patternProperties":{".*":{"type":"string"}}},"boundingBox":{"type":"array","items":{"$ref":"#/types/position"},"minItems":2,"maxItems":2},"matrix":{"type":"array","items":{"type":"number"},"minItems":16,"maxItems":16},"color":{"anyOf":[{"type":"array","items":{"$ref":"#/types/indexNonzero"},"minItems":3,"maxItems":3},{"type":"string"}]}};
        var entities = {"empty":{"type":"object","additionalProperties":false},"number":{"type":"number"},"brep":{"type":"object","properties":{"primitive":{"enum":["brep"]},"content":{"type":"string"},"format":{"$ref":"#/types/brep_format"},"isCompressed":{"type":"boolean"},"isBase64":{"type":"boolean"},"vertices":{"type":"array","items":{"$ref":"#/types/position"}},"faces":{"type":"array","items":{"type":"array","items":{"$ref":"#/types/index"},"minItems":3}},"attributes":{}},"required":["primitive","content","format"]},"vector":{"type":"object","properties":{"primitive":{"enum":["vector"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"coords":{"$ref":"#/types/position"}},"required":["primitive","coords"]},"point":{"type":"object","properties":{"primitive":{"enum":["point"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"point":{"$ref":"#/types/position"}},"required":["primitive","point"]},"plane":{"type":"object","properties":{"primitive":{"enum":["plane"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"normal":{"$ref":"#/types/direction"}},"required":["primitive","origin","normal"]},"affineTransform":{"type":"object","properties":{"primitive":{"enum":["affineTransform"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"mat":{"type":"array","items":{"type":"number"},"minItems":16,"maxItems":16,"fluxDimension":"affineMatrix"}},"required":["primitive","mat"],"additionalProperties":false},"massProps":{"type":"object","properties":{"primitive":{"enum":["massProps"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"mass":{"$ref":"#/types/distance"},"centerOfMass":{"$ref":"#/types/position"},"inertiaTensor":{"type":"array","items":{"$ref":"#/types/direction"},"minItems":3,"maxItems":3},"volume":{"$ref":"#/types/volume"},"surfaceArea":{"$ref":"#/types/area"},"length":{"$ref":"#/types/distance"},"circumference":{"$ref":"#/types/distance"}},"required":["primitive","mass","centerOfMass","inertiaTensor"],"additionalProperties":false},"line":{"type":"object","properties":{"primitive":{"enum":["line"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"start":{"$ref":"#/types/position"},"end":{"$ref":"#/types/position"}},"required":["primitive","start","end"]},"polyline":{"type":"object","properties":{"primitive":{"enum":["polyline"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"points":{"type":"array","items":{"$ref":"#/types/position"},"minItems":2}},"required":["primitive","points"]},"circle":{"type":"object","properties":{"primitive":{"enum":["circle"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"radius":{"$ref":"#/types/distanceNonzero"},"axis":{"$ref":"#/types/direction"}},"required":["primitive","origin","radius"]},"ellipse":{"type":"object","properties":{"primitive":{"enum":["ellipse"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"majorRadius":{"$ref":"#/types/distanceNonzero"},"minorRadius":{"$ref":"#/types/distanceNonzero"},"axis":{"$ref":"#/types/direction"},"reference":{"$ref":"#/types/direction"}},"required":["primitive","origin","majorRadius","minorRadius"]},"curve":{"type":"object","properties":{"primitive":{"enum":["curve"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"degree":{"$ref":"#/types/indexNonzero"},"controlPoints":{"type":"array","items":{"$ref":"#/types/position"}},"knots":{"type":"array","items":{"type":"number"}},"weights":{"type":"array","items":{"type":"number"}}},"required":["primitive","degree","controlPoints","knots"]},"arc":{"type":"object","properties":{"primitive":{"enum":["arc"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"start":{"$ref":"#/types/position"},"middle":{"$ref":"#/types/position"},"end":{"$ref":"#/types/position"}},"required":["primitive","start","middle","end"]},"rectangle":{"type":"object","properties":{"primitive":{"enum":["rectangle"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"dimensions":{"type":"array","items":{"$ref":"#/types/distanceNonzero"},"minItems":2,"maxItems":2,"additionalItems":false},"axis":{"$ref":"#/types/direction"},"reference":{"$ref":"#/types/direction"}},"required":["primitive","origin","dimensions"]},"polycurve":{"type":"object","properties":{"primitive":{"enum":["polycurve"]},"__repr__":{"type":"string"},"attributes":{},"curves":{"type":"array","minItems":1,"items":{"oneOf":[{"$ref":"#/entities/line"},{"$ref":"#/entities/polyline"},{"$ref":"#/entities/curve"},{"$ref":"#/entities/arc"}]}}},"required":["primitive","curves"]},"polygonSet":{"type":"object","properties":{"primitive":{"enum":["polygonSet"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"polygons":{"type":"array","items":{"type":"object","properties":{"boundary":{"$ref":"#/entities/polygonSet/polygon"},"holes":{"type":"array","items":{"$ref":"#/entities/polygonSet/polygon"}}},"required":["boundary","holes"],"additionalProperties":false},"minItems":1}},"required":["primitive","polygons"],"polygon":{"type":"array","items":{"$ref":"#/types/position"},"minItems":3}},"surface":{"type":"object","properties":{"primitive":{"enum":["surface"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"uDegree":{"$ref":"#/types/indexNonzero"},"vDegree":{"$ref":"#/types/indexNonzero"},"uKnots":{"type":"array","items":{"type":"number"}},"vKnots":{"type":"array","items":{"type":"number"}},"controlPoints":{"type":"array","items":{"type":"array","items":{"$ref":"#/types/position"}}},"weights":{"type":"array","items":{"type":"number"}}},"required":["primitive","uDegree","vDegree","uKnots","vKnots","controlPoints"]},"polysurface":{"type":"object","properties":{"primitive":{"enum":["polysurface"]},"__repr__":{"type":"string"},"attributes":{},"surfaces":{"type":"array","items":{"oneOf":[{"$ref":"#/entities/polygonSet"},{"$ref":"#/entities/surface"}]},"minItems":1}},"required":["primitive","surfaces"]},"block":{"type":"object","properties":{"primitive":{"enum":["block"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"dimensions":{"$ref":"#/types/dimensions"},"axis":{"$ref":"#/types/direction"},"reference":{"$ref":"#/types/direction"}},"required":["primitive","origin","dimensions"]},"torus":{"type":"object","properties":{"primitive":{"enum":["torus"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"majorRadius":{"$ref":"#/types/coordinate"},"minorRadius":{"$ref":"#/types/distanceNonzero"},"axis":{"$ref":"#/types/direction"}},"required":["primitive","origin","majorRadius","minorRadius"]},"sphere":{"type":"object","properties":{"primitive":{"enum":["sphere"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"radius":{"$ref":"#/types/distanceNonzero"}},"required":["primitive","origin","radius"]},"cylinder":{"type":"object","properties":{"primitive":{"enum":["cylinder"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"radius":{"$ref":"#/types/distanceNonzero"},"height":{"$ref":"#/types/distanceNonzero"},"axis":{"$ref":"#/types/direction"}},"required":["primitive","origin","radius","height"]},"cone":{"type":"object","properties":{"primitive":{"enum":["cone"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"origin":{"$ref":"#/types/position"},"radius":{"$ref":"#/types/distanceNonzero"},"height":{"$ref":"#/types/distanceNonzero"},"semiAngle":{"$ref":"#/types/angle"},"axis":{"$ref":"#/types/direction"}},"required":["primitive","origin","radius","height","semiAngle"]},"mesh":{"type":"object","properties":{"primitive":{"enum":["mesh"]},"__repr__":{"type":"string"},"attributes":{},"units":{"$ref":"#/types/units"},"vertices":{"type":"array","items":{"$ref":"#/types/position"}},"faces":{"type":"array","items":{"type":"array","items":{"$ref":"#/types/index"},"minItems":3}}},"required":["primitive","vertices","faces"]}};
        var instance = {"type":"object","properties":{"attributes":{},"primitive":{"enum":["instance"]},"id":{"$ref":"#/types/fluxid"},"matrix":{"$ref":"#/types/matrix"},"bbox":{"$ref":"#/types/boundingBox"},"label":{"type":"string"},"entity":{"$ref":"#/types/fluxid"}},"required":["primitive","id","entity"],"additionalProperties":false};
        var alphaGeometryContainer = {"type":"object","properties":{"attributes":{},"primitive":{"enum":["alphaGeometryContainer"]},"id":{"$ref":"#/types/fluxid"},"entity":{"anyOf":[{"type":"array"},{"type":"object"}]},"required":["primitive","id","entity"],"additionalProperties":false}};
        var assembly = {"type":"object","properties":{"attributes":{},"primitive":{"enum":["assembly"]},"id":{"$ref":"#/types/fluxid"},"matrix":{"$ref":"#/types/matrix"},"bbox":{"$ref":"#/types/boundingBox"},"label":{"type":"string"},"children":{"type":"array","items":{"$ref":"#/types/fluxid"}}},"required":["primitive","id","children"],"additionalProperties":true};
        var layer = {"type":"object","properties":{"attributes":{},"primitive":{"enum":["layer"]},"id":{"$ref":"#/types/fluxid"},"label":{"type":"string"},"color":{"$ref":"#/types/color"},"visible":{"type":"boolean"},"elements":{"type":"array","items":{"$ref":"#/types/fluxid"}}},"required":["primitive","id","elements"],"additionalProperties":false};
        var require$$1 = {
        	$schema: $schema,
        	scene: scene,
        	types: types,
        	entities: entities,
        	instance: instance,
        	alphaGeometryContainer: alphaGeometryContainer,
        	assembly: assembly,
        	layer: layer
        };

var schemaJson = Object.freeze({
        	$schema: $schema,
        	scene: scene,
        	types: types,
        	entities: entities,
        	instance: instance,
        	alphaGeometryContainer: alphaGeometryContainer,
        	assembly: assembly,
        	layer: layer,
        	default: require$$1
        });

        // Mapping from primitive names to schema validator functions
        var ajvValidators = null;

        // Cache schema compiler object
        var ajvSchema = null;


        /**
         * Check if the entities match the parasolid entity schema
         * @param {Array} entity Array of arrays or entities
         * @param {StatusMap} statusMap Container for errors
         * @returns {boolean} True if the schema checked out
         * @private
         */
        function checkSchema (entity, statusMap) {
            if (entity.primitive) {
                if (NON_STANDARD_ENTITIES.indexOf(entity.primitive) !== -1) {
                    return true;
                }
                var validate = _findValidator(entity.primitive);
                // Warning this assumes validate is synchronous so that we can
                // call validate on a singleton, and read the results safely from it's properties
                if (!validate) {
                    statusMap.appendError(_getDescriptor(entity),"Unknown primitive type.");
                    return false;
                }
                if (!validate(entity)) {
                    statusMap.appendError(_getDescriptor(entity), _serializeErrors(validate.errors));
                    return false;
                }
                return true;
            } else {
                return false;
            }
        }

        function _getDescriptor(entity) {
            var descriptor = entity.primitive;
            if (entity.id) {
                descriptor += ':'+entity.id;
            }
            return descriptor;
        }

        /**
         * Create schema compiler object
         * @private
         */
        function _initSchema() {
            if (!ajvSchema) {
                ajvSchema = Ajv({ allErrors: true });
                ajvSchema.addSchema(schemaJson, "_");
                ajvValidators = {};
            }
        }

        /**
         * Compile the schema for the given primitive
         * @param {String} primitive The name of the primitive
         * @returns {Function} Ajv validator function
         * @private
         */
        function _findValidator(primitive) {
            _initSchema();
            // Compile the schema for this primitive if needed
            if (!ajvValidators[primitive]) {
                var schemaPrim = entities[primitive];
                var schemaId = "#/entities/"+primitive;
                if (!schemaPrim) {
                    schemaPrim = schemaJson[primitive];
                    schemaId = "#/"+primitive;//scene, instance ...
                }
                if (!schemaPrim) {
                    return null;
                }
                ajvValidators[primitive] = ajvSchema.compile({ $ref: "_" + schemaId });
            }
            return ajvValidators[primitive];
        }

        /**
         * Turn ajv errors into strings of their messages
         * @param {Array} errors Ajv error objects
         * @returns {string} Error message
         * @private
         */
        function _serializeErrors(errors) {
            var messages = [];
            for (var i=0; i<errors.length; i++) {
                var error = errors[i];
                var message = '';
                if (error.dataPath) {
                    message += error.dataPath+': ';
                }
                message += error.message;
                if ( Object.keys(error.params).length > 0) {
                    var param = error.params[Object.keys(error.params)[0]];
                    if (message.toLowerCase().indexOf(param) === -1) {
                        message += ' ['+error.params[Object.keys(error.params)[0]]+']';
                    }
                }
                messages.push(message);
            }
            return messages.join(', ');
        }

        // Map from primitive name to material type
        var _primToMaterial = null;

        // Map from primitive name to creation function
        var _primToFunc = null;

        /**
         * Create mappings from primitives to related data and cache for easy reuse
         */
        function _makePrimMaps() {
            if (_primToMaterial) return;
            _primToMaterial = {
                point: MATERIAL_TYPES.POINT
            };
            _primToFunc = {};
            var key;
            for (key in wirePrimitives) {
                _primToMaterial[key] = MATERIAL_TYPES.LINE;
                _primToFunc[key] = wirePrimitives[key];
            }
            for (key in sheetPrimitives) {
                _primToMaterial[key] = MATERIAL_TYPES.PHONG;
                _primToFunc[key] = sheetPrimitives[key];
            }
            for (key in solidPrimitives) {
                _primToMaterial[key] = MATERIAL_TYPES.PHONG;
                _primToFunc[key] = solidPrimitives[key];
            }
            for (key in otherPrimitives) {
                _primToMaterial[key] = MATERIAL_TYPES.PHONG;
                _primToFunc[key] = otherPrimitives[key];
            }
        }

        /**
         * Determine what function can be used to construct this primitive
         * @param  {String}     primitive   The name of the entity type
         * @return {Function}               Construction function
         */
        function _resolvePrimFunc (primitive) {
            _makePrimMaps();
            return _primToFunc[primitive];
        }

        /**
         * Determine the material type that would be used for a given primitive
         * @param {String} primitive The name of the entity type
         * @returns {constants.MATERIAL_TYPES} A function to convert a prim to geomtry and a material type
         */
        function resolveMaterialType (primitive) {
            _makePrimMaps();
            return _primToMaterial[primitive];
        }

        /**
         * Cache to prevent repetitive munging of arrays.
         * Stores all the acceptable primitive types for geometry.
         * @type {Array.<String>}
         */
        var _validPrimsList = null;

        /**
         * Return a list of all the valid primitive strings
         * @return {Array.<String>} The list of primitives
         */
        function listValidPrims ( ) {
            if (_validPrimsList) return _validPrimsList;

            _validPrimsList =    KNOWN_PRIMITIVES.concat(
                                Object.keys(otherPrimitives),
                                Object.keys(solidPrimitives),
                                Object.keys(sheetPrimitives),
                                Object.keys(wirePrimitives));
            return _validPrimsList;
        }

        var RIGHT = new THREE.Vector3(1, 0, 0);
        var IN    = new THREE.Vector3(0, 1, 0);
        var UP    = new THREE.Vector3(0, 0, 1);

        /**
         * Get the point size from a given entity
         * @param {Array} prims Array of point data
         * @returns {Number} Point size
         * @private
         */
        function _getPointSize(prims) {
            var size = DEFAULT_MATERIAL_PROPERTIES.point.size;
            // Just use the first point for now, can't set size per point.
            var prim = prims[0];
            if (!prim) return;
            var materialProperties = prim.materialProperties || (prim.attributes && prim.attributes.materialProperties);
            if (materialProperties && materialProperties.size) {
                size = materialProperties.size;
            }
            return size;
        }

        /**
         * Check points against their schema
         * @param  {Array.<Object>}     prims       List of points
         * @param  {GeometryResults}    geomResult  The error message container
         * @return {Boolean}                        True when all are valid
         */
        function _validatePoints(prims, geomResult) {
            var validPoints = true;
            for (var i=0;i<prims.length; i++) {
                if (!checkSchema(prims[i], geomResult.primStatus)) {
                    validPoints = false;
                }
            }
            return validPoints;
        }

        /**
         * Create the point cloud mesh for all the input primitives
         * @param {Object}          prims       List of point primitive objects
         * @param {GeometryResults} geomResult  Results object for errors and geometry
         */
        function createPoints (prims, geomResult) {
            if (!_validatePoints(prims, geomResult)) {
                return;
            }

            var positions = new Float32Array(prims.length*3);
            var colors = new Float32Array(prims.length*3);
            for (var i=0;i<prims.length;i++) {
                var prim = convertUnits(prims[i]);
                positions[i*3] = prim.point[0];
                positions[i*3+1] = prim.point[1];
                positions[i*3+2] = prim.point[2]||0;
                // Get color or default color
                var color = _convertColor(_getEntityData(prim, 'color', DEFAULT_POINT_COLOR));
                colors[i*3] = color.r;
                colors[i*3+1] = color.g;
                colors[i*3+2] = color.b;
            }
            var geometry = new THREE.BufferGeometry();

            geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
            geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

            // First create a point cloud with world space size
            var materialProperties = {
                size: _getPointSize(prims),// user can set world space size
                sizeAttenuation: true,
                vertexColors: THREE.VertexColors
            };
            var material = new THREE.PointsMaterial(materialProperties);
            var mesh = new THREE.Points( geometry, material );

            // Second create a point cloud with pixel size, to ensure they always render at least a few pixels
            var materialProperties2 = {
                size: POINT_PIXEL_SIZE, //pixels
                sizeAttenuation: false,
                vertexColors: THREE.VertexColors
            };
            var material2 = new THREE.PointsMaterial(materialProperties2);
            var mesh2 = new THREE.Points( geometry, material2 );

            var obj = new THREE.Object3D();
            obj.add(mesh);
            obj.add(mesh2);

            geomResult.primStatus.appendValid('point');
            geomResult.object.add(obj);
        }

        /**
         * Creates the ParaSolid Object
         *
         * @function createPrimitive
         * @return { THREE.Mesh } The created mesh
         * @throws FluxGeometryError if unsupported geometry is found
         *
         * @param { Object } data The data to create the object with
         * @param { GeometryResults } geomResult The container for the geometry and caches
         */
        function createPrimitive ( data, geomResult ) {
            var materialType = resolveMaterialType(data.primitive);

            // Get a new clone of the data with different units for rendering
            var dataNormalized = convertUnits(data);

            // Check that the entity matches a schema, otherwise return no geometry
            if (!checkSchema(data, geomResult.primStatus)) {
                return; // Errors are already added to geomResult
            }

            var materialProperties = _findMaterialProperties( dataNormalized );
            var material = _createMaterial( materialType, materialProperties, geomResult.cubeArray );
            // Check if color is bound to a texture image
            if (materialProperties.colorMap) {
                // Defer texture loading until later because the url is loaded async
                geomResult.pendingTextures.push(materialProperties.colorMap);
                geomResult.texturedMaterials.push(material);
            }
            var primFunction = _resolvePrimFunc(data.primitive);
            if (!primFunction) return;

            var mesh = primFunction( dataNormalized, material );

            if ( mesh ) {
                return cleanupMesh(mesh, dataNormalized, materialProperties);
            }

            throw new FluxGeometryError( 'Unsupported geometry type: ' + dataNormalized.primitive );

        }

        /**
         * Move the color from a material to a geometry.
         *
         * This allows meshes of different colors to be merged together.
         * Then the meshes can share a single material with per vertex color.
         *
         * @precondition The color object on the material should not be shared with other materials.
         * @param {THREE.Geometry|THREE.BufferGeometry} mesh The mesh containing geometry and material to manipulate
         * @private
         */
        function _moveMaterialColorToGeom(mesh) {
            var geom = mesh.geometry;
            var color = mesh.material.color;
            var color2 = color.clone();
            if (geom) {
                if (geom.type.indexOf('BufferGeometry') !== -1) {
                    // Set the color as a buffer attribute
                    var attrLen = geom.attributes.position.array.length;
                    var colors = [];
                    for (var i=0;i<attrLen;i+=3) {
                        colors.push(color.r);
                        colors.push(color.g);
                        colors.push(color.b);
                    }
                    geom.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array(colors), 3 ) );
                } else if (geom.faces.length > 0) {
                    // Set the color per face
                    for (var f=0;f<geom.faces.length;f++) {
                        geom.faces[f].color = color2;
                    }
                } else {
                    // Lines have a colors array since they don't have faces
                    for (var c=0;c<geom.vertices.length;c++) {
                        geom.colors[c] = color2;
                    }
                    geom.colorsNeedUpdate = true;
                }
                // Reset the color since it is now on the points.
                // In three.js color is multiplicative, so:
                // color = material color * vertex color
                // Hence after setting it on the mesh, it must be reset on the material.
                color.r = 1;
                color.g = 1;
                color.b = 1;
            }
        }

        /**
         * Do some post processing to the mesh to prep it for Flux
         * @param {THREE.Object3D} mesh Geometry and material object
         * @param {Object} data The entity object
         * @returns {THREE.Mesh} The processed mesh
         */
        function cleanupMesh(mesh, data) {
            // Text helper is ignored, due to it's own special materials.
            if (mesh.type !== "textHelper") {
                // Convert all geometry in the object tree
                mesh.traverse(function (child) {
                    // Only convert the color for objects with material
                    if (child.material) {
                        _moveMaterialColorToGeom(child);
                    }
                });
            }

            if (!data) {
                return;
            }

            if ( data.origin ) {
                _applyOrigin( mesh, data.origin );
            }

            var reference = data.reference;
            var axis = data.axis || data.direction || data.normal;
            if (reference || axis) {
                var axisVec = UP.clone();
                if ( axis ) {
                    axisVec.set(axis[0], axis[1], axis[2]);
                    axisVec.normalize();
                }

                var referenceVec = RIGHT.clone();
                if (reference) {
                    referenceVec.set(reference[0], reference[1], reference[2]);
                    referenceVec.normalize();
                } else if (referenceVec.distanceToSquared(axisVec) < TOLERANCE) {
                    referenceVec = IN.clone();
                }
                mesh.up = referenceVec.cross(axisVec);

                mesh.lookAt( mesh.position.clone().add(axisVec));
            }

            if (data.attributes && data.attributes.tag) {
                mesh.userData.tag = data.attributes.tag;
            }

            return mesh;
        }

        /**
         * Helper method to find the material properties on the data
         *
         * @function _findMaterialProperties
         * @private
         *
         * @return { Object } The material properties
         *
         * @param { Object } data The data used to construct the primitive
         */
        function _findMaterialProperties ( data ) {
            if ( data.attributes && data.attributes.materialProperties ) return data.attributes.materialProperties;
            else if ( data.materialProperties ) return data.materialProperties;
            else return {
                side: THREE.DoubleSide
            };
        }

        /**
         * Function to copy white listed properties from the input to the output
         * @param {Object} knownPropsMap Map from material properties to defualt values
         * @param {Object} propsIn Map from material properties to values
         * @param {Object} propsOut Subset of propsIn (return parameter)
         * @private
         */
        function _addKnownProps(knownPropsMap, propsIn, propsOut) {
            var knownProps = Object.keys(knownPropsMap);
            for (var i=0;i<knownProps.length;i++) {
                var prop = knownProps[i];
                var propValue = propsIn[prop];
                if (propValue != null) {
                    propsOut[prop] = propValue;
                }
            }
        }

        /**
         * Modify a material to approximate a shading model with roughness
         * @param {Number} roughness        The roughness (measures shiny to matte)
         * @param {THREE.Material} material The material to edit
         * @param {Array} cubeArray         Array of textures
         * @private
         */
        function _applyRoughness(roughness, material, cubeArray) {
            if (roughness != null && cubeArray != null) {
                // There are some magic numbers here to simulate physically-accurate lighting.
                // This is only an artistic approximation of physically-accurate models.
                // TODO(aki): implement custom shader with better lighting model.
                material.envMap = cubeArray[Math.floor(Math.pow(roughness, 0.2) * 8)];
                // TODO(aki): Colored materials have clear white reflection.
                material.combine = THREE.AddOperation;
                material.reflectivity = 1 - roughness * 1;
                if (material.color.r !== 1 || material.color.g !== 1 || material.color.b !== 1) {
                    var hsl = material.color.getHSL();
                    material.reflectivity *= Math.pow(hsl.l, 2);
                    material.specular = material.color.clone();
                    material.color.multiplyScalar(Math.pow(roughness, 0.3));
                    material.specular.multiplyScalar(1 - Math.pow(roughness, 2));
                }
            }
        }

        /**
         * Helper method to create the material from the material properties.
         * There are only a few types of materials used, this function takes a type
         * and returns a material with the properties object given
         *
         * @function _createMaterial
         * @private
         *
         * @return { THREE.Material } an instance of a Three.js material
         *
         * @param { Number } type               A member of the enumeration of material types
         *                                      present in the parasolid utility
         *
         * @param { Object } materialProperties A set of properties that functions
         *                                      as options for the material
         * @param {Array} cubeArray             Array of textures
         */
        function _createMaterial ( type, materialProperties, cubeArray ) {

            var material;
            // Just the properties that actually make sense for this material
            var props = {};
            // Add sidedness to local state if it is not present
            if ( materialProperties && !materialProperties.side ) {
                props.side = THREE.DoubleSide;
            }
            // Create a material of the appropriate type
            if ( type === MATERIAL_TYPES.PHONG ) {
                // Add material properties related to shadows. This is an offset
                // to prevent z-fighting with stencil buffer shadows and their host object
                props.polygonOffset = true;
                props.polygonOffsetFactor = 1;
                props.polygonOffsetUnits = 1;
                props.vertexColors = THREE.VertexColors;

                _addKnownProps(DEFAULT_MATERIAL_PROPERTIES.phong, materialProperties, props);

                if (materialProperties.colorMap) {
                    if (materialProperties.noLighting) {
                        material = new THREE.MeshBasicMaterial( props );
                    } else {
                        material = new THREE.MeshPhongMaterial( props );
                    }
                } else {
                    material = new THREE.MeshPhongMaterial( props );
                }
                material.color = _convertColor(materialProperties.color||DEFAULT_PHONG_COLOR);

                // Apply roughness (modifies color and other material object properties)
                _applyRoughness(materialProperties.roughness, material, cubeArray);
                if (materialProperties.roughness) props.roughness = materialProperties.roughness;

            } else if ( type === MATERIAL_TYPES.POINT ) {

                _addKnownProps(DEFAULT_MATERIAL_PROPERTIES.point, materialProperties, props);
                material = new THREE.PointsMaterial( props );
                material.color = _convertColor(materialProperties.color||DEFAULT_POINT_COLOR);

            } else if ( type === MATERIAL_TYPES.LINE ) {

                props.vertexColors = THREE.VertexColors;
                _addKnownProps(DEFAULT_MATERIAL_PROPERTIES.line, materialProperties, props);
                material = new THREE.LineBasicMaterial( props );
                material.color = _convertColor(materialProperties.color||DEFAULT_LINE_COLOR);
            }
            // Use the material's name to track uniqueness of it's source
            material.name = materialToJson(type, props);

            if (material.opacity < 1) {
                material.transparent = true;
            }

            return material;

        }

        /**
         * A helper to apply an origin to a mesh
         *
         * @function _applyOrigin
         * @private
         *
         * @param { THREE.Mesh } mesh The mesh to receive the origin
         * @param { Array } origin The vector representing the origin
         */
        function _applyOrigin ( mesh, origin ) {
            mesh.position.set(
                origin[ 0 ],
                origin[ 1 ],
                origin[ 2 ] ? origin[ 2 ] : 0
            );
        }

        function StatusMap() {
            // Container for all errors
            // Map from string to list of strings
            this.errors = {};
        }

        // Static variable to initialize key with no error
        StatusMap.NO_ERROR = '';

        /**
         * Clear / initialize all temporary arrays
         */
        StatusMap.prototype.clear = function () {
            this.errors = {};
        };

        /**
         * Add a new error to the map.
         * If the error is StatusMap.NO_ERROR the entry will be added, but the list will
         * be empty, which allows the user to get a list of valid keys if needed.
         * @param {String} key The name of the error
         * @param {String} newError The error message
         */
        StatusMap.prototype.appendError = function (key, newError) {
            // Make sure the entry exists
            this.appendValid(key);
            // Add the error if it exists and is not a duplicate
            if (newError && this.errors[key].indexOf(newError) === -1) {
                this.errors[key].push(newError);
            }
        };

        /**
         * Add a key to indicate that an item was processed with no errors
         * @param  {String} key The item to store
         */
        StatusMap.prototype.appendValid = function (key) {
            // Make sure the entry exists so we can track what keys are valid
            if (!this.errors[key]) {
                this.errors[key] = [];
            }
        };

        /**
         * Determine if key is valid
         * @param {String} key Where to look in the map
         * @returns {boolean} True if the key is valid, meaning no errors
         */
        StatusMap.prototype.validKey = function (key) {
            return !this.errors[key] || this.errors[key].length === 0;
        };

        /**
         * Determine if the key is invalid
         * @param {String} key The entry to look for
         * @returns {boolean} True if the key is NOT valid, meaning has an error
         */
        StatusMap.prototype.invalidKey = function (key) {
            return !this.validKey(key);
        };

        /**
         * Create a human readable summary of all the errors.
         * @returns {string} The summary
         */
        StatusMap.prototype.invalidKeySummary = function () {
            var _this = this;
            var errors = Object.keys(this.errors).reduce(function (prev, key) {
                if (_this.invalidKey(key)) {
                    prev.push(key+' ('+_this.errors[key].join(', ')+')');
                }
                return prev;
            },[]);
            return errors.join(', ');
        };

        /**
         * Merge the errors in this map with that of another
         * @param  {StatusMap} other The other one
         */
        StatusMap.prototype.merge = function (other) {
            for (var key in other.errors) {
                this.errors[key] = other.errors[key];
            }
        };

        /**
         * Container class for 3D geometry and errors.
         * Note: This could call clear, but does not in order to allow JavaScript
         * compiler to optimize the member variable initialization
         * asyncPrims - Buffer for prims that require a server call
         * pendingTextures - data for textures stored as blob urls
         * texturedMaterials - Array of materials. Indexing is parallel to pendingTextures
         *                     so that once the texture is loaded it can be applied to the
         *                     corresponding material.
         * pointPrims - Buffer for combining all point objects
         * linePrims - Buffer for combining all line objects
         * phongPrims - Buffer for combining all surface objects
         * _layerPrims - List of layers
         */
        function GeometryResults() {
            // Container for all geometry results
            this.object = new THREE.Object3D();

            // Map from primitive name to error string or empty string when no error
            this.primStatus = new StatusMap();

            // Array of THREE.Texture objects used for image based lighting
            this.cubeArray = null;

            this.asyncPrims = [];
            this.pendingTextures = [];
            this.texturedMaterials = [];

            this.pointPrims = [];
            this.linePrims = [];
            this.phongPrims = [];
            this._layerPrims = [];
        }

        /**
         * Reset all temporary buffers so new geometry can be added
         */
        GeometryResults.prototype.clear = function () {
            this.asyncPrims = [];
            this.pointPrims = [];
            this.linePrims = [];
            this.phongPrims = [];
            this._layerPrims = [];
        };

        /**
        * Helper function to extract mesh from geometry
        * from a revitElement object.
        *
        * @function extractGeom
        *
        * @param { object } data The revitElement object to extract geometry.
        *
        * @return { Array.<object> } An array of mesh objects.
        */
        function extractGeom (data) {
            // TODO(Jaydeep) check data against Revit Schema here.
            if (data.geometryParameters && data.geometryParameters.geometry) {
                var meshData = data.geometryParameters.geometry;
                if (data.attributes && data.attributes.materialProperties) {
                    if (meshData.constructor === Array) {
                        for(var i=0; i < meshData.length; ++i) {
                            if (!meshData[i].attributes) {
                                meshData[i].attributes = {};
                            }
                            meshData[i].attributes.materialProperties = data.attributes.materialProperties;
                        }
                    }
                }
                return meshData;
            }
            return data;
        }

        /**
         * Helper function to run a callback on each entity in the nested array
         * @param {Array} arr Array of arrays or entities
         * @param {Function} cb Callbck function returning boolean
         * @returns {boolean} Reduced return value of the callback
         * @private
         */
        function _recursiveReduce (arr, cb) {
            if (!arr) return false;
            var isValid = false;
            if (arr.primitive) {
                isValid = cb(arr);
            } else if (arr.constructor === Array) {
                isValid = arr.reduce(function(prev, curr) {
                    return prev || _recursiveReduce(curr, cb);
                }, false);
            }
            return isValid;
        }
        /**
         * Determine if the given data contains geometry.
         *
         * It must only contain geometry, and arrays of geometry, no mixed types.
         *
         * @param  {Object}  data Flux JSON formatted object.
         * @return {Boolean}      Whether the data is geometry.
         */
        function isKnownGeom (data) {
            var prims = listValidPrims();
            return _recursiveReduce(data, function (item) {
                return prims.indexOf(item.primitive) !== -1;
            });
        }

        /**
         * Determine if the given data contains materials with roughness.
         *
         * Then it is necessary to load the related textures
         *
         * @param  {Object}  entities Flux JSON formatted object.
         * @return {Boolean}      Whether the materials have roughness.
         */
        function hasRoughness(entities) {
            return _recursiveReduce(entities, function (item) {
                return _getEntityData(item, 'roughness', undefined) != null;
            });
        }
        /**
         * Creates THREE scene and geometries from parasolid output.
         * The method is called recursively for each array and entities
         * map
         *
         * @function createObject
         *
         * @param { Object }  data        Parasolid Data from the flux json representation
         * @param { Object } geomResult Object containing properties for categorizing primitives
         */
        function createObject ( data, geomResult ) {
            if (!geomResult || geomResult.constructor !== GeometryResults) {
                throw new Error('Second argument must have class GeometryResults');
            }

            // It is very important to call clear here, otherwise all existing primtives
            // will be rebuilt and re-added to the scene when any brep response comes back from the server
            geomResult.clear();

            if (data && Object.keys(data).length > 0) {
                _flattenData(data, geomResult);
                _createObject(geomResult);
            }
        }

        /**
         * Resolve the nested arrays of primitives into categorized flat arrays of primitives.
         * @param {Object} data The entities objects / arrays
         * @param {GeometryResult} geomResult The results container
         * @private
         */
        function _flattenData(data, geomResult) {
            if (!data) return;

            // Breps are skipped when they need to be handled async
            if (data.primitive === 'brep' && (data.faces == null || data.vertices == null)) {
                geomResult.asyncPrims.push(data);
            } else if (data.primitive) {
                if (data.primitive === 'polycurve') {
                    Array.prototype.push.apply(geomResult.linePrims,data.curves);
                } else if (data.primitive === 'polysurface') {
                    Array.prototype.push.apply(geomResult.phongPrims,data.surfaces);
                } else if (data.primitive === "revitElement") {
                    Array.prototype.push.apply(geomResult.phongPrims, extractGeom(data));
                }
                else {
                    var type = resolveMaterialType(data.primitive);
                    switch (type) {
                        case MATERIAL_TYPES.POINT: {
                            geomResult.pointPrims.push(data);
                            break;
                        }
                        case MATERIAL_TYPES.LINE: {
                            geomResult.linePrims.push(data);
                            break;
                        }
                        case MATERIAL_TYPES.PHONG: {
                            geomResult.phongPrims.push(data);
                            break;
                        }
                        default: {
                            geomResult.primStatus.appendError(data.primitive, 'Unsupported geometry type');
                        }
                    }
                }
            }
            if (data.constructor === Array) {
                for (var i=0;i<data.length;i++) {
                    _flattenData(data[i], geomResult);
                }
            }
        }
        /**
         * Create the objects for each geometry type.
         * @param {GeometryResult} geomResult The results container
         * @private
         */
        function _createObject ( geomResult ) {
            _handlePoints(geomResult);
            _handleLines(geomResult);
            _handlePhongs(geomResult);
        }

        /**
         * Create all point objects into point clouds.
         * @param {GeometryResult} geomResult The results container
         * @private
         */
        function _handlePoints(geomResult) {
            var prims = geomResult.pointPrims;
            if (prims.length === 0) return;
            createPoints(prims, geomResult);
        }

        /**
         * Create all the lines primitives.
         * @param {GeometryResult} geomResult The results container
         * @private
         */
        function _handleLines(geomResult) {
            var prims = geomResult.linePrims;
            if (prims.length === 0) return;
            _handlePrimitives(prims, geomResult);
        }

        /**
         * Create all geometry that will be phong shaded.
         * @param {GeometryResult} geomResult The results container
         * @private
         */
        function _handlePhongs(geomResult) {
            var prims = geomResult.phongPrims;
            if (prims.length === 0) return;
            _handlePrimitives(prims, geomResult);
        }

        /**
         * Create all the three.js geometry from a list of JSON data.
         *
         * Pseudo-code usage example: _handlePrimitives([{primitive:mesh},{primitive:mesh}],
         *                                              {errors:'',result:{Mesh Hierarchy}})
         * First we convert each item to the appropriate three.js geometry from its
         * JSON data representation. Then the meshes are grouped by their materials,
         * since meshes with the same material can be combined into a single mesh as an
         * optimization. Finally the grouped meshes are merged together and added
         * to the final result.
         *
         * @param {Array.<Object>} prims Array of Flux JSON primitive data
         * @param {GeometryResult} geomResult The results container
         */
        function _handlePrimitives( prims, geomResult ) {
            var primMeshes = [];
            var i;
            var mesh;

            // create
            for (i=0;i<prims.length;i++) {
                mesh = _tryCreatePrimitive( prims[i], geomResult);
                if (mesh) {
                    primMeshes.push(mesh);
                }
            }

            // Build a map to collect similar objects that can merge
            var materialToMeshes = {};
            for (i=0;i<primMeshes.length;i++) {
                mesh = primMeshes[i];
                if (_objectCanMerge(mesh)) {
                    var name = mesh.material.name;
                    var sameMeshList = materialToMeshes[name];
                    if (!sameMeshList) {
                        materialToMeshes[name] = [];
                    } else if (!_sameProperties(primMeshes[i].geometry, sameMeshList[sameMeshList.length-1].geometry)) {
                        throw new FluxGeometryError('Found two similar meshes with different attributes');
                    }
                    materialToMeshes[name].push(primMeshes[i]);
                } else {
                    geomResult.object.add(mesh);
                }
            }
            for (var key in materialToMeshes) {
                var meshes = materialToMeshes[key];
                _maybeMergeModels(meshes, geomResult);
            }
        }

        /**
         * Call create primitive and handle errors due to bad inputs
         * @param {Object} data Primitive properties
         * @param {GeometryResults} geomResult The results object for shared data
         * @returns {THREE.Object3D} The created primitive or falsey
         * @private
         */
        function _tryCreatePrimitive(data, geomResult) {
            var mesh;
            var errorMessage = StatusMap.NO_ERROR;
            try {
                mesh = createPrimitive( data, geomResult );
            }
            catch(err) {
                if (err.name !== "FluxGeometryError") {
                    throw err;
                } else {
                    errorMessage = err.message;
                }
            }
            // Get the error message that exists, and add to it if it exists, or set it
            geomResult.primStatus.appendError(data.primitive, errorMessage);
            return mesh;
        }

        /**
         * Determines if an object can merge.
         *
         * Currently only meshes can be merged.
         *
         * @function _objectCanMerge
         * @private
         *
         * @returns { Boolean } Whether the object is a mesh that can be combined with others
         *
         * @param { THREE.Object3D } object The object to check
         */
        function _objectCanMerge ( object ) {
            return false;//object && object.geometry && object.type === 'Mesh' ;
        }

        /**
         * Determine if two geometries have the same configuration of face vertex uvs
         * Used to determine if the geometry can merge.
         * Three.js throws warnings when converting to buffer geometry if they are mismatched.
         * @param {THREE.Geometry|THREE.BufferGeometry} geomA The first geometry
         * @param {THREE.Geometry|THREE.BufferGeometry} geomB The second geometry
         * @returns {boolean} True if they match
         * @private
         */
        function _sameProperties(geomA, geomB) {
            var bufferA = geomA instanceof THREE.BufferGeometry;
            if (bufferA !== geomB instanceof THREE.BufferGeometry) {
                return false;
            }
            if (bufferA) {
                return true;
            }
            var hasFaceVertexUvA = geomA.faceVertexUvs[ 0 ] && geomA.faceVertexUvs[ 0 ].length > 0;
            var hasFaceVertexUv2A = geomA.faceVertexUvs[ 1 ] && geomA.faceVertexUvs[ 1 ].length > 0;
            var hasFaceVertexUvB = geomB.faceVertexUvs[ 0 ] && geomB.faceVertexUvs[ 0 ].length > 0;
            var hasFaceVertexUv2B = geomB.faceVertexUvs[ 1 ] && geomB.faceVertexUvs[ 1 ].length > 0;
            return hasFaceVertexUvA === hasFaceVertexUvB && hasFaceVertexUv2A === hasFaceVertexUv2B;
        }

        /**
         * Helper function to merge the children of a particular
         * object in the scene graph into the fewest number of children
         * possible.
         *
         * @function _mergeModels
         * @private
         *
         * @param { Array.<THREE.Object3D> } meshes A list of meshes to join into one
         * @param { Object }       geomResult The object being built
         */
        function _maybeMergeModels ( meshes, geomResult ) {
            if ( !geomResult.object ) geomResult.object = new THREE.Object3D();

            if (!meshes || meshes.constructor !== Array || meshes.length === 0) return;
            if (meshes.length === 1) {
                geomResult.object.add(meshes[0]);
                return;
            }
            var baseMesh = meshes[0];
            // Let's move the geometry from mesh to base mesh
            baseMesh.updateMatrixWorld();
            // Remember matrix multiplication applies in reverse
            var matXform = new THREE.Matrix4();
            // transform all the other meshes into the same coordinate system.
            for (var i=1;i<meshes.length;i++) {
                var mesh = meshes[i];
                mesh.updateMatrixWorld(true);

                // Apply the inverse of baseMesh transform to put the vertices from world space into it's local space
                matXform.getInverse(baseMesh.matrixWorld);
                // Apply the mesh transform to get verts from mesh in world space
                matXform.multiply(mesh.matrixWorld);
                mesh.geometry.applyMatrix(matXform);
            }
            var mergedMesh = mergeBufferGeom(meshes);
            baseMesh.geometry = mergedMesh;
            geomResult.object.add(baseMesh);
        }

        var WARNING_LEVELS = {
            ALL: 5,
            LOG: 4,
            INFO: 3,
            WARN: 2,
            ERROR: 1,
            SILENT: 0
        };
        var WARNING_LEVEL = WARNING_LEVELS.INFO;

        function log(message) {
            if (WARNING_LEVEL >= WARNING_LEVELS.LOG) {
                console.log(message); // eslint-disable-line no-console
            }
        }

        function warn(message) {
            if (WARNING_LEVEL >= WARNING_LEVELS.WARN) {
                console.warn(message); // eslint-disable-line no-console
            }
        }

        var util = __commonjs(function (module) {
        // Inherit one type from another, adding methods via prototype object
        // TODO(andrew): once https://vannevar.atlassian.net/browse/LIB3D-623 lands,
        // I think that we can remove all use of inherit and the remaining pseudoclasses.
        // Inherit one type from another, adding methods via prototype object
        function inherit(clazz, base, proto) {
            clazz.prototype = Object.create(base.prototype);
            clazz.prototype.constructor = clazz;
            if (proto)
                Object.keys(proto).forEach(
                    function (key) {
                        clazz.prototype[key] = proto[key];
                    }
                );
        }
        /** @class Throwable

            More universal error type than Error
            * supports JS inheritance
            * can capture stack trace properly
            * supports exception chaining, i.e. 'error causes'

            Important!
            Any subclass of Throwable MUST invoke 'this.captureStackTrace()'
            in its constructor BEFORE invoking super's constructor
            This will ensure that stack trace will be properly captured
            Calling 'this.captureStackTrace()' multiple times on the same object
            will do no harm, as only the first call will initialize 'stack' property
         */
        function Throwable(message) {
            this.captureStackTrace();
            this.message = (message || "");
        }

        Throwable.prototype = new Error();
        Throwable.prototype.constructor = Throwable;

        Throwable.prototype.causedBy = function (cause) {
            this.cause = cause;
            return this;
        }
        Throwable.prototype.toString = function () {
            return this.constructor.name + (this.message ? ': ' + this.message : '');
        };
        // This method must be invoked in each descendant class' constructor
        // befor calling down to super's ctor.
        // Such approach gives us loss of only 2 stack frames
        Throwable.prototype.captureStackTrace = function () {
            // If already initialized, return just here
            if (this.hasOwnProperty("stack"))
                return;
            // I know this is usually a bad idea.
            // Though I have no better way to capture stacktraces
            // in platform-independent way
            // I hope V8's Error.captureStackTrace will become kind of standard someday
            var tmp = new Error();
            Object.defineProperty(this, "stack", {
                configurable: true,
                enumerable:   false,
                get: function () {
                    // first, capture trace as string
                    var trace = tmp.stack.slice(6); // cut 'Error\n' just here
                    // next, eliminate first 2 frames
                    // captureStackTrace frame
                    // and constructor frame
                    var mid = trace.indexOf('\n');
                    mid = trace.indexOf('\n', mid + 1);
                    trace = trace.slice(mid + 1);
                    // lastly, compose with this exception's toString
                    trace = this.toString() + '\n' + trace;
                    if (this.cause)
                        trace += '\n*caused by ' + this.cause.stack;
                    Object.defineProperty(this, "stack", {
                        enumerable: false,
                        writable:   false,
                        value:      trace
                    });
                    return trace;
                }
            });
        };

        function FluxModelingError(message) {
            this.captureStackTrace();
            Throwable.call(this, message || 'Invalid or degenerate geometry specified');
        }
        inherit(FluxModelingError, Throwable);

        module.exports = {
            Throwable:          Throwable,
            inherit:            inherit,
            FluxModelingError:  FluxModelingError
        };
        });

        var require$$0$1 = (util && typeof util === 'object' && 'default' in util ? util['default'] : util);

        var $schema$1 = "http://json-schema.org/draft-04/schema#";
        var title = "flux-revit schema";
        var description = "schema for revit elements in flux.";
        var require$$0$3 = {
        	$schema: $schema$1,
        	title: title,
        	description: description,
        	"revit-types": {"revit-primitive":{"enum":["revitElement"]},"revit-fluxId":{"type":["string","null"]},"revit-level":{"type":"string"},"revit-structuralType":{"enum":["Beam","Column","Brace","Footing","NonStructural"]},"revit-placementType":{"enum":["OneLevelBased","TwoLevelsBased","OneLevelBasedHosted","Invalid"]},"revit-parameters-map":{"type":"object","additionalProperties":false,"patternProperties":{".*":{"type":["string","number","boolean","null"]}}},"revit-mesh-geometry":{"type":"array","items":{"$ref":"flux-entity#/entities/mesh"}},"revit-material":{"type":"object","properties":{"name":{"type":"string"},"area":{"type":"number"},"volume":{"type":"number"},"paintMaterial":{"type":"boolean"},"instanceParameters":{"$ref":"#/revit-types/revit-parameters-map"}},"required":["name","area","volume","paintMaterial","instanceParameters"]},"revit-materialInfo":{"type":"array","items":{"$ref":"#/revit-types/revit-material"}},"revit-familyInfo":{"type":"object","properties":{"category":{"type":"string"},"family":{"type":"string"},"type":{"type":"string"},"placementType":{"$ref":"#/revit-types/revit-placementType"}},"required":["category","family","type","placementType"]},"revit-profile":{"type":"array","minItems":1,"items":{"anyOf":[{"$ref":"flux-entity#/entities/line"},{"$ref":"flux-entity#/entities/curve"},{"$ref":"flux-entity#/entities/arc"},{"$ref":"flux-entity#/entities/polyline"}]}},"revit-location":{"anyOf":[{"$ref":"flux-entity#/entities/point"},{"$ref":"flux-entity#/entities/line"},{"$ref":"flux-entity#/entities/curve"},{"$ref":"flux-entity#/entities/arc"}]},"revit-common":{"type":"object","properties":{"fluxId":{"$ref":"#/revit-types/revit-fluxId"},"primitive":{"$ref":"#/revit-types/revit-primitive"},"familyInfo":{"$ref":"#/revit-types/revit-familyInfo"},"materialInfo":{"$ref":"#/revit-types/revit-materialInfo"},"units":{"$ref":"flux-entity#/types/units"},"instanceParameters":{"$ref":"#/revit-types/revit-parameters-map"},"typeParameters":{"$ref":"#/revit-types/revit-parameters-map"},"customParameters":{"$ref":"#/revit-types/revit-parameters-map"}},"required":["fluxId","primitive","familyInfo"]}},
        	"revit-wall": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"flipped":{"type":"boolean"},"level":{"$ref":"#/revit-types/revit-level"},"profile":{"$ref":"#/revit-types/revit-profile"},"structural":{"type":"boolean"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["flipped","level","profile","structural"]}},"required":["geometryParameters"]}]},
        	"revit-room": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"name":{"type":"string"},"level":{"$ref":"#/revit-types/revit-level"},"uv":{"$ref":"flux-entity#/entities/point"},"phase":{"type":"string"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["name","level","uv"]}},"required":["geometryParameters"]}]},
        	"revit-referencePlane": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"name":{"type":"string"},"wallClosure":{"type":"boolean"},"bubbleEnd":{"$ref":"flux-entity#/entities/point"},"freeEnd":{"$ref":"flux-entity#/entities/point"},"thirdPoint":{"$ref":"flux-entity#/entities/point"},"cutVector":{"$ref":"flux-entity#/entities/vector"}},"required":["name","wallClosure","bubbleEnd","freeEnd","cutVector"]}},"required":["geometryParameters"]}]},
        	"revit-modelCurve": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"curve":{"anyOf":[{"$ref":"flux-entity#/entities/line"},{"$ref":"flux-entity#/entities/curve"},{"$ref":"flux-entity#/entities/arc"}]}},"required":["curve"]}},"required":["geometryParameters"]}]},
        	"revit-level": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"name":{"type":"string"},"elevation":{"$ref":"flux-entity#/types/distance"}},"required":["name","elevation"]}},"required":["geometryParameters"]}]},
        	"revit-grid": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"name":{"type":"string"},"curve":{"anyOf":[{"$ref":"#/entities/line"},{"$ref":"#/entities/arc"}]}},"required":["name","curve"]}},"required":["geometryParameters"]}]},
        	"revit-floor": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"profile":{"$ref":"#/revit-types/revit-profile"},"structural":{"type":"boolean"},"normal":{"$ref":"flux-entity#/types/direction"},"level":{"$ref":"#/revit-types/revit-level"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["profile","structural","level"]}},"required":["geometryParameters"]}]},
        	"revit-oneLevelFamilyInstance": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"location":{"$ref":"#/revit-types/revit-location"},"level":{"$ref":"#/revit-types/revit-level"},"structuralType":{"$ref":"#/revit-types/revit-structuralType"},"faceFlipped":{"type":"boolean"},"handFlipped":{"type":"boolean"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["location","level","structuralType","faceFlipped","handFlipped"]}},"required":["geometryParameters"]}]},
        	"revit-twoLevelFamilyInstance": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"location":{"$ref":"#/revit-types/revit-location"},"baseLevel":{"$ref":"#/revit-types/revit-level"},"topLevel":{"$ref":"#/revit-types/revit-level"},"structuralType":{"$ref":"#/revit-types/revit-structuralType"},"faceFlipped":{"type":"boolean"},"handFlipped":{"type":"boolean"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["location","baseLevel","topLevel","structuralType","faceFlipped","handFlipped"]}},"required":["geometryParameters"]}]},
        	"revit-oneLevelHostedFamilyInstance": {"type":"object","allOf":[{"$ref":"#/revit-types/revit-common"},{"properties":{"geometryParameters":{"properties":{"location":{"$ref":"#/revit-types/revit-location"},"level":{"$ref":"#/revit-types/revit-level"},"hostId":{"$ref":"#/revit-types/revit-fluxId"},"structuralType":{"$ref":"#/revit-types/revit-structuralType"},"faceFlipped":{"type":"boolean"},"handFlipped":{"type":"boolean"},"geometry":{"$ref":"#/revit-types/revit-mesh-geometry"}},"required":["location","level","hostId","structuralType","faceFlipped","handFlipped"]}},"required":["geometryParameters"]}]}
        };

        var index$2 = __commonjs(function (module) {
        /** @file Export declaration for submodules
         *  All submodules are fetched lazily, on first request
         *  @author Igor Baidiuk <ibaidiuk@amcbridge.com>
         */
        /* jslint node:true */
        "use strict";
        /*
            Adds property to object whose value will be computed only on first access
        */
        function lazy_prop(obj, prop, initializer) {
            Object.defineProperty(obj, prop, {
                configurable: true,
                enumerable:   false,
                get: function () {
                    var value = initializer();
                    Object.defineProperty(this, prop, {
                        enumerable: true,
                        value:      value
                    });
                    return value;
                }
            });
        }

        function submodules(obj) {
            var exps = {};
            Object.keys(obj).forEach(function (key) {
                var modpath = obj[key];
                if (typeof modpath === 'string')
                    lazy_prop(exps, key, function () { return require(modpath); });
                else
                    Object.defineProperty(exps, key, {
                        enumerable: true,
                        writable: false,
                        value: modpath
                    });
            });
            return exps;
        }
        /**
            Exports section

            NB: Submodules are loaded lazily here, only when they're referenced. Some submodules can
            impact load times, even when not needed at all. As an example, PBW integration tests run
            about twice the time when 'measure' is loaded eagerly. It's a large piece of ASM.JS code,
            and loading it on each script run impacts interpreter.
         */
        module.exports = submodules({
            'measure':  './measure',
            'modeling': './modeling',
            'revit':    './revit-core',
            'schemas':  {
                'pbw':      require$$1,
                'revit':    require$$0$3
            },
            'types': './types',
            'uuid':     './uuid'
        });
        });

        var require$$0$2 = (index$2 && typeof index$2 === 'object' && 'default' in index$2 ? index$2['default'] : index$2);

        var id = "http://json-schema.org/draft-04/schema#";
        var $schema$2 = "http://json-schema.org/draft-04/schema#";
        var description$1 = "Core schema meta-schema";
        var definitions = {"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"positiveInteger":{"type":"integer","minimum":0},"positiveIntegerDefault0":{"allOf":[{"$ref":"#/definitions/positiveInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"minItems":1,"uniqueItems":true}};
        var type = "object";
        var properties = {"id":{"type":"string","format":"uri"},"$schema":{"type":"string","format":"uri"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"multipleOf":{"type":"number","minimum":0,"exclusiveMinimum":true},"maximum":{"type":"number"},"exclusiveMaximum":{"type":"boolean","default":false},"minimum":{"type":"number"},"exclusiveMinimum":{"type":"boolean","default":false},"maxLength":{"$ref":"#/definitions/positiveInteger"},"minLength":{"$ref":"#/definitions/positiveIntegerDefault0"},"pattern":{"type":"string","format":"regex"},"additionalItems":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"$ref":"#/definitions/positiveInteger"},"minItems":{"$ref":"#/definitions/positiveIntegerDefault0"},"uniqueItems":{"type":"boolean","default":false},"maxProperties":{"$ref":"#/definitions/positiveInteger"},"minProperties":{"$ref":"#/definitions/positiveIntegerDefault0"},"required":{"$ref":"#/definitions/stringArray"},"additionalProperties":{"anyOf":[{"type":"boolean"},{"$ref":"#"}],"default":{}},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"enum":{"type":"array","minItems":1,"uniqueItems":true},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"}};
        var dependencies = {"exclusiveMaximum":["maximum"],"exclusiveMinimum":["minimum"]};
        var require$$0$4 = {
        	id: id,
        	$schema: $schema$2,
        	description: description$1,
        	definitions: definitions,
        	type: type,
        	properties: properties,
        	dependencies: dependencies,
        	"default": {}
        };

        var validation_error = __commonjs(function (module) {
        'use strict';

        module.exports = ValidationError;


        function ValidationError(errors) {
          this.message = 'validation failed';
          this.errors = errors;
          this.ajv = this.validation = true;
        }


        ValidationError.prototype = Object.create(Error.prototype);
        ValidationError.prototype.constructor = ValidationError;
        });

        var require$$0$5 = (validation_error && typeof validation_error === 'object' && 'default' in validation_error ? validation_error['default'] : validation_error);

        var keyword = __commonjs(function (module) {
        'use strict';

        var IDENTIFIER = /^[a-z_$][a-z0-9_$]*$/i;

        /**
         * Define custom keyword
         * @this  Ajv
         * @param {String} keyword custom keyword, should be a valid identifier, should be different from all standard, custom and macro keywords.
         * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
         */
        module.exports = function addKeyword(keyword, definition) {
          /* eslint no-shadow: 0 */
          var self = this;
          if (this.RULES.keywords[keyword])
            throw new Error('Keyword ' + keyword + ' is already defined');

          if (!IDENTIFIER.test(keyword))
            throw new Error('Keyword ' + keyword + ' is not a valid identifier');

          if (definition) {
            var dataType = definition.type;
            if (Array.isArray(dataType)) {
              var i, len = dataType.length;
              for (i=0; i<len; i++) checkDataType(dataType[i]);
              for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
            } else {
              if (dataType) checkDataType(dataType);
              _addRule(keyword, dataType, definition);
            }
          }

          this.RULES.keywords[keyword] = true;
          this.RULES.all[keyword] = true;


          function _addRule(keyword, dataType, definition) {
            var ruleGroup;
            for (var i=0; i<self.RULES.length; i++) {
              var rg = self.RULES[i];
              if (rg.type == dataType) {
                ruleGroup = rg;
                break;
              }
            }

            if (!ruleGroup) {
              ruleGroup = { type: dataType, rules: [] };
              self.RULES.push(ruleGroup);
            }

            var rule = { keyword: keyword, definition: definition, custom: true };
            ruleGroup.rules.push(rule);
          }


          function checkDataType(dataType) {
            if (!self.RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
          }
        };
        });

        var require$$2 = (keyword && typeof keyword === 'object' && 'default' in keyword ? keyword['default'] : keyword);

        var index$3 = __commonjs(function (module) {
        /**
         * slice() reference.
         */

        var slice = Array.prototype.slice;

        /**
         * Expose `co`.
         */

        module.exports = co['default'] = co.co = co;

        /**
         * Wrap the given generator `fn` into a
         * function that returns a promise.
         * This is a separate function so that
         * every `co()` call doesn't create a new,
         * unnecessary closure.
         *
         * @param {GeneratorFunction} fn
         * @return {Function}
         * @api public
         */

        co.wrap = function (fn) {
          createPromise.__generatorFunction__ = fn;
          return createPromise;
          function createPromise() {
            return co.call(this, fn.apply(this, arguments));
          }
        };

        /**
         * Execute the generator function or a generator
         * and return a promise.
         *
         * @param {Function} fn
         * @return {Promise}
         * @api public
         */

        function co(gen) {
          var ctx = this;
          var args = slice.call(arguments, 1)

          // we wrap everything in a promise to avoid promise chaining,
          // which leads to memory leak errors.
          // see https://github.com/tj/co/issues/180
          return new Promise(function(resolve, reject) {
            if (typeof gen === 'function') gen = gen.apply(ctx, args);
            if (!gen || typeof gen.next !== 'function') return resolve(gen);

            onFulfilled();

            /**
             * @param {Mixed} res
             * @return {Promise}
             * @api private
             */

            function onFulfilled(res) {
              var ret;
              try {
                ret = gen.next(res);
              } catch (e) {
                return reject(e);
              }
              next(ret);
            }

            /**
             * @param {Error} err
             * @return {Promise}
             * @api private
             */

            function onRejected(err) {
              var ret;
              try {
                ret = gen.throw(err);
              } catch (e) {
                return reject(e);
              }
              next(ret);
            }

            /**
             * Get the next value in the generator,
             * return a promise.
             *
             * @param {Object} ret
             * @return {Promise}
             * @api private
             */

            function next(ret) {
              if (ret.done) return resolve(ret.value);
              var value = toPromise.call(ctx, ret.value);
              if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
              return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
                + 'but the following object was passed: "' + String(ret.value) + '"'));
            }
          });
        }

        /**
         * Convert a `yield`ed value into a promise.
         *
         * @param {Mixed} obj
         * @return {Promise}
         * @api private
         */

        function toPromise(obj) {
          if (!obj) return obj;
          if (isPromise(obj)) return obj;
          if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
          if ('function' == typeof obj) return thunkToPromise.call(this, obj);
          if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
          if (isObject(obj)) return objectToPromise.call(this, obj);
          return obj;
        }

        /**
         * Convert a thunk to a promise.
         *
         * @param {Function}
         * @return {Promise}
         * @api private
         */

        function thunkToPromise(fn) {
          var ctx = this;
          return new Promise(function (resolve, reject) {
            fn.call(ctx, function (err, res) {
              if (err) return reject(err);
              if (arguments.length > 2) res = slice.call(arguments, 1);
              resolve(res);
            });
          });
        }

        /**
         * Convert an array of "yieldables" to a promise.
         * Uses `Promise.all()` internally.
         *
         * @param {Array} obj
         * @return {Promise}
         * @api private
         */

        function arrayToPromise(obj) {
          return Promise.all(obj.map(toPromise, this));
        }

        /**
         * Convert an object of "yieldables" to a promise.
         * Uses `Promise.all()` internally.
         *
         * @param {Object} obj
         * @return {Promise}
         * @api private
         */

        function objectToPromise(obj){
          var results = new obj.constructor();
          var keys = Object.keys(obj);
          var promises = [];
          for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var promise = toPromise.call(this, obj[key]);
            if (promise && isPromise(promise)) defer(promise, key);
            else results[key] = obj[key];
          }
          return Promise.all(promises).then(function () {
            return results;
          });

          function defer(promise, key) {
            // predefine the key in the result
            results[key] = undefined;
            promises.push(promise.then(function (res) {
              results[key] = res;
            }));
          }
        }

        /**
         * Check if `obj` is a promise.
         *
         * @param {Object} obj
         * @return {Boolean}
         * @api private
         */

        function isPromise(obj) {
          return 'function' == typeof obj.then;
        }

        /**
         * Check if `obj` is a generator.
         *
         * @param {Mixed} obj
         * @return {Boolean}
         * @api private
         */

        function isGenerator(obj) {
          return 'function' == typeof obj.next && 'function' == typeof obj.throw;
        }

        /**
         * Check if `obj` is a generator function.
         *
         * @param {Mixed} obj
         * @return {Boolean}
         * @api private
         */
        function isGeneratorFunction(obj) {
          var constructor = obj.constructor;
          if (!constructor) return false;
          if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
          return isGenerator(constructor.prototype);
        }

        /**
         * Check for plain object.
         *
         * @param {Mixed} val
         * @return {Boolean}
         * @api private
         */

        function isObject(val) {
          return Object == val.constructor;
        }
        });

        var require$$2$1 = (index$3 && typeof index$3 === 'object' && 'default' in index$3 ? index$3['default'] : index$3);

        var stringify$1 = __commonjs(function (module) {
        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
            gap,
            indent,
            meta = {    // table of character substitutions
                '\b': '\\b',
                '\t': '\\t',
                '\n': '\\n',
                '\f': '\\f',
                '\r': '\\r',
                '"' : '\\"',
                '\\': '\\\\'
            },
            rep;

        function quote(string) {
            // If the string contains no control characters, no quote characters, and no
            // backslash characters, then we can safely slap some quotes around it.
            // Otherwise we must also replace the offending characters with safe escape
            // sequences.
            
            escapable.lastIndex = 0;
            return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' : '"' + string + '"';
        }

        function str(key, holder) {
            // Produce a string from holder[key].
            var i,          // The loop counter.
                k,          // The member key.
                v,          // The member value.
                length,
                mind = gap,
                partial,
                value = holder[key];
            
            // If the value has a toJSON method, call it to obtain a replacement value.
            if (value && typeof value === 'object' &&
                    typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
            
            // If we were called with a replacer function, then call the replacer to
            // obtain a replacement value.
            if (typeof rep === 'function') {
                value = rep.call(holder, key, value);
            }
            
            // What happens next depends on the value's type.
            switch (typeof value) {
                case 'string':
                    return quote(value);
                
                case 'number':
                    // JSON numbers must be finite. Encode non-finite numbers as null.
                    return isFinite(value) ? String(value) : 'null';
                
                case 'boolean':
                case 'null':
                    // If the value is a boolean or null, convert it to a string. Note:
                    // typeof null does not produce 'null'. The case is included here in
                    // the remote chance that this gets fixed someday.
                    return String(value);
                    
                case 'object':
                    if (!value) return 'null';
                    gap += indent;
                    partial = [];
                    
                    // Array.isArray
                    if (Object.prototype.toString.apply(value) === '[object Array]') {
                        length = value.length;
                        for (i = 0; i < length; i += 1) {
                            partial[i] = str(i, value) || 'null';
                        }
                        
                        // Join all of the elements together, separated with commas, and
                        // wrap them in brackets.
                        v = partial.length === 0 ? '[]' : gap ?
                            '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                            '[' + partial.join(',') + ']';
                        gap = mind;
                        return v;
                    }
                    
                    // If the replacer is an array, use it to select the members to be
                    // stringified.
                    if (rep && typeof rep === 'object') {
                        length = rep.length;
                        for (i = 0; i < length; i += 1) {
                            k = rep[i];
                            if (typeof k === 'string') {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    }
                    else {
                        // Otherwise, iterate through all of the keys in the object.
                        for (k in value) {
                            if (Object.prototype.hasOwnProperty.call(value, k)) {
                                v = str(k, value);
                                if (v) {
                                    partial.push(quote(k) + (gap ? ': ' : ':') + v);
                                }
                            }
                        }
                    }
                    
                // Join all of the member texts together, separated with commas,
                // and wrap them in braces.

                v = partial.length === 0 ? '{}' : gap ?
                    '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                    '{' + partial.join(',') + '}';
                gap = mind;
                return v;
            }
        }

        module.exports = function (value, replacer, space) {
            var i;
            gap = '';
            indent = '';
            
            // If the space parameter is a number, make an indent string containing that
            // many spaces.
            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }
            }
            // If the space parameter is a string, it will be used as the indent string.
            else if (typeof space === 'string') {
                indent = space;
            }

            // If there is a replacer, it must be a function or an array.
            // Otherwise, throw an error.
            rep = replacer;
            if (replacer && typeof replacer !== 'function'
            && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }
            
            // Make a fake root object containing our value under the key of ''.
            // Return the result of stringifying the value.
            return str('', {'': value});
        };
        });

        var require$$0$7 = (stringify$1 && typeof stringify$1 === 'object' && 'default' in stringify$1 ? stringify$1['default'] : stringify$1);

        var parse$1 = __commonjs(function (module) {
        var at, // The index of the current character
            ch, // The current character
            escapee = {
                '"':  '"',
                '\\': '\\',
                '/':  '/',
                b:    '\b',
                f:    '\f',
                n:    '\n',
                r:    '\r',
                t:    '\t'
            },
            text,

            error = function (m) {
                // Call error when something is wrong.
                throw {
                    name:    'SyntaxError',
                    message: m,
                    at:      at,
                    text:    text
                };
            },
            
            next = function (c) {
                // If a c parameter is provided, verify that it matches the current character.
                if (c && c !== ch) {
                    error("Expected '" + c + "' instead of '" + ch + "'");
                }
                
                // Get the next character. When there are no more characters,
                // return the empty string.
                
                ch = text.charAt(at);
                at += 1;
                return ch;
            },
            
            number = function () {
                // Parse a number value.
                var number,
                    string = '';
                
                if (ch === '-') {
                    string = '-';
                    next('-');
                }
                while (ch >= '0' && ch <= '9') {
                    string += ch;
                    next();
                }
                if (ch === '.') {
                    string += '.';
                    while (next() && ch >= '0' && ch <= '9') {
                        string += ch;
                    }
                }
                if (ch === 'e' || ch === 'E') {
                    string += ch;
                    next();
                    if (ch === '-' || ch === '+') {
                        string += ch;
                        next();
                    }
                    while (ch >= '0' && ch <= '9') {
                        string += ch;
                        next();
                    }
                }
                number = +string;
                if (!isFinite(number)) {
                    error("Bad number");
                } else {
                    return number;
                }
            },
            
            string = function () {
                // Parse a string value.
                var hex,
                    i,
                    string = '',
                    uffff;
                
                // When parsing for string values, we must look for " and \ characters.
                if (ch === '"') {
                    while (next()) {
                        if (ch === '"') {
                            next();
                            return string;
                        } else if (ch === '\\') {
                            next();
                            if (ch === 'u') {
                                uffff = 0;
                                for (i = 0; i < 4; i += 1) {
                                    hex = parseInt(next(), 16);
                                    if (!isFinite(hex)) {
                                        break;
                                    }
                                    uffff = uffff * 16 + hex;
                                }
                                string += String.fromCharCode(uffff);
                            } else if (typeof escapee[ch] === 'string') {
                                string += escapee[ch];
                            } else {
                                break;
                            }
                        } else {
                            string += ch;
                        }
                    }
                }
                error("Bad string");
            },

            white = function () {

        // Skip whitespace.

                while (ch && ch <= ' ') {
                    next();
                }
            },

            word = function () {

        // true, false, or null.

                switch (ch) {
                case 't':
                    next('t');
                    next('r');
                    next('u');
                    next('e');
                    return true;
                case 'f':
                    next('f');
                    next('a');
                    next('l');
                    next('s');
                    next('e');
                    return false;
                case 'n':
                    next('n');
                    next('u');
                    next('l');
                    next('l');
                    return null;
                }
                error("Unexpected '" + ch + "'");
            },

            value,  // Place holder for the value function.

            array = function () {

        // Parse an array value.

                var array = [];

                if (ch === '[') {
                    next('[');
                    white();
                    if (ch === ']') {
                        next(']');
                        return array;   // empty array
                    }
                    while (ch) {
                        array.push(value());
                        white();
                        if (ch === ']') {
                            next(']');
                            return array;
                        }
                        next(',');
                        white();
                    }
                }
                error("Bad array");
            },

            object = function () {

        // Parse an object value.

                var key,
                    object = {};

                if (ch === '{') {
                    next('{');
                    white();
                    if (ch === '}') {
                        next('}');
                        return object;   // empty object
                    }
                    while (ch) {
                        key = string();
                        white();
                        next(':');
                        if (Object.hasOwnProperty.call(object, key)) {
                            error('Duplicate key "' + key + '"');
                        }
                        object[key] = value();
                        white();
                        if (ch === '}') {
                            next('}');
                            return object;
                        }
                        next(',');
                        white();
                    }
                }
                error("Bad object");
            };

        value = function () {

        // Parse a JSON value. It could be an object, an array, a string, a number,
        // or a word.

            white();
            switch (ch) {
            case '{':
                return object();
            case '[':
                return array();
            case '"':
                return string();
            case '-':
                return number();
            default:
                return ch >= '0' && ch <= '9' ? number() : word();
            }
        };

        // Return the json_parse function. It will have access to all of the above
        // functions and variables.

        module.exports = function (source, reviver) {
            var result;
            
            text = source;
            at = 0;
            ch = ' ';
            result = value();
            white();
            if (ch) {
                error("Syntax error");
            }

            // If there is a reviver function, we recursively walk the new structure,
            // passing each name/value pair to the reviver function for possible
            // transformation, starting with a temporary root object that holds the result
            // in an empty key. If there is not a reviver function, we simply return the
            // result.

            return typeof reviver === 'function' ? (function walk(holder, key) {
                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }({'': result}, '')) : result;
        };
        });

        var require$$1$3 = (parse$1 && typeof parse$1 === 'object' && 'default' in parse$1 ? parse$1['default'] : parse$1);

        var index$5 = __commonjs(function (module, exports) {
        exports.parse = require$$1$3;
        exports.stringify = require$$0$7;
        });

        var require$$0$6 = (index$5 && typeof index$5 === 'object' && 'default' in index$5 ? index$5['default'] : index$5);

        var index$4 = __commonjs(function (module) {
        var json = typeof JSON !== 'undefined' ? JSON : require$$0$6;

        module.exports = function (obj, opts) {
            if (!opts) opts = {};
            if (typeof opts === 'function') opts = { cmp: opts };
            var space = opts.space || '';
            if (typeof space === 'number') space = Array(space+1).join(' ');
            var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
            var replacer = opts.replacer || function(key, value) { return value; };

            var cmp = opts.cmp && (function (f) {
                return function (node) {
                    return function (a, b) {
                        var aobj = { key: a, value: node[a] };
                        var bobj = { key: b, value: node[b] };
                        return f(aobj, bobj);
                    };
                };
            })(opts.cmp);

            var seen = [];
            return (function stringify (parent, key, node, level) {
                var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
                var colonSeparator = space ? ': ' : ':';

                if (node && node.toJSON && typeof node.toJSON === 'function') {
                    node = node.toJSON();
                }

                node = replacer.call(parent, key, node);

                if (node === undefined) {
                    return;
                }
                if (typeof node !== 'object' || node === null) {
                    return json.stringify(node);
                }
                if (isArray(node)) {
                    var out = [];
                    for (var i = 0; i < node.length; i++) {
                        var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                        out.push(indent + space + item);
                    }
                    return '[' + out.join(',') + indent + ']';
                }
                else {
                    if (seen.indexOf(node) !== -1) {
                        if (cycles) return json.stringify('__cycle__');
                        throw new TypeError('Converting circular structure to JSON');
                    }
                    else seen.push(node);

                    var keys = objectKeys(node).sort(cmp && cmp(node));
                    var out = [];
                    for (var i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        var value = stringify(node, key, node[key], level+1);

                        if(!value) continue;

                        var keyValue = json.stringify(key)
                            + colonSeparator
                            + value;
                        ;
                        out.push(indent + space + keyValue);
                    }
                    seen.splice(seen.indexOf(node), 1);
                    return '{' + out.join(',') + indent + '}';
                }
            })({ '': obj }, '', obj, 0);
        };

        var isArray = Array.isArray || function (x) {
            return {}.toString.call(x) === '[object Array]';
        };

        var objectKeys = Object.keys || function (obj) {
            var has = Object.prototype.hasOwnProperty || function () { return true };
            var keys = [];
            for (var key in obj) {
                if (has.call(obj, key)) keys.push(key);
            }
            return keys;
        };
        });

        var require$$5 = (index$4 && typeof index$4 === 'object' && 'default' in index$4 ? index$4['default'] : index$4);

        var util$1 = __commonjs(function (module) {
        'use strict';


        module.exports = {
          copy: copy,
          checkDataType: checkDataType,
          checkDataTypes: checkDataTypes,
          coerceToTypes: coerceToTypes,
          toHash: toHash,
          getProperty: getProperty,
          escapeQuotes: escapeQuotes,
          ucs2length: ucs2length,
          varOccurences: varOccurences,
          varReplace: varReplace,
          cleanUpCode: cleanUpCode,
          cleanUpVarErrors: cleanUpVarErrors,
          schemaHasRules: schemaHasRules,
          stableStringify: require$$5,
          toQuotedString: toQuotedString,
          getPathExpr: getPathExpr,
          getPath: getPath,
          getData: getData,
          unescapeFragment: unescapeFragment,
          escapeFragment: escapeFragment,
          escapeJsonPointer: escapeJsonPointer
        };


        function copy(o, to) {
          to = to || {};
          for (var key in o) to[key] = o[key];
          return to;
        }


        function checkDataType(dataType, data, negate) {
          var EQUAL = negate ? ' !== ' : ' === '
            , AND = negate ? ' || ' : ' && '
            , OK = negate ? '!' : ''
            , NOT = negate ? '' : '!';
          switch (dataType) {
            case 'null': return data + EQUAL + 'null';
            case 'array': return OK + 'Array.isArray(' + data + ')';
            case 'object': return '(' + OK + data + AND +
                                  'typeof ' + data + EQUAL + '"object"' + AND +
                                  NOT + 'Array.isArray(' + data + '))';
            case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                                   NOT + '(' + data + ' % 1))';
            default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
          }
        }


        function checkDataTypes(dataTypes, data) {
          switch (dataTypes.length) {
            case 1: return checkDataType(dataTypes[0], data, true);
            default:
              var code = '';
              var types = toHash(dataTypes);
              if (types.array && types.object) {
                code = types.null ? '(': '(!' + data + ' || ';
                code += 'typeof ' + data + ' !== "object")';
                delete types.null;
                delete types.array;
                delete types.object;
              }
              if (types.number) delete types.integer;
              for (var t in types)
                code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

              return code;
          }
        }


        var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
        function coerceToTypes(dataTypes) {
          if (Array.isArray(dataTypes)) {
            var types = [];
            for (var i=0; i<dataTypes.length; i++) {
              var t = dataTypes[i];
              if (COERCE_TO_TYPES[t]) types[types.length] = t;
            }
            if (types.length) return types;
          } else if (COERCE_TO_TYPES[dataTypes]) {
            return [dataTypes];
          }
        }


        function toHash(arr) {
          var hash = {};
          for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
          return hash;
        }


        var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
        var SINGLE_QUOTE = /'|\\/g;
        function getProperty(key) {
          return typeof key == 'number'
                  ? '[' + key + ']'
                  : IDENTIFIER.test(key)
                    ? '.' + key
                    : "['" + key.replace(SINGLE_QUOTE, '\\$&') + "']";
        }


        function escapeQuotes(str) {
          return str.replace(SINGLE_QUOTE, '\\$&');
        }


        // https://mathiasbynens.be/notes/javascript-encoding
        // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
        function ucs2length(str) {
          var length = 0
            , len = str.length
            , pos = 0
            , value;
          while (pos < len) {
            length++;
            value = str.charCodeAt(pos++);
            if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
              // high surrogate, and there is a next character
              value = str.charCodeAt(pos);
              if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
            }
          }
          return length;
        }


        function varOccurences(str, dataVar) {
          dataVar += '[^0-9]';
          var matches = str.match(new RegExp(dataVar, 'g'));
          return matches ? matches.length : 0;
        }


        function varReplace(str, dataVar, expr) {
          dataVar += '([^0-9])';
          expr = expr.replace(/\$/g, '$$$$');
          return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
        }


        var EMPTY_ELSE = /else\s*{\s*}/g
          , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
          , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
        function cleanUpCode(out) {
          return out.replace(EMPTY_ELSE, '')
                    .replace(EMPTY_IF_NO_ELSE, '')
                    .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
        }


        var ERRORS_REGEXP = /[^v\.]errors/g
          , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
          , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
          , RETURN_VALID = 'return errors === 0;'
          , RETURN_TRUE = 'validate.errors = null; return true;'
          , RETURN_ASYNC = /if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/
          , RETURN_TRUE_ASYNC = 'return true;';

        function cleanUpVarErrors(out, async) {
          var matches = out.match(ERRORS_REGEXP);
          if (!matches || matches.length !== 2) return out;
          return async
                  ? out.replace(REMOVE_ERRORS_ASYNC, '')
                       .replace(RETURN_ASYNC, RETURN_TRUE_ASYNC)
                  : out.replace(REMOVE_ERRORS, '')
                       .replace(RETURN_VALID, RETURN_TRUE);
        }


        function schemaHasRules(schema, rules) {
          for (var key in schema) if (rules[key]) return true;
        }


        function toQuotedString(str) {
          return '\'' + escapeQuotes(str) + '\'';
        }


        function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
          var path = jsonPointers // false by default
                      ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
                      : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
          return joinPaths(currentPath, path);
        }


        function getPath(currentPath, prop, jsonPointers) {
          var path = jsonPointers // false by default
                      ? toQuotedString('/' + escapeJsonPointer(prop))
                      : toQuotedString(getProperty(prop));
          return joinPaths(currentPath, path);
        }


        var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
        function getData($data, lvl, paths) {
          var matches = $data.match(RELATIVE_JSON_POINTER);
          if (!matches) throw new Error('Invalid relative JSON-pointer: ' + $data);
          var up = +matches[1];
          var jsonPointer = matches[2];
          if (jsonPointer == '#') {
            if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
            return paths[lvl - up];
          }

          if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
          var data = 'data' + ((lvl - up) || '');
          if (!jsonPointer) return data;

          var expr = data;
          var segments = jsonPointer.split('/');
          for (var i=0; i<segments.length; i++) {
            var segment = segments[i];
            if (segment) {
              data += getProperty(unescapeJsonPointer(segment));
              expr += ' && ' + data;
            }
          }
          return expr;
        }


        function joinPaths (a, b) {
          if (a == '""') return b;
          return (a + ' + ' + b).replace(/' \+ '/g, '');
        }


        function unescapeFragment(str) {
          return unescapeJsonPointer(decodeURIComponent(str));
        }


        function escapeFragment(str) {
          return encodeURIComponent(escapeJsonPointer(str));
        }


        function escapeJsonPointer(str) {
          return str.replace(/~/g, '~0').replace(/\//g, '~1');
        }


        function unescapeJsonPointer(str) {
          return str.replace(/~1/g, '/').replace(/~0/g, '~');
        }
        });

        var require$$6 = (util$1 && typeof util$1 === 'object' && 'default' in util$1 ? util$1['default'] : util$1);

        var async = __commonjs(function (module) {
        'use strict';

        module.exports = {
          setup: setupAsync,
          compile: compileAsync
        };


        var util = require$$6;

        var ASYNC = {
          '*': checkGenerators,
          'co*': checkGenerators,
          'es7': checkAsyncFunction
        };

        var TRANSPILE = {
          'nodent': getNodent,
          'regenerator': getRegenerator
        };

        var MODES = [
          { async: 'co*' },
          { async: 'es7', transpile: 'nodent' },
          { async: 'co*', transpile: 'regenerator' }
        ];


        var regenerator, nodent;


        function setupAsync(opts, required) {
          if (required !== false) required = true;
          var async = opts.async
            , transpile = opts.transpile
            , check;

          switch (typeof transpile) {
            case 'string':
              var get = TRANSPILE[transpile];
              if (!get) throw new Error('bad transpiler: ' + transpile);
              return (opts._transpileFunc = get(opts, required));
            case 'undefined':
            case 'boolean':
              if (typeof async == 'string') {
                check = ASYNC[async];
                if (!check) throw new Error('bad async mode: ' + async);
                return (opts.transpile = check(opts, required));
              }

              for (var i=0; i<MODES.length; i++) {
                var _opts = MODES[i];
                if (setupAsync(_opts, false)) {
                  util.copy(_opts, opts);
                  return opts.transpile;
                }
              }
              /* istanbul ignore next */
              throw new Error('generators, nodent and regenerator are not available');
            case 'function':
              return (opts._transpileFunc = opts.transpile);
            default:
              throw new Error('bad transpiler: ' + transpile);
          }
        }


        function checkGenerators(opts, required) {
          /* jshint evil: true */
          try {
            eval('(function*(){})()');
            return true;
          } catch(e) {
            /* istanbul ignore next */
            if (required) throw new Error('generators not supported');
          }
        }


        function checkAsyncFunction(opts, required) {
          /* jshint evil: true */
          try {
            eval('(async function(){})()');
            /* istanbul ignore next */
            return true;
          } catch(e) {
            if (required) throw new Error('es7 async functions not supported');
          }
        }


        function getRegenerator(opts, required) {
          try {
            if (!regenerator) {
              regenerator = require('' + 'regenerator');
              regenerator.runtime();
            }
            if (!opts.async || opts.async === true)
              opts.async = 'es7';
            return regeneratorTranspile;
          } catch(e) {
            /* istanbul ignore next */
            if (required) throw new Error('regenerator not available');
          }
        }


        function regeneratorTranspile(code) {
          return regenerator.compile(code).code;
        }


        function getNodent(opts, required) {
          /* jshint evil: true */
          try {
            if (!nodent) nodent = require('' + 'nodent')({ log: false, dontInstallRequireHook: true });
            if (opts.async != 'es7') {
              if (opts.async && opts.async !== true) console.warn('nodent transpiles only es7 async functions');
              opts.async = 'es7';
            }
            return nodentTranspile;
          } catch(e) {
            /* istanbul ignore next */
            if (required) throw new Error('nodent not available');
          }
        }


        function nodentTranspile(code) {
          return nodent.compile(code, '', { promises: true, sourcemap: false }).code;
        }


        /**
         * Creates validating function for passed schema with asynchronous loading of missing schemas.
         * `loadSchema` option should be a function that accepts schema uri and node-style callback.
         * @this  Ajv
         * @param {Object}   schema schema object
         * @param {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.
         */
        function compileAsync(schema, callback) {
          /* eslint no-shadow: 0 */
          /* jshint validthis: true */
          var schemaObj;
          var self = this;
          try {
            schemaObj = this._addSchema(schema);
          } catch(e) {
            setTimeout(function() { callback(e); });
            return;
          }
          if (schemaObj.validate) {
            setTimeout(function() { callback(null, schemaObj.validate); });
          } else {
            if (typeof this._opts.loadSchema != 'function')
              throw new Error('options.loadSchema should be a function');
            _compileAsync(schema, callback, true);
          }


          function _compileAsync(schema, callback, firstCall) {
            var validate;
            try { validate = self.compile(schema); }
            catch(e) {
              if (e.missingSchema) loadMissingSchema(e);
              else deferCallback(e);
              return;
            }
            deferCallback(null, validate);

            function loadMissingSchema(e) {
              var ref = e.missingSchema;
              if (self._refs[ref] || self._schemas[ref])
                return callback(new Error('Schema ' + ref + ' is loaded but' + e.missingRef + 'cannot be resolved'));
              var _callbacks = self._loadingSchemas[ref];
              if (_callbacks) {
                if (typeof _callbacks == 'function')
                  self._loadingSchemas[ref] = [_callbacks, schemaLoaded];
                else
                  _callbacks[_callbacks.length] = schemaLoaded;
              } else {
                self._loadingSchemas[ref] = schemaLoaded;
                self._opts.loadSchema(ref, function (err, sch) {
                  var _callbacks = self._loadingSchemas[ref];
                  delete self._loadingSchemas[ref];
                  if (typeof _callbacks == 'function') {
                    _callbacks(err, sch);
                  } else {
                    for (var i=0; i<_callbacks.length; i++)
                      _callbacks[i](err, sch);
                  }
                });
              }

              function schemaLoaded(err, sch) {
                if (err) return callback(err);
                if (!(self._refs[ref] || self._schemas[ref])) {
                  try {
                    self.addSchema(sch, ref);
                  } catch(e) {
                    callback(e);
                    return;
                  }
                }
                _compileAsync(schema, callback);
              }
            }

            function deferCallback(err, validate) {
              if (firstCall) setTimeout(function() { callback(err, validate); });
              else return callback(err, validate);
            }
          }
        }
        });

        var require$$4 = (async && typeof async === 'object' && 'default' in async ? async['default'] : async);

        var id$1 = "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#";
        var $schema$3 = "http://json-schema.org/draft-04/schema#";
        var description$2 = "Core schema meta-schema (v5 proposals)";
        var definitions$1 = {"schemaArray":{"type":"array","minItems":1,"items":{"$ref":"#"}},"positiveInteger":{"type":"integer","minimum":0},"positiveIntegerDefault0":{"allOf":[{"$ref":"#/definitions/positiveInteger"},{"default":0}]},"simpleTypes":{"enum":["array","boolean","integer","null","number","object","string"]},"stringArray":{"type":"array","items":{"type":"string"},"minItems":1,"uniqueItems":true},"$data":{"type":"object","required":["$data"],"properties":{"$data":{"type":"string","format":"relative-json-pointer"}},"additionalProperties":false}};
        var type$1 = "object";
        var properties$1 = {"id":{"type":"string","format":"uri"},"$schema":{"type":"string","format":"uri"},"title":{"type":"string"},"description":{"type":"string"},"default":{},"multipleOf":{"anyOf":[{"type":"number","minimum":0,"exclusiveMinimum":true},{"$ref":"#/definitions/$data"}]},"maximum":{"anyOf":[{"type":"number"},{"$ref":"#/definitions/$data"}]},"exclusiveMaximum":{"anyOf":[{"type":"boolean","default":false},{"$ref":"#/definitions/$data"}]},"minimum":{"anyOf":[{"type":"number"},{"$ref":"#/definitions/$data"}]},"exclusiveMinimum":{"anyOf":[{"type":"boolean","default":false},{"$ref":"#/definitions/$data"}]},"maxLength":{"anyOf":[{"$ref":"#/definitions/positiveInteger"},{"$ref":"#/definitions/$data"}]},"minLength":{"anyOf":[{"$ref":"#/definitions/positiveIntegerDefault0"},{"$ref":"#/definitions/$data"}]},"pattern":{"anyOf":[{"type":"string","format":"regex"},{"$ref":"#/definitions/$data"}]},"additionalItems":{"anyOf":[{"type":"boolean"},{"$ref":"#"},{"$ref":"#/definitions/$data"}],"default":{}},"items":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/schemaArray"}],"default":{}},"maxItems":{"anyOf":[{"$ref":"#/definitions/positiveInteger"},{"$ref":"#/definitions/$data"}]},"minItems":{"anyOf":[{"$ref":"#/definitions/positiveIntegerDefault0"},{"$ref":"#/definitions/$data"}]},"uniqueItems":{"anyOf":[{"type":"boolean","default":false},{"$ref":"#/definitions/$data"}]},"maxProperties":{"anyOf":[{"$ref":"#/definitions/positiveInteger"},{"$ref":"#/definitions/$data"}]},"minProperties":{"anyOf":[{"$ref":"#/definitions/positiveIntegerDefault0"},{"$ref":"#/definitions/$data"}]},"required":{"anyOf":[{"$ref":"#/definitions/stringArray"},{"$ref":"#/definitions/$data"}]},"additionalProperties":{"anyOf":[{"type":"boolean"},{"$ref":"#"},{"$ref":"#/definitions/$data"}],"default":{}},"definitions":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"properties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"patternProperties":{"type":"object","additionalProperties":{"$ref":"#"},"default":{}},"dependencies":{"type":"object","additionalProperties":{"anyOf":[{"$ref":"#"},{"$ref":"#/definitions/stringArray"}]}},"enum":{"anyOf":[{"type":"array","minItems":1,"uniqueItems":true},{"$ref":"#/definitions/$data"}]},"type":{"anyOf":[{"$ref":"#/definitions/simpleTypes"},{"type":"array","items":{"$ref":"#/definitions/simpleTypes"},"minItems":1,"uniqueItems":true}]},"allOf":{"$ref":"#/definitions/schemaArray"},"anyOf":{"$ref":"#/definitions/schemaArray"},"oneOf":{"$ref":"#/definitions/schemaArray"},"not":{"$ref":"#"},"format":{"anyOf":[{"type":"string"},{"$ref":"#/definitions/$data"}]},"formatMaximum":{"anyOf":[{"type":"string"},{"$ref":"#/definitions/$data"}]},"formatMinimum":{"anyOf":[{"type":"string"},{"$ref":"#/definitions/$data"}]},"exclusiveFormatMaximum":{"anyOf":[{"type":"boolean","default":false},{"$ref":"#/definitions/$data"}]},"exclusiveFormatMinimum":{"anyOf":[{"type":"boolean","default":false},{"$ref":"#/definitions/$data"}]},"constant":{"anyOf":[{},{"$ref":"#/definitions/$data"}]},"contains":{"$ref":"#"},"patternGroups":{"type":"object","additionalProperties":{"type":"object","required":["schema"],"properties":{"maximum":{"anyOf":[{"$ref":"#/definitions/positiveInteger"},{"$ref":"#/definitions/$data"}]},"minimum":{"anyOf":[{"$ref":"#/definitions/positiveIntegerDefault0"},{"$ref":"#/definitions/$data"}]},"schema":{"$ref":"#"}},"additionalProperties":false},"default":{}},"switch":{"type":"array","items":{"required":["then"],"properties":{"if":{"$ref":"#"},"then":{"anyOf":[{"type":"boolean"},{"$ref":"#"}]},"continue":{"type":"boolean"}},"additionalProperties":false,"dependencies":{"continue":["if"]}}}};
        var dependencies$1 = {"exclusiveMaximum":["maximum"],"exclusiveMinimum":["minimum"],"formatMaximum":["format"],"formatMinimum":["format"],"exclusiveFormatMaximum":["formatMaximum"],"exclusiveFormatMinimum":["formatMinimum"]};
        var require$$0$8 = {
        	id: id$1,
        	$schema: $schema$3,
        	description: description$2,
        	definitions: definitions$1,
        	type: type$1,
        	properties: properties$1,
        	dependencies: dependencies$1,
        	"default": {}
        };

        var patternRequired = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_patternRequired(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $key = 'key' + $lvl,
            $matched = 'patternMatched' + $lvl,
            $closingBraces = '';
          out += 'var ' + ($valid) + ' = true;';
          var arr1 = $schema;
          if (arr1) {
            var $pProperty, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $pProperty = arr1[i1 += 1];
              out += ' var ' + ($matched) + ' = false; for (var ' + ($key) + ' in ' + ($data) + ') { ' + ($matched) + ' = ' + (it.usePattern($pProperty)) + '.test(' + ($key) + '); if (' + ($matched) + ') break; } ';
              var $missingPattern = it.util.escapeQuotes($pProperty);
              out += ' if (!' + ($matched) + ') { ' + ($valid) + ' = false;  var err =   '; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'patternRequired') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingPattern: \'' + ($missingPattern) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should have property matching pattern \\\'' + ($missingPattern) + '\\\'\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ';
              if ($breakOnError) {
                $closingBraces += '}';
                out += ' else { ';
              }
            }
          }
          out += '' + ($closingBraces);
          return out;
        }
        });

        var require$$1$4 = (patternRequired && typeof patternRequired === 'object' && 'default' in patternRequired ? patternRequired['default'] : patternRequired);

        var _formatLimit = __commonjs(function (module) {
        'use strict';
        module.exports = function generate__formatLimit(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          out += 'var ' + ($valid) + ' = undefined;';
          if (it.opts.format === false) {
            out += ' ' + ($valid) + ' = true; ';
            return out;
          }
          var $schemaFormat = it.schema.format,
            $isDataFormat = it.opts.v5 && $schemaFormat.$data,
            $closingBraces = '';
          if ($isDataFormat) {
            var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr),
              $format = 'format' + $lvl,
              $compare = 'compare' + $lvl;
            out += ' var ' + ($format) + ' = formats[' + ($schemaValueFormat) + '] , ' + ($compare) + ' = ' + ($format) + ' && ' + ($format) + '.compare;';
          } else {
            var $format = it.formats[$schemaFormat];
            if (!($format && $format.compare)) {
              out += '  ' + ($valid) + ' = true; ';
              return out;
            }
            var $compare = 'formats' + it.util.getProperty($schemaFormat) + '.compare';
          }
          var $isMax = $keyword == 'formatMaximum',
            $exclusiveKeyword = 'exclusiveFormat' + ($isMax ? 'Maximum' : 'Minimum'),
            $schemaExcl = it.schema[$exclusiveKeyword],
            $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
            $op = $isMax ? '<' : '>',
            $result = 'result' + $lvl;
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          if ($isDataExcl) {
            var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
              $exclusive = 'exclusive' + $lvl,
              $opExpr = 'op' + $lvl,
              $opStr = '\' + ' + $opExpr + ' + \'';
            out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
            $schemaValueExcl = 'schemaExcl' + $lvl;
            out += ' if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && ' + ($schemaValueExcl) + ' !== undefined) { ' + ($valid) + ' = false; ';
            var $errorKeyword = $exclusiveKeyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || '_exclusiveFormatLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
              if (it.opts.messages !== false) {
                out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' }  ';
            if ($breakOnError) {
              $closingBraces += '}';
              out += ' else { ';
            }
            if ($isData) {
              out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
              $closingBraces += '}';
            }
            if ($isDataFormat) {
              out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
              $closingBraces += '}';
            }
            out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
            if ($isData) {
              out += '' + ($schemaValue);
            } else {
              out += '' + (it.util.toQuotedString($schema));
            }
            out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; var exclusive' + ($lvl) + ' = ' + ($schemaValueExcl) + ' === true; if (' + ($valid) + ' === undefined) { ' + ($valid) + ' = exclusive' + ($lvl) + ' ? ' + ($result) + ' ' + ($op) + ' 0 : ' + ($result) + ' ' + ($op) + '= 0; } if (!' + ($valid) + ') var op' + ($lvl) + ' = exclusive' + ($lvl) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
          } else {
            var $exclusive = $schemaExcl === true,
              $opStr = $op;
            if (!$exclusive) $opStr += '=';
            var $opExpr = '\'' + $opStr + '\'';
            if ($isData) {
              out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
              $closingBraces += '}';
            }
            if ($isDataFormat) {
              out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
              $closingBraces += '}';
            }
            out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
            if ($isData) {
              out += '' + ($schemaValue);
            } else {
              out += '' + (it.util.toQuotedString($schema));
            }
            out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; if (' + ($valid) + ' === undefined) ' + ($valid) + ' = ' + ($result) + ' ' + ($op);
            if (!$exclusive) {
              out += '=';
            }
            out += ' 0;';
          }
          out += '' + ($closingBraces) + 'if (!' + ($valid) + ') { ';
          var $errorKeyword = $keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_formatLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { limit:  ';
            if ($isData) {
              out += '' + ($schemaValue);
            } else {
              out += '' + (it.util.toQuotedString($schema));
            }
            out += '  } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should be ' + ($opStr) + ' "';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + (it.util.escapeQuotes($schema));
              }
              out += '"\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + (it.util.toQuotedString($schema));
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '}';
          return out;
        }
        });

        var require$$2$2 = (_formatLimit && typeof _formatLimit === 'object' && 'default' in _formatLimit ? _formatLimit['default'] : _formatLimit);

        var constant = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_constant(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          if (!$isData) {
            out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
          }
          out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'constant') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should be equal to constant\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' }';
          return out;
        }
        });

        var require$$3 = (constant && typeof constant === 'object' && 'default' in constant ? constant['default'] : constant);

        var _switch = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_switch(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var $ifPassed = 'ifPassed' + it.level,
            $shouldContinue;
          out += 'var ' + ($ifPassed) + ';';
          var arr1 = $schema;
          if (arr1) {
            var $sch, $caseIndex = -1,
              l1 = arr1.length - 1;
            while ($caseIndex < l1) {
              $sch = arr1[$caseIndex += 1];
              if ($caseIndex && !$shouldContinue) {
                out += ' if (!' + ($ifPassed) + ') { ';
                $closingBraces += '}';
              }
              if ($sch.if && it.util.schemaHasRules($sch.if, it.RULES.all)) {
                out += ' var ' + ($errs) + ' = errors;   ';
                var $wasComposite = it.compositeRule;
                it.compositeRule = $it.compositeRule = true;
                $it.createErrors = false;
                $it.schema = $sch.if;
                $it.schemaPath = $schemaPath + '[' + $caseIndex + '].if';
                $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/if';
                out += ' ' + (it.validate($it)) + ' ';
                $it.createErrors = true;
                it.compositeRule = $it.compositeRule = $wasComposite;
                out += ' ' + ($ifPassed) + ' = valid' + ($it.level) + '; if (' + ($ifPassed) + ') {  ';
                if (typeof $sch.then == 'boolean') {
                  if ($sch.then === false) {
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                      out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { caseIndex: ' + ($caseIndex) + ' } ';
                      if (it.opts.messages !== false) {
                        out += ' , message: \'should pass "switch" keyword validation\' ';
                      }
                      if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                      }
                      out += ' } ';
                    } else {
                      out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                      if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                      } else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                      }
                    } else {
                      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                  }
                  out += ' var valid' + ($it.level) + ' = ' + ($sch.then) + '; ';
                } else {
                  $it.schema = $sch.then;
                  $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
                  $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
                  out += ' ' + (it.validate($it)) + ' ';
                }
                out += '  } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } } ';
              } else {
                out += ' ' + ($ifPassed) + ' = true;  ';
                if (typeof $sch.then == 'boolean') {
                  if ($sch.then === false) {
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                      out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { caseIndex: ' + ($caseIndex) + ' } ';
                      if (it.opts.messages !== false) {
                        out += ' , message: \'should pass "switch" keyword validation\' ';
                      }
                      if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                      }
                      out += ' } ';
                    } else {
                      out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                      if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                      } else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                      }
                    } else {
                      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                  }
                  out += ' var valid' + ($it.level) + ' = ' + ($sch.then) + '; ';
                } else {
                  $it.schema = $sch.then;
                  $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
                  $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
                  out += ' ' + (it.validate($it)) + ' ';
                }
              }
              $shouldContinue = $sch.continue
            }
          }
          out += '' + ($closingBraces) + 'var ' + ($valid) + ' = valid' + ($it.level) + '; ';
          out = it.util.cleanUpCode(out);
          return out;
        }
        });

        var require$$4$1 = (_switch && typeof _switch === 'object' && 'default' in _switch ? _switch['default'] : _switch);

        var v5 = __commonjs(function (module) {
        'use strict';

        var META_SCHEMA_ID = 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json';

        module.exports = {
          enable: enableV5,
          META_SCHEMA_ID: META_SCHEMA_ID
        };


        function enableV5(ajv) {
          var inlineFunctions = {
            'switch': require$$4$1,
            'constant': require$$3,
            '_formatLimit': require$$2$2,
            'patternRequired': require$$1$4
          };

          if (ajv._opts.meta !== false) {
            var metaSchema = require$$0$8;
            ajv.addMetaSchema(metaSchema, META_SCHEMA_ID);
          }
          _addKeyword('constant');
          ajv.addKeyword('contains', { type: 'array', macro: containsMacro });

          _addKeyword('formatMaximum', 'string', inlineFunctions._formatLimit);
          _addKeyword('formatMinimum', 'string', inlineFunctions._formatLimit);
          ajv.addKeyword('exclusiveFormatMaximum');
          ajv.addKeyword('exclusiveFormatMinimum');

          ajv.addKeyword('patternGroups'); // implemented in properties.jst
          _addKeyword('patternRequired', 'object');
          _addKeyword('switch');


          function _addKeyword(keyword, types, inlineFunc) {
            var definition = {
              inline: inlineFunc || inlineFunctions[keyword],
              statements: true,
              errors: 'full'
            };
            if (types) definition.type = types;
            ajv.addKeyword(keyword, definition);
          }
        }


        function containsMacro(schema) {
          return {
            not: { items: { not: schema } }
          };
        }
        });

        var require$$6$1 = (v5 && typeof v5 === 'object' && 'default' in v5 ? v5['default'] : v5);

        var validate$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_validate(it, $keyword) {
          var out = '';
          var $async = it.schema.$async === true;
          if (it.isTop) {
            var $top = it.isTop,
              $lvl = it.level = 0,
              $dataLvl = it.dataLevel = 0,
              $data = 'data';
            it.rootId = it.resolve.fullPath(it.root.schema.id);
            it.baseId = it.baseId || it.rootId;
            if ($async) {
              it.async = true;
              var $es7 = it.opts.async == 'es7';
              it.yieldAwait = $es7 ? 'await' : 'yield';
            }
            delete it.isTop;
            it.dataPathArr = [undefined];
            out += ' validate = ';
            if ($async) {
              if ($es7) {
                out += ' (async function ';
              } else {
                if (it.opts.async == 'co*') {
                  out += 'co.wrap';
                }
                out += '(function* ';
              }
            } else {
              out += ' (function ';
            }
            out += ' (data, dataPath, parentData, parentDataProperty) { \'use strict\'; var vErrors = null; ';
            out += ' var errors = 0;     ';
          } else {
            var $lvl = it.level,
              $dataLvl = it.dataLevel,
              $data = 'data' + ($dataLvl || '');
            if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);
            if ($async && !it.async) throw new Error('async schema in sync schema');
            out += ' var errs_' + ($lvl) + ' = errors;';
          }
          var $valid = 'valid' + $lvl,
            $breakOnError = !it.opts.allErrors,
            $closingBraces1 = '',
            $closingBraces2 = '',
            $errorKeyword;
          var $typeSchema = it.schema.type,
            $typeIsArray = Array.isArray($typeSchema);
          if ($typeSchema && it.opts.coerceTypes) {
            var $coerceToTypes = it.util.coerceToTypes($typeSchema);
            if ($coerceToTypes) {
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type',
                $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
              out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';
              var $dataType = 'dataType' + $lvl,
                $coerced = 'coerced' + $lvl;
              out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
              var $bracesCoercion = '';
              var arr1 = $coerceToTypes;
              if (arr1) {
                var $type, $i = -1,
                  l1 = arr1.length - 1;
                while ($i < l1) {
                  $type = arr1[$i += 1];
                  if ($i) {
                    out += ' if (' + ($coerced) + ' === undefined) { ';
                    $bracesCoercion += '}';
                  }
                  if ($type == 'string') {
                    out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
                  } else if ($type == 'number' || $type == 'integer') {
                    out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
                    if ($type == 'integer') {
                      out += ' && !(' + ($data) + ' % 1)';
                    }
                    out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
                  } else if ($type == 'boolean') {
                    out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
                  } else if ($type == 'null') {
                    out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
                  }
                }
              }
              out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } else { ';
              if ($dataLvl) {
                var $parentData = 'data' + (($dataLvl - 1) || ''),
                  $dataProperty = it.dataPathArr[$dataLvl];
                out += ' ' + ($data) + ' = ' + ($parentData) + '[' + ($dataProperty) + '] = ' + ($coerced) + '; ';
              } else {
                out += ' data = ' + ($coerced) + '; if (parentData !== undefined) parentData[parentDataProperty] = ' + ($coerced) + '; ';
              }
              out += ' } } ';
            }
          }
          var arr2 = it.RULES;
          if (arr2) {
            var $rulesGroup, i2 = -1,
              l2 = arr2.length - 1;
            while (i2 < l2) {
              $rulesGroup = arr2[i2 += 1];
              if ($shouldUseGroup($rulesGroup)) {
                if ($rulesGroup.type) {
                  out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
                }
                if (it.opts.useDefaults && !it.compositeRule) {
                  if ($rulesGroup.type == 'object' && it.schema.properties) {
                    var $schema = it.schema.properties,
                      $schemaKeys = Object.keys($schema);
                    var arr3 = $schemaKeys;
                    if (arr3) {
                      var $propertyKey, i3 = -1,
                        l3 = arr3.length - 1;
                      while (i3 < l3) {
                        $propertyKey = arr3[i3 += 1];
                        var $sch = $schema[$propertyKey];
                        if ($sch.default !== undefined) {
                          var $passData = $data + it.util.getProperty($propertyKey);
                          out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                          if (it.opts.useDefaults == 'clone') {
                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                          } else {
                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                          }
                          out += '; ';
                        }
                      }
                    }
                  } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
                    var arr4 = it.schema.items;
                    if (arr4) {
                      var $sch, $i = -1,
                        l4 = arr4.length - 1;
                      while ($i < l4) {
                        $sch = arr4[$i += 1];
                        if ($sch.default !== undefined) {
                          var $passData = $data + '[' + $i + ']';
                          out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                          if (it.opts.useDefaults == 'clone') {
                            out += ' ' + (JSON.stringify($sch.default)) + ' ';
                          } else {
                            out += ' ' + (it.useDefault($sch.default)) + ' ';
                          }
                          out += '; ';
                        }
                      }
                    }
                  }
                }
                var arr5 = $rulesGroup.rules;
                if (arr5) {
                  var $rule, i5 = -1,
                    l5 = arr5.length - 1;
                  while (i5 < l5) {
                    $rule = arr5[i5 += 1];
                    if ($shouldUseRule($rule)) {
                      if ($rule.custom) {
                        var $schema = it.schema[$rule.keyword],
                          $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it),
                          $ruleErrs = $ruleValidate.code + '.errors',
                          $schemaPath = it.schemaPath + '.' + $rule.keyword,
                          $errSchemaPath = it.errSchemaPath + '/' + $rule.keyword,
                          $errs = 'errs' + $lvl,
                          $i = 'i' + $lvl,
                          $ruleErr = 'ruleErr' + $lvl,
                          $rDef = $rule.definition,
                          $asyncKeyword = $rDef.async,
                          $inline = $rDef.inline,
                          $macro = $rDef.macro;
                        if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
                        if (!($inline || $macro)) {
                          out += '' + ($ruleErrs) + ' = null;';
                        }
                        out += 'var ' + ($errs) + ' = errors;var valid' + ($lvl) + ';';
                        if ($inline && $rDef.statements) {
                          out += ' ' + ($ruleValidate.validate);
                        } else if ($macro) {
                          var $it = it.util.copy(it);
                          $it.level++;
                          $it.schema = $ruleValidate.validate;
                          $it.schemaPath = '';
                          var $wasComposite = it.compositeRule;
                          it.compositeRule = $it.compositeRule = true;
                          var $code = it.validate($it).replace(/validate\.schema/g, $ruleValidate.code);
                          it.compositeRule = $it.compositeRule = $wasComposite;
                          out += ' ' + ($code);
                        } else if ($rDef.compile || $rDef.validate) {
                          var $$outStack = $$outStack || [];
                          $$outStack.push(out);
                          out = '';
                          out += '  ' + ($ruleValidate.code) + '.call( ';
                          if (it.opts.passContext) {
                            out += 'this';
                          } else {
                            out += 'self';
                          }
                          var $validateArgs = $ruleValidate.validate.length;
                          if ($rDef.compile || $rDef.schema === false) {
                            out += ' , ' + ($data) + ' ';
                          } else {
                            out += ' , validate.schema' + ($schemaPath) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
                          }
                          out += ' , (dataPath || \'\')';
                          if (it.errorPath != '""') {
                            out += ' + ' + (it.errorPath);
                          }
                          if ($dataLvl) {
                            out += ' , data' + (($dataLvl - 1) || '') + ' , ' + (it.dataPathArr[$dataLvl]) + ' ';
                          } else {
                            out += ' , parentData , parentDataProperty ';
                          }
                          out += ' )  ';
                          var def_callRuleValidate = out;
                          out = $$outStack.pop();
                          if ($rDef.errors !== false) {
                            if ($asyncKeyword) {
                              $ruleErrs = 'customErrors' + $lvl;
                              out += ' var ' + ($ruleErrs) + ' = null; try { valid' + ($lvl) + ' = ' + (it.yieldAwait) + (def_callRuleValidate) + '; } catch (e) { valid' + ($lvl) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
                            } else {
                              out += ' ' + ($ruleValidate.code) + '.errors = null; ';
                            }
                          }
                        }
                        out += 'if (! ';
                        if ($inline) {
                          if ($rDef.statements) {
                            out += ' valid' + ($lvl) + ' ';
                          } else {
                            out += ' (' + ($ruleValidate.validate) + ') ';
                          }
                        } else if ($macro) {
                          out += ' valid' + ($it.level) + ' ';
                        } else {
                          if ($asyncKeyword) {
                            if ($rDef.errors === false) {
                              out += ' (' + (it.yieldAwait) + (def_callRuleValidate) + ') ';
                            } else {
                              out += ' valid' + ($lvl) + ' ';
                            }
                          } else {
                            out += ' ' + (def_callRuleValidate) + ' ';
                          }
                        }
                        out += ') { ';
                        $errorKeyword = $rule.keyword;
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = '';
                        var $$outStack = $$outStack || [];
                        $$outStack.push(out);
                        out = ''; /* istanbul ignore else */
                        if (it.createErrors !== false) {
                          out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { keyword: \'' + ($rule.keyword) + '\' } ';
                          if (it.opts.messages !== false) {
                            out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
                          }
                          if (it.opts.verbose) {
                            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                          }
                          out += ' } ';
                        } else {
                          out += ' {} ';
                        }
                        var __err = out;
                        out = $$outStack.pop();
                        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                          if (it.async) {
                            out += ' throw new ValidationError([' + (__err) + ']); ';
                          } else {
                            out += ' validate.errors = [' + (__err) + ']; return false; ';
                          }
                        } else {
                          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                        }
                        var def_customError = out;
                        out = $$outStack.pop();
                        if ($inline) {
                          if ($rDef.errors) {
                            if ($rDef.errors != 'full') {
                              out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) { ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; } if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
                              if (it.opts.verbose) {
                                out += ' ' + ($ruleErr) + '.schema = validate.schema' + ($schemaPath) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                              }
                              out += ' } ';
                            }
                          } else {
                            if ($rDef.errors === false) {
                              out += ' ' + (def_customError) + ' ';
                            } else {
                              out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) { ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; } if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
                              if (it.opts.verbose) {
                                out += ' ' + ($ruleErr) + '.schema = validate.schema' + ($schemaPath) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                              }
                              out += ' } } ';
                            }
                          }
                        } else if ($macro) {
                          out += '   var err =   '; /* istanbul ignore else */
                          if (it.createErrors !== false) {
                            out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { keyword: \'' + ($rule.keyword) + '\' } ';
                            if (it.opts.messages !== false) {
                              out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
                            }
                            if (it.opts.verbose) {
                              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                            }
                            out += ' } ';
                          } else {
                            out += ' {} ';
                          }
                          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                            if (it.async) {
                              out += ' throw new ValidationError(vErrors); ';
                            } else {
                              out += ' validate.errors = vErrors; return false ';
                            }
                          }
                        } else {
                          if ($rDef.errors === false) {
                            out += ' ' + (def_customError) + ' ';
                          } else {
                            out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + '];  ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';   ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
                            if (it.opts.verbose) {
                              out += ' ' + ($ruleErr) + '.schema = validate.schema' + ($schemaPath) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
                            }
                            out += ' } } else { ' + (def_customError) + ' } ';
                          }
                        }
                        $errorKeyword = undefined;
                        out += ' } ';
                        if ($breakOnError) {
                          out += ' else { ';
                        }
                      } else {
                        out += ' ' + ($rule.code(it, $rule.keyword)) + ' ';
                      }
                      if ($breakOnError) {
                        $closingBraces1 += '}';
                      }
                    }
                  }
                }
                if ($breakOnError) {
                  out += ' ' + ($closingBraces1) + ' ';
                  $closingBraces1 = '';
                }
                if ($rulesGroup.type) {
                  out += ' } ';
                  if ($typeSchema && $typeSchema === $rulesGroup.type) {
                    var $typeChecked = true;
                    out += ' else { ';
                    var $schemaPath = it.schemaPath + '.type',
                      $errSchemaPath = it.errSchemaPath + '/type';
                    var $$outStack = $$outStack || [];
                    $$outStack.push(out);
                    out = ''; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                      out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { type: \'';
                      if ($typeIsArray) {
                        out += '' + ($typeSchema.join(","));
                      } else {
                        out += '' + ($typeSchema);
                      }
                      out += '\' } ';
                      if (it.opts.messages !== false) {
                        out += ' , message: \'should be ';
                        if ($typeIsArray) {
                          out += '' + ($typeSchema.join(","));
                        } else {
                          out += '' + ($typeSchema);
                        }
                        out += '\' ';
                      }
                      if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                      }
                      out += ' } ';
                    } else {
                      out += ' {} ';
                    }
                    var __err = out;
                    out = $$outStack.pop();
                    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                      if (it.async) {
                        out += ' throw new ValidationError([' + (__err) + ']); ';
                      } else {
                        out += ' validate.errors = [' + (__err) + ']; return false; ';
                      }
                    } else {
                      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                    }
                    out += ' } ';
                  }
                }
                if ($breakOnError) {
                  out += ' if (errors === ';
                  if ($top) {
                    out += '0';
                  } else {
                    out += 'errs_' + ($lvl);
                  }
                  out += ') { ';
                  $closingBraces2 += '}';
                }
              }
            }
          }
          if ($typeSchema && !$typeChecked && !(it.opts.coerceTypes && $coerceToTypes)) {
            var $schemaPath = it.schemaPath + '.type',
              $errSchemaPath = it.errSchemaPath + '/type',
              $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
            out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { type: \'';
              if ($typeIsArray) {
                out += '' + ($typeSchema.join(","));
              } else {
                out += '' + ($typeSchema);
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' }';
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces2) + ' ';
          }
          if ($top) {
            if ($async) {
              out += ' if (errors === 0) return true;           ';
              out += ' else throw new ValidationError(vErrors); ';
            } else {
              out += ' validate.errors = vErrors; ';
              out += ' return errors === 0;       ';
            }
            out += ' });';
          } else {
            out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
          }
          out = it.util.cleanUpCode(out);
          if ($top && $breakOnError) {
            out = it.util.cleanUpVarErrors(out, $async);
          }

          function $shouldUseGroup($rulesGroup) {
            for (var i = 0; i < $rulesGroup.rules.length; i++)
              if ($shouldUseRule($rulesGroup.rules[i])) return true;
          }

          function $shouldUseRule($rule) {
            return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length) || (it.opts.v5 && it.schema.patternGroups && Object.keys(it.schema.patternGroups).length)));
          }
          return out;
        }
        });

        var require$$3$1 = (validate$1 && typeof validate$1 === 'object' && 'default' in validate$1 ? validate$1['default'] : validate$1);

        var uniqueItems$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_uniqueItems(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          if (($schema || $isData) && it.opts.uniqueItems !== false) {
            if ($isData) {
              out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
            }
            out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } ';
            if ($isData) {
              out += '  }  ';
            }
            out += ' if (!' + ($valid) + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { i: i, j: j } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema:  ';
                if ($isData) {
                  out += 'validate.schema' + ($schemaPath);
                } else {
                  out += '' + ($schema);
                }
                out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } ';
            if ($breakOnError) {
              out += ' else { ';
            }
          } else {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
          }
          return out;
        }
        });

        var require$$1$6 = (uniqueItems$1 && typeof uniqueItems$1 === 'object' && 'default' in uniqueItems$1 ? uniqueItems$1['default'] : uniqueItems$1);

        var required$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_required(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          if (!$isData) {
            if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
              var $required = [];
              var arr1 = $schema;
              if (arr1) {
                var $property, i1 = -1,
                  l1 = arr1.length - 1;
                while (i1 < l1) {
                  $property = arr1[i1 += 1];
                  var $propertySch = it.schema.properties[$property];
                  if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
                    $required[$required.length] = $property;
                  }
                }
              }
            } else {
              var $required = $schema;
            }
          }
          if ($isData || $required.length) {
            var $currentErrorPath = it.errorPath,
              $loopRequired = $isData || $required.length >= it.opts.loopRequired;
            if ($breakOnError) {
              out += ' var missing' + ($lvl) + '; ';
              if ($loopRequired) {
                if (!$isData) {
                  out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';
                }
                var $i = 'i' + $lvl,
                  $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                  $missingProperty = '\' + ' + $propertyPath + ' + \'';
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                }
                out += ' var ' + ($valid) + ' = true; ';
                if ($isData) {
                  out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
                }
                out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; } ';
                if ($isData) {
                  out += '  }  ';
                }
                out += '  if (!' + ($valid) + ') {   ';
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                  if (it.async) {
                    out += ' throw new ValidationError([' + (__err) + ']); ';
                  } else {
                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                  }
                } else {
                  out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } else { ';
              } else {
                out += ' if ( ';
                var arr2 = $required;
                if (arr2) {
                  var _$property, $i = -1,
                    l2 = arr2.length - 1;
                  while ($i < l2) {
                    _$property = arr2[$i += 1];
                    if ($i) {
                      out += ' || ';
                    }
                    var $prop = it.util.getProperty(_$property);
                    out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
                  }
                }
                out += ') {  ';
                var $propertyPath = 'missing' + $lvl,
                  $missingProperty = '\' + ' + $propertyPath + ' + \'';
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
                }
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                  if (it.async) {
                    out += ' throw new ValidationError([' + (__err) + ']); ';
                  } else {
                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                  }
                } else {
                  out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                out += ' } else { ';
              }
            } else {
              if ($loopRequired) {
                if (!$isData) {
                  out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + '; ';
                }
                var $i = 'i' + $lvl,
                  $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                  $missingProperty = '\' + ' + $propertyPath + ' + \'';
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
                }
                if ($isData) {
                  out += ' if (schema' + ($lvl) + ' && !Array.isArray(schema' + ($lvl) + ')) {  var err =   '; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'';
                      if (it.opts._errorDataPathProperty) {
                        out += 'is a required property';
                      } else {
                        out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (schema' + ($lvl) + ' !== undefined) { ';
                }
                out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < schema' + ($lvl) + '.length; ' + ($i) + '++) { if (' + ($data) + '[schema' + ($lvl) + '[' + ($i) + ']] === undefined) {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
                if ($isData) {
                  out += '  }  ';
                }
              } else {
                var arr3 = $required;
                if (arr3) {
                  var $property, $i = -1,
                    l3 = arr3.length - 1;
                  while ($i < l3) {
                    $property = arr3[$i += 1];
                    var $prop = it.util.getProperty($property),
                      $missingProperty = it.util.escapeQuotes($property);
                    if (it.opts._errorDataPathProperty) {
                      it.errorPath = it.util.getPath($currentErrorPath, $property, it.opts.jsonPointers);
                    }
                    out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   '; /* istanbul ignore else */
                    if (it.createErrors !== false) {
                      out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                      if (it.opts.messages !== false) {
                        out += ' , message: \'';
                        if (it.opts._errorDataPathProperty) {
                          out += 'is a required property';
                        } else {
                          out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                        }
                        out += '\' ';
                      }
                      if (it.opts.verbose) {
                        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                      }
                      out += ' } ';
                    } else {
                      out += ' {} ';
                    }
                    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
                  }
                }
              }
            }
            it.errorPath = $currentErrorPath;
          } else if ($breakOnError) {
            out += ' if (true) {';
          }
          return out;
        }
        });

        var require$$2$3 = (required$1 && typeof required$1 === 'object' && 'default' in required$1 ? required$1['default'] : required$1);

        var properties$3 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_properties(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var $dataNxt = $it.dataLevel = it.dataLevel + 1,
            $nextData = 'data' + $dataNxt;
          var $schemaKeys = Object.keys($schema || {}),
            $pProperties = it.schema.patternProperties || {},
            $pPropertyKeys = Object.keys($pProperties),
            $aProperties = it.schema.additionalProperties,
            $someProperties = $schemaKeys.length || $pPropertyKeys.length,
            $noAdditional = $aProperties === false,
            $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
            $removeAdditional = it.opts.removeAdditional,
            $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional;
          var $required = it.schema.required;
          if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
          if (it.opts.v5) {
            var $pgProperties = it.schema.patternGroups || {},
              $pgPropertyKeys = Object.keys($pgProperties);
          }
          out += 'var ' + ($errs) + ' = errors;var valid' + ($it.level) + ' = true;';
          if ($checkAdditional) {
            out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { ';
            if ($someProperties) {
              out += ' var isAdditional' + ($lvl) + ' = !(false ';
              if ($schemaKeys.length) {
                if ($schemaKeys.length > 5) {
                  out += ' || validate.schema' + ($schemaPath) + '[key' + ($lvl) + '] ';
                } else {
                  var arr1 = $schemaKeys;
                  if (arr1) {
                    var $propertyKey, i1 = -1,
                      l1 = arr1.length - 1;
                    while (i1 < l1) {
                      $propertyKey = arr1[i1 += 1];
                      out += ' || key' + ($lvl) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
                    }
                  }
                }
              }
              if ($pPropertyKeys.length) {
                var arr2 = $pPropertyKeys;
                if (arr2) {
                  var $pProperty, $i = -1,
                    l2 = arr2.length - 1;
                  while ($i < l2) {
                    $pProperty = arr2[$i += 1];
                    out += ' || ' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ') ';
                  }
                }
              }
              if (it.opts.v5 && $pgPropertyKeys && $pgPropertyKeys.length) {
                var arr3 = $pgPropertyKeys;
                if (arr3) {
                  var $pgProperty, $i = -1,
                    l3 = arr3.length - 1;
                  while ($i < l3) {
                    $pgProperty = arr3[$i += 1];
                    out += ' || ' + (it.usePattern($pgProperty)) + '.test(key' + ($lvl) + ') ';
                  }
                }
              }
              out += ' ); if (isAdditional' + ($lvl) + ') { ';
            }
            if ($removeAdditional == 'all') {
              out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';
            } else {
              var $currentErrorPath = it.errorPath;
              var $additionalProperty = '\' + key' + $lvl + ' + \'';
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);
              }
              if ($noAdditional) {
                if ($removeAdditional) {
                  out += ' delete ' + ($data) + '[key' + ($lvl) + ']; ';
                } else {
                  out += ' valid' + ($it.level) + ' = false; ';
                  var $currErrSchemaPath = $errSchemaPath;
                  $errSchemaPath = it.errSchemaPath + '/additionalProperties';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || 'additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should NOT have additional properties\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + (__err) + ']); ';
                    } else {
                      out += ' validate.errors = [' + (__err) + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  if ($breakOnError) {
                    out += ' break; ';
                  }
                }
              } else if ($additionalIsSchema) {
                if ($removeAdditional == 'failing') {
                  out += ' var ' + ($errs) + ' = errors;  ';
                  var $wasComposite = it.compositeRule;
                  it.compositeRule = $it.compositeRule = true;
                  $it.schema = $aProperties;
                  $it.schemaPath = it.schemaPath + '.additionalProperties';
                  $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
                  $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);
                  var $passData = $data + '[key' + $lvl + ']';
                  $it.dataPathArr[$dataNxt] = 'key' + $lvl;
                  var $code = it.validate($it);
                  if (it.util.varOccurences($code, $nextData) < 2) {
                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                  } else {
                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                  }
                  out += ' if (!valid' + ($it.level) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[key' + ($lvl) + ']; }  ';
                  it.compositeRule = $it.compositeRule = $wasComposite;
                } else {
                  $it.schema = $aProperties;
                  $it.schemaPath = it.schemaPath + '.additionalProperties';
                  $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
                  $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);
                  var $passData = $data + '[key' + $lvl + ']';
                  $it.dataPathArr[$dataNxt] = 'key' + $lvl;
                  var $code = it.validate($it);
                  if (it.util.varOccurences($code, $nextData) < 2) {
                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                  } else {
                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                  }
                  if ($breakOnError) {
                    out += ' if (!valid' + ($it.level) + ') break; ';
                  }
                }
              }
              it.errorPath = $currentErrorPath;
            }
            if ($someProperties) {
              out += ' } ';
            }
            out += ' }  ';
            if ($breakOnError) {
              out += ' if (valid' + ($it.level) + ') { ';
              $closingBraces += '}';
            }
          }
          var $useDefaults = it.opts.useDefaults && !it.compositeRule;
          if ($schemaKeys.length) {
            var arr4 = $schemaKeys;
            if (arr4) {
              var $propertyKey, i4 = -1,
                l4 = arr4.length - 1;
              while (i4 < l4) {
                $propertyKey = arr4[i4 += 1];
                var $sch = $schema[$propertyKey];
                if (it.util.schemaHasRules($sch, it.RULES.all)) {
                  var $prop = it.util.getProperty($propertyKey),
                    $passData = $data + $prop,
                    $hasDefault = $useDefaults && $sch.default !== undefined;
                  $it.schema = $sch;
                  $it.schemaPath = $schemaPath + $prop;
                  $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
                  $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
                  $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
                  var $code = it.validate($it);
                  if (it.util.varOccurences($code, $nextData) < 2) {
                    $code = it.util.varReplace($code, $nextData, $passData);
                    var $useData = $passData;
                  } else {
                    var $useData = $nextData;
                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
                  }
                  if ($hasDefault) {
                    out += ' ' + ($code) + ' ';
                  } else {
                    if ($requiredHash && $requiredHash[$propertyKey]) {
                      out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = false; ';
                      var $currentErrorPath = it.errorPath,
                        $currErrSchemaPath = $errSchemaPath,
                        $missingProperty = it.util.escapeQuotes($propertyKey);
                      if (it.opts._errorDataPathProperty) {
                        it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                      }
                      $errSchemaPath = it.errSchemaPath + '/required';
                      var $$outStack = $$outStack || [];
                      $$outStack.push(out);
                      out = ''; /* istanbul ignore else */
                      if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                        if (it.opts.messages !== false) {
                          out += ' , message: \'';
                          if (it.opts._errorDataPathProperty) {
                            out += 'is a required property';
                          } else {
                            out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                          }
                          out += '\' ';
                        }
                        if (it.opts.verbose) {
                          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                      } else {
                        out += ' {} ';
                      }
                      var __err = out;
                      out = $$outStack.pop();
                      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                        if (it.async) {
                          out += ' throw new ValidationError([' + (__err) + ']); ';
                        } else {
                          out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                      } else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                      }
                      $errSchemaPath = $currErrSchemaPath;
                      it.errorPath = $currentErrorPath;
                      out += ' } else { ';
                    } else {
                      if ($breakOnError) {
                        out += ' if (' + ($useData) + ' === undefined) { valid' + ($it.level) + ' = true; } else { ';
                      } else {
                        out += ' if (' + ($useData) + ' !== undefined) { ';
                      }
                    }
                    out += ' ' + ($code) + ' } ';
                  }
                }
                if ($breakOnError) {
                  out += ' if (valid' + ($it.level) + ') { ';
                  $closingBraces += '}';
                }
              }
            }
          }
          var arr5 = $pPropertyKeys;
          if (arr5) {
            var $pProperty, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $pProperty = arr5[i5 += 1];
              var $sch = $pProperties[$pProperty];
              if (it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
                $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
                out += ' for (var key' + ($lvl) + ' in ' + ($data) + ') { if (' + (it.usePattern($pProperty)) + '.test(key' + ($lvl) + ')) { ';
                $it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);
                var $passData = $data + '[key' + $lvl + ']';
                $it.dataPathArr[$dataNxt] = 'key' + $lvl;
                var $code = it.validate($it);
                if (it.util.varOccurences($code, $nextData) < 2) {
                  out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                } else {
                  out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                }
                if ($breakOnError) {
                  out += ' if (!valid' + ($it.level) + ') break; ';
                }
                out += ' } ';
                if ($breakOnError) {
                  out += ' else valid' + ($it.level) + ' = true; ';
                }
                out += ' }  ';
                if ($breakOnError) {
                  out += ' if (valid' + ($it.level) + ') { ';
                  $closingBraces += '}';
                }
              }
            }
          }
          if (it.opts.v5) {
            var arr6 = $pgPropertyKeys;
            if (arr6) {
              var $pgProperty, i6 = -1,
                l6 = arr6.length - 1;
              while (i6 < l6) {
                $pgProperty = arr6[i6 += 1];
                var $pgSchema = $pgProperties[$pgProperty],
                  $sch = $pgSchema.schema;
                if (it.util.schemaHasRules($sch, it.RULES.all)) {
                  $it.schema = $sch;
                  $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
                  $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
                  out += ' var pgPropCount' + ($lvl) + ' = 0; for (var key' + ($lvl) + ' in ' + ($data) + ') { if (' + (it.usePattern($pgProperty)) + '.test(key' + ($lvl) + ')) { pgPropCount' + ($lvl) + '++; ';
                  $it.errorPath = it.util.getPathExpr(it.errorPath, 'key' + $lvl, it.opts.jsonPointers);
                  var $passData = $data + '[key' + $lvl + ']';
                  $it.dataPathArr[$dataNxt] = 'key' + $lvl;
                  var $code = it.validate($it);
                  if (it.util.varOccurences($code, $nextData) < 2) {
                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                  } else {
                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                  }
                  if ($breakOnError) {
                    out += ' if (!valid' + ($it.level) + ') break; ';
                  }
                  out += ' } ';
                  if ($breakOnError) {
                    out += ' else valid' + ($it.level) + ' = true; ';
                  }
                  out += ' }  ';
                  if ($breakOnError) {
                    out += ' if (valid' + ($it.level) + ') { ';
                    $closingBraces += '}';
                  }
                  var $pgMin = $pgSchema.minimum,
                    $pgMax = $pgSchema.maximum;
                  if ($pgMin !== undefined || $pgMax !== undefined) {
                    out += ' var ' + ($valid) + ' = true; ';
                    var $currErrSchemaPath = $errSchemaPath;
                    if ($pgMin !== undefined) {
                      var $limit = $pgMin,
                        $reason = 'minimum',
                        $moreOrLess = 'less';
                      out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' >= ' + ($pgMin) + '; ';
                      $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
                      out += '  if (!' + ($valid) + ') {   ';
                      var $$outStack = $$outStack || [];
                      $$outStack.push(out);
                      out = ''; /* istanbul ignore else */
                      if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                        if (it.opts.messages !== false) {
                          out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                        }
                        if (it.opts.verbose) {
                          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                      } else {
                        out += ' {} ';
                      }
                      var __err = out;
                      out = $$outStack.pop();
                      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                        if (it.async) {
                          out += ' throw new ValidationError([' + (__err) + ']); ';
                        } else {
                          out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                      } else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                      }
                      out += ' } ';
                      if ($pgMax !== undefined) {
                        out += ' else ';
                      }
                    }
                    if ($pgMax !== undefined) {
                      var $limit = $pgMax,
                        $reason = 'maximum',
                        $moreOrLess = 'more';
                      out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' <= ' + ($pgMax) + '; ';
                      $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
                      out += '  if (!' + ($valid) + ') {   ';
                      var $$outStack = $$outStack || [];
                      $$outStack.push(out);
                      out = ''; /* istanbul ignore else */
                      if (it.createErrors !== false) {
                        out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                        if (it.opts.messages !== false) {
                          out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                        }
                        if (it.opts.verbose) {
                          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                        }
                        out += ' } ';
                      } else {
                        out += ' {} ';
                      }
                      var __err = out;
                      out = $$outStack.pop();
                      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                        if (it.async) {
                          out += ' throw new ValidationError([' + (__err) + ']); ';
                        } else {
                          out += ' validate.errors = [' + (__err) + ']; return false; ';
                        }
                      } else {
                        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                      }
                      out += ' } ';
                    }
                    $errSchemaPath = $currErrSchemaPath;
                    if ($breakOnError) {
                      out += ' if (' + ($valid) + ') { ';
                      $closingBraces += '}';
                    }
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
          }
          out = it.util.cleanUpCode(out);
          return out;
        }
        });

        var require$$3$2 = (properties$3 && typeof properties$3 === 'object' && 'default' in properties$3 ? properties$3['default'] : properties$3);

        var pattern$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_pattern(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
          out += 'if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
          }
          out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { pattern:  ';
            if ($isData) {
              out += '' + ($schemaValue);
            } else {
              out += '' + (it.util.toQuotedString($schema));
            }
            out += '  } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should match pattern "';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + (it.util.escapeQuotes($schema));
              }
              out += '"\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + (it.util.toQuotedString($schema));
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$4$2 = (pattern$1 && typeof pattern$1 === 'object' && 'default' in pattern$1 ? pattern$1['default'] : pattern$1);

        var oneOf$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_oneOf(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false; ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1,
              l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              if (it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + '[' + $i + ']';
                $it.errSchemaPath = $errSchemaPath + '/' + $i;
                out += ' ' + (it.validate($it)) + ' ';
              } else {
                out += ' var valid' + ($it.level) + ' = true; ';
              }
              if ($i) {
                out += ' if (valid' + ($it.level) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';
                $closingBraces += '}';
              }
              out += ' if (valid' + ($it.level) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';
            }
          }
          it.compositeRule = $it.compositeRule = $wasComposite;
          out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should match exactly one schema in oneOf\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
          if (it.opts.allErrors) {
            out += ' } ';
          }
          return out;
        }
        });

        var require$$5$1 = (oneOf$1 && typeof oneOf$1 === 'object' && 'default' in oneOf$1 ? oneOf$1['default'] : oneOf$1);

        var not$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_not(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          $it.level++;
          if (it.util.schemaHasRules($schema, it.RULES.all)) {
            $it.schema = $schema;
            $it.schemaPath = $schemaPath;
            $it.errSchemaPath = $errSchemaPath;
            out += ' var ' + ($errs) + ' = errors;  ';
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            $it.createErrors = false;
            var $allErrorsOption;
            if ($it.opts.allErrors) {
              $allErrorsOption = $it.opts.allErrors;
              $it.opts.allErrors = false;
            }
            out += ' ' + (it.validate($it)) + ' ';
            $it.createErrors = true;
            if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
            it.compositeRule = $it.compositeRule = $wasComposite;
            out += ' if (valid' + ($it.level) + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should NOT be valid\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
            if (it.opts.allErrors) {
              out += ' } ';
            }
          } else {
            out += '  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should NOT be valid\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            if ($breakOnError) {
              out += ' if (false) { ';
            }
          }
          return out;
        }
        });

        var require$$6$2 = (not$1 && typeof not$1 === 'object' && 'default' in not$1 ? not$1['default'] : not$1);

        var multipleOf$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_multipleOf(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          out += 'var division' + ($lvl) + ';if (';
          if ($isData) {
            out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
          }
          out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
          if (it.opts.multipleOfPrecision) {
            out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
          } else {
            out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
          }
          out += ' ) ';
          if ($isData) {
            out += '  )  ';
          }
          out += ' ) {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { multipleOf: ' + ($schemaValue) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should be multiple of ';
              if ($isData) {
                out += '\' + ' + ($schemaValue);
              } else {
                out += '' + ($schema) + '\'';
              }
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + ($schema);
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$7$1 = (multipleOf$1 && typeof multipleOf$1 === 'object' && 'default' in multipleOf$1 ? multipleOf$1['default'] : multipleOf$1);

        var _limitProperties = __commonjs(function (module) {
        'use strict';
        module.exports = function generate__limitProperties(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $op = $keyword == 'maxProperties' ? '>' : '<';
          out += 'if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
          }
          out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
          var $errorKeyword = $keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { limit: ' + ($schemaValue) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have ';
              if ($keyword == 'maxProperties') {
                out += 'more';
              } else {
                out += 'less';
              }
              out += ' than ';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + ($schema);
              }
              out += ' properties\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + ($schema);
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$8 = (_limitProperties && typeof _limitProperties === 'object' && 'default' in _limitProperties ? _limitProperties['default'] : _limitProperties);

        var _limitLength = __commonjs(function (module) {
        'use strict';
        module.exports = function generate__limitLength(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $op = $keyword == 'maxLength' ? '>' : '<';
          out += 'if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
          }
          if (it.opts.unicode === false) {
            out += ' ' + ($data) + '.length ';
          } else {
            out += ' ucs2length(' + ($data) + ') ';
          }
          out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
          var $errorKeyword = $keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { limit: ' + ($schemaValue) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT be ';
              if ($keyword == 'maxLength') {
                out += 'longer';
              } else {
                out += 'shorter';
              }
              out += ' than ';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + ($schema);
              }
              out += ' characters\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + ($schema);
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$9 = (_limitLength && typeof _limitLength === 'object' && 'default' in _limitLength ? _limitLength['default'] : _limitLength);

        var _limitItems = __commonjs(function (module) {
        'use strict';
        module.exports = function generate__limitItems(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $op = $keyword == 'maxItems' ? '>' : '<';
          out += 'if ( ';
          if ($isData) {
            out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
          }
          out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
          var $errorKeyword = $keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { limit: ' + ($schemaValue) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have ';
              if ($keyword == 'maxItems') {
                out += 'more';
              } else {
                out += 'less';
              }
              out += ' than ';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + ($schema);
              }
              out += ' items\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + ($schema);
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += '} ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$10 = (_limitItems && typeof _limitItems === 'object' && 'default' in _limitItems ? _limitItems['default'] : _limitItems);

        var _limit = __commonjs(function (module) {
        'use strict';
        module.exports = function generate__limit(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $isMax = $keyword == 'maximum',
            $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
            $schemaExcl = it.schema[$exclusiveKeyword],
            $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
            $op = $isMax ? '<' : '>',
            $notOp = $isMax ? '>' : '<';
          if ($isDataExcl) {
            var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
              $exclusive = 'exclusive' + $lvl,
              $opExpr = 'op' + $lvl,
              $opStr = '\' + ' + $opExpr + ' + \'';
            out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
            $schemaValueExcl = 'schemaExcl' + $lvl;
            out += ' var exclusive' + ($lvl) + '; if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && typeof ' + ($schemaValueExcl) + ' != \'undefined\') { ';
            var $errorKeyword = $exclusiveKeyword;
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
              if (it.opts.messages !== false) {
                out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else if( ';
            if ($isData) {
              out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
            }
            out += ' ((exclusive' + ($lvl) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ')) { var op' + ($lvl) + ' = exclusive' + ($lvl) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
          } else {
            var $exclusive = $schemaExcl === true,
              $opStr = $op;
            if (!$exclusive) $opStr += '=';
            var $opExpr = '\'' + $opStr + '\'';
            out += ' if ( ';
            if ($isData) {
              out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
            }
            out += ' ' + ($data) + ' ' + ($notOp);
            if ($exclusive) {
              out += '=';
            }
            out += ' ' + ($schemaValue) + ') {';
          }
          var $errorKeyword = $keyword;
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should be ' + ($opStr) + ' ';
              if ($isData) {
                out += '\' + ' + ($schemaValue);
              } else {
                out += '' + ($schema) + '\'';
              }
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + ($schema);
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$11 = (_limit && typeof _limit === 'object' && 'default' in _limit ? _limit['default'] : _limit);

        var items$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_items(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var $dataNxt = $it.dataLevel = it.dataLevel + 1,
            $nextData = 'data' + $dataNxt;
          out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
          if (Array.isArray($schema)) {
            var $additionalItems = it.schema.additionalItems;
            if ($additionalItems === false) {
              out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + '/additionalItems';
              out += '  if (!' + ($valid) + ') {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { limit: ' + ($schema.length) + ' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                $closingBraces += '}';
                out += ' else { ';
              }
            }
            var arr1 = $schema;
            if (arr1) {
              var $sch, $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $sch = arr1[$i += 1];
                if (it.util.schemaHasRules($sch, it.RULES.all)) {
                  out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
                  var $passData = $data + '[' + $i + ']';
                  $it.schema = $sch;
                  $it.schemaPath = $schemaPath + '[' + $i + ']';
                  $it.errSchemaPath = $errSchemaPath + '/' + $i;
                  $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
                  $it.dataPathArr[$dataNxt] = $i;
                  var $code = it.validate($it);
                  if (it.util.varOccurences($code, $nextData) < 2) {
                    out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
                  } else {
                    out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
                  }
                  out += ' }  ';
                  if ($breakOnError) {
                    out += ' if (valid' + ($it.level) + ') { ';
                    $closingBraces += '}';
                  }
                }
              }
            }
            if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
              $it.schema = $additionalItems;
              $it.schemaPath = it.schemaPath + '.additionalItems';
              $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
              out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var i' + ($lvl) + ' = ' + ($schema.length) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);
              var $passData = $data + '[i' + $lvl + ']';
              $it.dataPathArr[$dataNxt] = 'i' + $lvl;
              var $code = it.validate($it);
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
              } else {
                out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
              }
              if ($breakOnError) {
                out += ' if (!valid' + ($it.level) + ') break; ';
              }
              out += ' } }  ';
              if ($breakOnError) {
                out += ' if (valid' + ($it.level) + ') { ';
                $closingBraces += '}';
              }
            }
          } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
            $it.schema = $schema;
            $it.schemaPath = $schemaPath;
            $it.errSchemaPath = $errSchemaPath;
            out += '  for (var i' + ($lvl) + ' = ' + (0) + '; i' + ($lvl) + ' < ' + ($data) + '.length; i' + ($lvl) + '++) { ';
            $it.errorPath = it.util.getPathExpr(it.errorPath, 'i' + $lvl, it.opts.jsonPointers, true);
            var $passData = $data + '[i' + $lvl + ']';
            $it.dataPathArr[$dataNxt] = 'i' + $lvl;
            var $code = it.validate($it);
            if (it.util.varOccurences($code, $nextData) < 2) {
              out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
            } else {
              out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
            }
            if ($breakOnError) {
              out += ' if (!valid' + ($it.level) + ') break; ';
            }
            out += ' }  ';
            if ($breakOnError) {
              out += ' if (valid' + ($it.level) + ') { ';
              $closingBraces += '}';
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
          }
          out = it.util.cleanUpCode(out);
          return out;
        }
        });

        var require$$12 = (items$1 && typeof items$1 === 'object' && 'default' in items$1 ? items$1['default'] : items$1);

        var format$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_format(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          if (it.opts.format === false) {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          }
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          if ($isData) {
            var $format = 'format' + $lvl;
            out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var isObject' + ($lvl) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; if (isObject' + ($lvl) + ') { var async' + ($lvl) + ' = ' + ($format) + '.async; ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
            if ($isData) {
              out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
            }
            out += ' (' + ($format) + ' && !(typeof ' + ($format) + ' == \'function\' ? ';
            if (it.async) {
              out += ' (async' + ($lvl) + ' ? ' + (it.yieldAwait) + ' ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
            } else {
              out += ' ' + ($format) + '(' + ($data) + ') ';
            }
            out += ' : ' + ($format) + '.test(' + ($data) + ')))) {';
          } else {
            var $format = it.formats[$schema];
            if (!$format) {
              if ($breakOnError) {
                out += ' if (true) { ';
              }
              return out;
            }
            var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
            if ($isObject) {
              var $async = $format.async === true;
              $format = $format.validate;
            }
            if ($async) {
              if (!it.async) throw new Error('async format in sync schema');
              var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
              out += ' if (!(' + (it.yieldAwait) + ' ' + ($formatRef) + '(' + ($data) + '))) { ';
            } else {
              out += ' if (! ';
              var $formatRef = 'formats' + it.util.getProperty($schema);
              if ($isObject) $formatRef += '.validate';
              if (typeof $format == 'function') {
                out += ' ' + ($formatRef) + '(' + ($data) + ') ';
              } else {
                out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
              }
              out += ') { ';
            }
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { format:  ';
            if ($isData) {
              out += '' + ($schemaValue);
            } else {
              out += '' + (it.util.toQuotedString($schema));
            }
            out += '  } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should match format "';
              if ($isData) {
                out += '\' + ' + ($schemaValue) + ' + \'';
              } else {
                out += '' + (it.util.escapeQuotes($schema));
              }
              out += '"\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema:  ';
              if ($isData) {
                out += 'validate.schema' + ($schemaPath);
              } else {
                out += '' + (it.util.toQuotedString($schema));
              }
              out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$13 = (format$1 && typeof format$1 === 'object' && 'default' in format$1 ? format$1['default'] : format$1);

        var _enum = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_enum(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $isData = it.opts.v5 && $schema.$data;
          var $schemaValue = $isData ? it.util.getData($schema.$data, $dataLvl, it.dataPathArr) : $schema;
          if ($isData) {
            out += ' var schema' + ($lvl) + ' = ' + ($schemaValue) + '; ';
            $schemaValue = 'schema' + $lvl;
          }
          var $i = 'i' + $lvl;
          if (!$isData) {
            out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
          }
          out += 'var ' + ($valid) + ';';
          if ($isData) {
            out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
          }
          out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<schema' + ($lvl) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', schema' + ($lvl) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
          if ($isData) {
            out += '  }  ';
          }
          out += ' if (!' + ($valid) + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should be equal to one of the allowed values\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' }';
          if ($breakOnError) {
            out += ' else { ';
          }
          return out;
        }
        });

        var require$$14 = (_enum && typeof _enum === 'object' && 'default' in _enum ? _enum['default'] : _enum);

        var dependencies$3 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_dependencies(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var $schemaDeps = {},
            $propertyDeps = {};
          for ($property in $schema) {
            var $sch = $schema[$property];
            var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
            $deps[$property] = $sch;
          }
          out += 'var ' + ($errs) + ' = errors;';
          var $currentErrorPath = it.errorPath;
          out += 'var missing' + ($lvl) + ';';
          for (var $property in $propertyDeps) {
            $deps = $propertyDeps[$property];
            out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined && ( ';
            var arr1 = $deps;
            if (arr1) {
              var _$property, $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                _$property = arr1[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty(_$property);
                out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
              }
            }
            out += ')) {  ';
            var $propertyPath = 'missing' + $lvl,
              $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' }   ';
            if ($breakOnError) {
              $closingBraces += '}';
              out += ' else { ';
            }
          }
          it.errorPath = $currentErrorPath;
          for (var $property in $schemaDeps) {
            var $sch = $schemaDeps[$property];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              out += ' valid' + ($it.level) + ' = true; if (' + ($data) + '[\'' + ($property) + '\'] !== undefined) { ';
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + it.util.getProperty($property);
              $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
              out += ' ' + (it.validate($it)) + ' }  ';
              if ($breakOnError) {
                out += ' if (valid' + ($it.level) + ') { ';
                $closingBraces += '}';
              }
            }
          }
          if ($breakOnError) {
            out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
          }
          out = it.util.cleanUpCode(out);
          return out;
        }
        });

        var require$$15 = (dependencies$3 && typeof dependencies$3 === 'object' && 'default' in dependencies$3 ? dependencies$3['default'] : dependencies$3);

        var anyOf$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_anyOf(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $errs = 'errs__' + $lvl;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var $noEmptySchema = $schema.every(function($sch) {
            return it.util.schemaHasRules($sch, it.RULES.all);
          });
          if ($noEmptySchema) {
            out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
            var $wasComposite = it.compositeRule;
            it.compositeRule = $it.compositeRule = true;
            var arr1 = $schema;
            if (arr1) {
              var $sch, $i = -1,
                l1 = arr1.length - 1;
              while ($i < l1) {
                $sch = arr1[$i += 1];
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + '[' + $i + ']';
                $it.errSchemaPath = $errSchemaPath + '/' + $i;
                out += ' ' + (it.validate($it)) + ' ' + ($valid) + ' = ' + ($valid) + ' || valid' + ($it.level) + '; if (!' + ($valid) + ') { ';
                $closingBraces += '}';
              }
            }
            it.compositeRule = $it.compositeRule = $wasComposite;
            out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: {} ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should match some schema in anyOf\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
            if (it.opts.allErrors) {
              out += ' } ';
            }
            out = it.util.cleanUpCode(out);
          } else {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
          }
          return out;
        }
        });

        var require$$16 = (anyOf$1 && typeof anyOf$1 === 'object' && 'default' in anyOf$1 ? anyOf$1['default'] : anyOf$1);

        var allOf$1 = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_allOf(it, $keyword) {
          var out = ' ';
          var $schema = it.schema[$keyword];
          var $schemaPath = it.schemaPath + '.' + $keyword;
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $it = it.util.copy(it);
          var $closingBraces = '';
          $it.level++;
          var arr1 = $schema;
          if (arr1) {
            var $sch, $i = -1,
              l1 = arr1.length - 1;
            while ($i < l1) {
              $sch = arr1[$i += 1];
              if (it.util.schemaHasRules($sch, it.RULES.all)) {
                $it.schema = $sch;
                $it.schemaPath = $schemaPath + '[' + $i + ']';
                $it.errSchemaPath = $errSchemaPath + '/' + $i;
                out += ' ' + (it.validate($it)) + '  ';
                if ($breakOnError) {
                  out += ' if (valid' + ($it.level) + ') { ';
                  $closingBraces += '}';
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces.slice(0, -1));
          }
          out = it.util.cleanUpCode(out);
          return out;
        }
        });

        var require$$17 = (allOf$1 && typeof allOf$1 === 'object' && 'default' in allOf$1 ? allOf$1['default'] : allOf$1);

        var ref = __commonjs(function (module) {
        'use strict';
        module.exports = function generate_ref(it, $keyword) {
          var out = ' ';
          var $lvl = it.level;
          var $dataLvl = it.dataLevel;
          var $schema = it.schema[$keyword];
          var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
          var $breakOnError = !it.opts.allErrors;
          var $errorKeyword;
          var $data = 'data' + ($dataLvl || '');
          var $valid = 'valid' + $lvl;
          var $async, $refCode;
          if ($schema == '#' || $schema == '#/') {
            if (it.isRoot) {
              $async = it.async;
              $refCode = 'validate';
            } else {
              $async = it.root.schema.$async === true;
              $refCode = 'root.refVal[0]';
            }
          } else {
            var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
            if ($refVal === undefined) {
              var $message = 'can\'t resolve reference ' + $schema + ' from id ' + it.baseId;
              if (it.opts.missingRefs == 'fail') {
                console.log($message);
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = ''; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + ($errorKeyword || '$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: "' + ($errSchemaPath) + '" , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                  if (it.async) {
                    out += ' throw new ValidationError([' + (__err) + ']); ';
                  } else {
                    out += ' validate.errors = [' + (__err) + ']; return false; ';
                  }
                } else {
                  out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                }
                if ($breakOnError) {
                  out += ' if (false) { ';
                }
              } else if (it.opts.missingRefs == 'ignore') {
                console.log($message);
                if ($breakOnError) {
                  out += ' if (true) { ';
                }
              } else {
                var $error = new Error($message);
                $error.missingRef = it.resolve.url(it.baseId, $schema);
                $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));
                throw $error;
              }
            } else if ($refVal.inline) {
              var $it = it.util.copy(it);
              $it.level++;
              $it.schema = $refVal.schema;
              $it.schemaPath = '';
              $it.errSchemaPath = $schema;
              var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
              out += ' ' + ($code) + ' ';
              if ($breakOnError) {
                out += ' if (valid' + ($it.level) + ') { ';
              }
            } else {
              $async = $refVal.async === true;
              $refCode = $refVal.code;
            }
          }
          if ($refCode) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = '';
            if (it.opts.passContext) {
              out += ' ' + ($refCode) + '.call(this, ';
            } else {
              out += ' ' + ($refCode) + '( ';
            }
            out += ' ' + ($data) + ', (dataPath || \'\')';
            if (it.errorPath != '""') {
              out += ' + ' + (it.errorPath);
            }
            if ($dataLvl) {
              out += ' , data' + (($dataLvl - 1) || '') + ' , ' + (it.dataPathArr[$dataLvl]) + ' ';
            } else {
              out += ' , parentData , parentDataProperty ';
            }
            out += ')  ';
            var __callValidate = out;
            out = $$outStack.pop();
            if ($async) {
              if (!it.async) throw new Error('async schema referenced by sync schema');
              out += ' try { ';
              if ($breakOnError) {
                out += 'var ' + ($valid) + ' =';
              }
              out += ' ' + (it.yieldAwait) + ' ' + (__callValidate) + '; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } ';
              if ($breakOnError) {
                out += ' if (' + ($valid) + ') { ';
              }
            } else {
              out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
              if ($breakOnError) {
                out += ' else { ';
              }
            }
          }
          return out;
        }
        });

        var require$$18 = (ref && typeof ref === 'object' && 'default' in ref ? ref['default'] : ref);

        var _rules = __commonjs(function (module) {
        'use strict';

        //all requires must be explicit because browserify won't work with dynamic requires
        module.exports = {
          '$ref': require$$18,
          allOf: require$$17,
          anyOf: require$$16,
          dependencies: require$$15,
          enum: require$$14,
          format: require$$13,
          items: require$$12,
          maximum: require$$11,
          minimum: require$$11,
          maxItems: require$$10,
          minItems: require$$10,
          maxLength: require$$9,
          minLength: require$$9,
          maxProperties: require$$8,
          minProperties: require$$8,
          multipleOf: require$$7$1,
          not: require$$6$2,
          oneOf: require$$5$1,
          pattern: require$$4$2,
          properties: require$$3$2,
          required: require$$2$3,
          uniqueItems: require$$1$6,
          validate: require$$3$1
        };
        });

        var require$$1$5 = (_rules && typeof _rules === 'object' && 'default' in _rules ? _rules['default'] : _rules);

        var rules = __commonjs(function (module) {
        'use strict';

        var ruleModules = require$$1$5
          , util = require$$6;

        module.exports = function rules() {
          var RULES = [
            { type: 'number',
              rules: [ 'maximum', 'minimum', 'multipleOf'] },
            { type: 'string',
              rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
            { type: 'array',
              rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },
            { type: 'object',
              rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },
            { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }
          ];

          RULES.all = [ 'type', 'additionalProperties', 'patternProperties' ];
          RULES.keywords = [ 'additionalItems', '$schema', 'id', 'title', 'description', 'default' ];
          RULES.types = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];

          RULES.forEach(function (group) {
            group.rules = group.rules.map(function (keyword) {
              RULES.all.push(keyword);
              return {
                keyword: keyword,
                code: ruleModules[keyword]
              };
            });
          });

          RULES.keywords = util.toHash(RULES.all.concat(RULES.keywords));
          RULES.all = util.toHash(RULES.all);
          RULES.types = util.toHash(RULES.types);

          return RULES;
        };
        });

        var require$$7 = (rules && typeof rules === 'object' && 'default' in rules ? rules['default'] : rules);

        var formats = __commonjs(function (module) {
        'use strict';

        var util = require$$6;

        var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
        var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
        var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
        var HOSTNAME = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;
        var URI = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i;
        var UUID = /^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
        var JSON_POINTER = /^(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?$|^\#(?:\/(?:[a-z0-9_\-\.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)+)*(?:\/)?$/i;
        var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)+)*(?:\/)?)$/;


        module.exports = formats;

        function formats(mode) {
          mode = mode == 'full' ? 'full' : 'fast';
          var formatDefs = util.copy(formats[mode]);
          for (var fName in formats.compare) {
            formatDefs[fName] = {
              validate: formatDefs[fName],
              compare: formats.compare[fName]
            };
          }
          return formatDefs;
        }


        formats.fast = {
          // date: http://tools.ietf.org/html/rfc3339#section-5.6
          date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
          // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
          time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
          'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
          // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
          uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,
          // email (sources from jsen validator):
          // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
          // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
          email: /^[a-z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
          hostname: HOSTNAME,
          // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
          ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
          // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
          ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
          regex: regex,
          // uuid: http://tools.ietf.org/html/rfc4122
          uuid: UUID,
          // JSON-pointer: https://tools.ietf.org/html/rfc6901
          // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
          'json-pointer': JSON_POINTER,
          // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
          'relative-json-pointer': RELATIVE_JSON_POINTER
        };


        formats.full = {
          date: date,
          time: time,
          'date-time': date_time,
          uri: uri,
          email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
          hostname: hostname,
          ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
          ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
          regex: regex,
          uuid: UUID,
          'json-pointer': JSON_POINTER,
          'relative-json-pointer': RELATIVE_JSON_POINTER
        };


        formats.compare = {
          date: compareDate,
          time: compareTime,
          'date-time': compareDateTime
        };


        function date(str) {
          // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
          var matches = str.match(DATE);
          if (!matches) return false;

          var month = +matches[1];
          var day = +matches[2];
          return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
        }


        function time(str, full) {
          var matches = str.match(TIME);
          if (!matches) return false;

          var hour = matches[1];
          var minute = matches[2];
          var second = matches[3];
          var timeZone = matches[5];
          return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
        }


        var DATE_TIME_SEPARATOR = /t|\s/i;
        function date_time(str) {
          // http://tools.ietf.org/html/rfc3339#section-5.6
          var dateTime = str.split(DATE_TIME_SEPARATOR);
          return date(dateTime[0]) && time(dateTime[1], true);
        }


        function hostname(str) {
          // http://tools.ietf.org/html/rfc1034#section-3.5
          return str.length <= 255 && HOSTNAME.test(str);
        }


        var NOT_URI_FRAGMENT = /\/|\:/;
        function uri(str) {
          // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
          return NOT_URI_FRAGMENT.test(str) && URI.test(str);
        }


        function regex(str) {
          try {
            new RegExp(str);
            return true;
          } catch(e) {
            return false;
          }
        }


        function compareDate(d1, d2) {
          if (!(d1 && d2)) return;
          if (d1 > d2) return 1;
          if (d1 < d2) return -1;
          if (d1 === d2) return 0;
        }


        function compareTime(t1, t2) {
          if (!(t1 && t2)) return;
          t1 = t1.match(TIME);
          t2 = t2.match(TIME);
          if (!(t1 && t2)) return;
          t1 = t1[1] + t1[2] + t1[3] + (t1[4]||'');
          t2 = t2[1] + t2[2] + t2[3] + (t2[4]||'');
          if (t1 > t2) return 1;
          if (t1 < t2) return -1;
          if (t1 === t2) return 0;
        }


        function compareDateTime(dt1, dt2) {
          if (!(dt1 && dt2)) return;
          dt1 = dt1.split(DATE_TIME_SEPARATOR);
          dt2 = dt2.split(DATE_TIME_SEPARATOR);
          var res = compareDate(dt1[0], dt2[0]);
          if (res === undefined) return;
          return res || compareTime(dt1[1], dt2[1]);
        }
        });

        var require$$8$1 = (formats && typeof formats === 'object' && 'default' in formats ? formats['default'] : formats);

        var schema_obj = __commonjs(function (module) {
        'use strict';

        var util = require$$6;

        module.exports = SchemaObject;

        function SchemaObject(obj) {
          util.copy(obj, this);
        }
        });

        var require$$0$9 = (schema_obj && typeof schema_obj === 'object' && 'default' in schema_obj ? schema_obj['default'] : schema_obj);

        var cache = __commonjs(function (module) {
        'use strict';


        var Cache = module.exports = function Cache() {
          this._cache = {};
        };


        Cache.prototype.put = function Cache_put(key, value) {
          this._cache[key] = value;
        };


        Cache.prototype.get = function Cache_get(key) {
          return this._cache[key];
        };


        Cache.prototype.del = function Cache_del(key) {
          delete this._cache[key];
        };


        Cache.prototype.clear = function Cache_clear() {
          this._cache = {};
        };
        });

        var require$$11$1 = (cache && typeof cache === 'object' && 'default' in cache ? cache['default'] : cache);

        var equal = __commonjs(function (module) {
        'use strict';

        module.exports = function equal(a, b) {
          if (a === b) return true;

          var arrA = Array.isArray(a)
            , arrB = Array.isArray(b)
            , i;

          if (arrA && arrB) {
            if (a.length != b.length) return false;
            for (i = 0; i < a.length; i++)
              if (!equal(a[i], b[i])) return false;
            return true;
          }

          if (arrA != arrB) return false;

          if (a && b && typeof a === 'object' && typeof b === 'object') {
            var keys = Object.keys(a);

            if (keys.length !== Object.keys(b).length) return false;

            for (i = 0; i < keys.length; i++)
              if (b[keys[i]] === undefined) return false;

            for (i = 0; i < keys.length; i++)
              if(!equal(a[keys[i]], b[keys[i]])) return false;

            return true;
          }

          return false;
        };
        });

        var require$$1$7 = (equal && typeof equal === 'object' && 'default' in equal ? equal['default'] : equal);

        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.


        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707
        function hasOwnProperty(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        var isArray = Array.isArray || function (xs) {
          return Object.prototype.toString.call(xs) === '[object Array]';
        };
        function stringifyPrimitive(v) {
          switch (typeof v) {
            case 'string':
              return v;

            case 'boolean':
              return v ? 'true' : 'false';

            case 'number':
              return isFinite(v) ? v : '';

            default:
              return '';
          }
        }

        function stringify$2 (obj, sep, eq, name) {
          sep = sep || '&';
          eq = eq || '=';
          if (obj === null) {
            obj = undefined;
          }

          if (typeof obj === 'object') {
            return map(objectKeys(obj), function(k) {
              var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
              if (isArray(obj[k])) {
                return map(obj[k], function(v) {
                  return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep);
              } else {
                return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
              }
            }).join(sep);

          }

          if (!name) return '';
          return encodeURIComponent(stringifyPrimitive(name)) + eq +
                 encodeURIComponent(stringifyPrimitive(obj));
        };

        function map (xs, f) {
          if (xs.map) return xs.map(f);
          var res = [];
          for (var i = 0; i < xs.length; i++) {
            res.push(f(xs[i], i));
          }
          return res;
        }

        var objectKeys = Object.keys || function (obj) {
          var res = [];
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
          }
          return res;
        };

        function parse$3(qs, sep, eq, options) {
          sep = sep || '&';
          eq = eq || '=';
          var obj = {};

          if (typeof qs !== 'string' || qs.length === 0) {
            return obj;
          }

          var regexp = /\+/g;
          qs = qs.split(sep);

          var maxKeys = 1000;
          if (options && typeof options.maxKeys === 'number') {
            maxKeys = options.maxKeys;
          }

          var len = qs.length;
          // maxKeys <= 0 means that we should not limit keys count
          if (maxKeys > 0 && len > maxKeys) {
            len = maxKeys;
          }

          for (var i = 0; i < len; ++i) {
            var x = qs[i].replace(regexp, '%20'),
                idx = x.indexOf(eq),
                kstr, vstr, k, v;

            if (idx >= 0) {
              kstr = x.substr(0, idx);
              vstr = x.substr(idx + 1);
            } else {
              kstr = x;
              vstr = '';
            }

            k = decodeURIComponent(kstr);
            v = decodeURIComponent(vstr);

            if (!hasOwnProperty(obj, k)) {
              obj[k] = v;
            } else if (isArray(obj[k])) {
              obj[k].push(v);
            } else {
              obj[k] = [obj[k], v];
            }
          }

          return obj;
        };
        var require$$0$10 = {
          encode: stringify$2,
          stringify: stringify$2,
          decode: parse$3,
          parse: parse$3
        }

        var util$2 = __commonjs(function (module) {
        'use strict';

        module.exports = {
          isString: function(arg) {
            return typeof(arg) === 'string';
          },
          isObject: function(arg) {
            return typeof(arg) === 'object' && arg !== null;
          },
          isNull: function(arg) {
            return arg === null;
          },
          isNullOrUndefined: function(arg) {
            return arg == null;
          }
        };
        });

        var require$$1$8 = (util$2 && typeof util$2 === 'object' && 'default' in util$2 ? util$2['default'] : util$2);

        var punycode = __commonjs(function (module, exports, global) {
        /*! https://mths.be/punycode v1.4.1 by @mathias */
        ;(function(root) {

        	/** Detect free variables */
        	var freeExports = typeof exports == 'object' && exports &&
        		!exports.nodeType && exports;
        	var freeModule = typeof module == 'object' && module &&
        		!module.nodeType && module;
        	var freeGlobal = typeof global == 'object' && global;
        	if (
        		freeGlobal.global === freeGlobal ||
        		freeGlobal.window === freeGlobal ||
        		freeGlobal.self === freeGlobal
        	) {
        		root = freeGlobal;
        	}

        	/**
        	 * The `punycode` object.
        	 * @name punycode
        	 * @type Object
        	 */
        	var punycode,

        	/** Highest positive signed 32-bit float value */
        	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

        	/** Bootstring parameters */
        	base = 36,
        	tMin = 1,
        	tMax = 26,
        	skew = 38,
        	damp = 700,
        	initialBias = 72,
        	initialN = 128, // 0x80
        	delimiter = '-', // '\x2D'

        	/** Regular expressions */
        	regexPunycode = /^xn--/,
        	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
        	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

        	/** Error messages */
        	errors = {
        		'overflow': 'Overflow: input needs wider integers to process',
        		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
        		'invalid-input': 'Invalid input'
        	},

        	/** Convenience shortcuts */
        	baseMinusTMin = base - tMin,
        	floor = Math.floor,
        	stringFromCharCode = String.fromCharCode,

        	/** Temporary variable */
        	key;

        	/*--------------------------------------------------------------------------*/

        	/**
        	 * A generic error utility function.
        	 * @private
        	 * @param {String} type The error type.
        	 * @returns {Error} Throws a `RangeError` with the applicable error message.
        	 */
        	function error(type) {
        		throw new RangeError(errors[type]);
        	}

        	/**
        	 * A generic `Array#map` utility function.
        	 * @private
        	 * @param {Array} array The array to iterate over.
        	 * @param {Function} callback The function that gets called for every array
        	 * item.
        	 * @returns {Array} A new array of values returned by the callback function.
        	 */
        	function map(array, fn) {
        		var length = array.length;
        		var result = [];
        		while (length--) {
        			result[length] = fn(array[length]);
        		}
        		return result;
        	}

        	/**
        	 * A simple `Array#map`-like wrapper to work with domain name strings or email
        	 * addresses.
        	 * @private
        	 * @param {String} domain The domain name or email address.
        	 * @param {Function} callback The function that gets called for every
        	 * character.
        	 * @returns {Array} A new string of characters returned by the callback
        	 * function.
        	 */
        	function mapDomain(string, fn) {
        		var parts = string.split('@');
        		var result = '';
        		if (parts.length > 1) {
        			// In email addresses, only the domain name should be punycoded. Leave
        			// the local part (i.e. everything up to `@`) intact.
        			result = parts[0] + '@';
        			string = parts[1];
        		}
        		// Avoid `split(regex)` for IE8 compatibility. See #17.
        		string = string.replace(regexSeparators, '\x2E');
        		var labels = string.split('.');
        		var encoded = map(labels, fn).join('.');
        		return result + encoded;
        	}

        	/**
        	 * Creates an array containing the numeric code points of each Unicode
        	 * character in the string. While JavaScript uses UCS-2 internally,
        	 * this function will convert a pair of surrogate halves (each of which
        	 * UCS-2 exposes as separate characters) into a single code point,
        	 * matching UTF-16.
        	 * @see `punycode.ucs2.encode`
        	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
        	 * @memberOf punycode.ucs2
        	 * @name decode
        	 * @param {String} string The Unicode input string (UCS-2).
        	 * @returns {Array} The new array of code points.
        	 */
        	function ucs2decode(string) {
        		var output = [],
        		    counter = 0,
        		    length = string.length,
        		    value,
        		    extra;
        		while (counter < length) {
        			value = string.charCodeAt(counter++);
        			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        				// high surrogate, and there is a next character
        				extra = string.charCodeAt(counter++);
        				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
        					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        				} else {
        					// unmatched surrogate; only append this code unit, in case the next
        					// code unit is the high surrogate of a surrogate pair
        					output.push(value);
        					counter--;
        				}
        			} else {
        				output.push(value);
        			}
        		}
        		return output;
        	}

        	/**
        	 * Creates a string based on an array of numeric code points.
        	 * @see `punycode.ucs2.decode`
        	 * @memberOf punycode.ucs2
        	 * @name encode
        	 * @param {Array} codePoints The array of numeric code points.
        	 * @returns {String} The new Unicode string (UCS-2).
        	 */
        	function ucs2encode(array) {
        		return map(array, function(value) {
        			var output = '';
        			if (value > 0xFFFF) {
        				value -= 0x10000;
        				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        				value = 0xDC00 | value & 0x3FF;
        			}
        			output += stringFromCharCode(value);
        			return output;
        		}).join('');
        	}

        	/**
        	 * Converts a basic code point into a digit/integer.
        	 * @see `digitToBasic()`
        	 * @private
        	 * @param {Number} codePoint The basic numeric code point value.
        	 * @returns {Number} The numeric value of a basic code point (for use in
        	 * representing integers) in the range `0` to `base - 1`, or `base` if
        	 * the code point does not represent a value.
        	 */
        	function basicToDigit(codePoint) {
        		if (codePoint - 48 < 10) {
        			return codePoint - 22;
        		}
        		if (codePoint - 65 < 26) {
        			return codePoint - 65;
        		}
        		if (codePoint - 97 < 26) {
        			return codePoint - 97;
        		}
        		return base;
        	}

        	/**
        	 * Converts a digit/integer into a basic code point.
        	 * @see `basicToDigit()`
        	 * @private
        	 * @param {Number} digit The numeric value of a basic code point.
        	 * @returns {Number} The basic code point whose value (when used for
        	 * representing integers) is `digit`, which needs to be in the range
        	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
        	 * used; else, the lowercase form is used. The behavior is undefined
        	 * if `flag` is non-zero and `digit` has no uppercase form.
        	 */
        	function digitToBasic(digit, flag) {
        		//  0..25 map to ASCII a..z or A..Z
        		// 26..35 map to ASCII 0..9
        		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        	}

        	/**
        	 * Bias adaptation function as per section 3.4 of RFC 3492.
        	 * https://tools.ietf.org/html/rfc3492#section-3.4
        	 * @private
        	 */
        	function adapt(delta, numPoints, firstTime) {
        		var k = 0;
        		delta = firstTime ? floor(delta / damp) : delta >> 1;
        		delta += floor(delta / numPoints);
        		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
        			delta = floor(delta / baseMinusTMin);
        		}
        		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        	}

        	/**
        	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
        	 * symbols.
        	 * @memberOf punycode
        	 * @param {String} input The Punycode string of ASCII-only symbols.
        	 * @returns {String} The resulting string of Unicode symbols.
        	 */
        	function decode(input) {
        		// Don't use UCS-2
        		var output = [],
        		    inputLength = input.length,
        		    out,
        		    i = 0,
        		    n = initialN,
        		    bias = initialBias,
        		    basic,
        		    j,
        		    index,
        		    oldi,
        		    w,
        		    k,
        		    digit,
        		    t,
        		    /** Cached calculation results */
        		    baseMinusT;

        		// Handle the basic code points: let `basic` be the number of input code
        		// points before the last delimiter, or `0` if there is none, then copy
        		// the first basic code points to the output.

        		basic = input.lastIndexOf(delimiter);
        		if (basic < 0) {
        			basic = 0;
        		}

        		for (j = 0; j < basic; ++j) {
        			// if it's not a basic code point
        			if (input.charCodeAt(j) >= 0x80) {
        				error('not-basic');
        			}
        			output.push(input.charCodeAt(j));
        		}

        		// Main decoding loop: start just after the last delimiter if any basic code
        		// points were copied; start at the beginning otherwise.

        		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

        			// `index` is the index of the next character to be consumed.
        			// Decode a generalized variable-length integer into `delta`,
        			// which gets added to `i`. The overflow checking is easier
        			// if we increase `i` as we go, then subtract off its starting
        			// value at the end to obtain `delta`.
        			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

        				if (index >= inputLength) {
        					error('invalid-input');
        				}

        				digit = basicToDigit(input.charCodeAt(index++));

        				if (digit >= base || digit > floor((maxInt - i) / w)) {
        					error('overflow');
        				}

        				i += digit * w;
        				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

        				if (digit < t) {
        					break;
        				}

        				baseMinusT = base - t;
        				if (w > floor(maxInt / baseMinusT)) {
        					error('overflow');
        				}

        				w *= baseMinusT;

        			}

        			out = output.length + 1;
        			bias = adapt(i - oldi, out, oldi == 0);

        			// `i` was supposed to wrap around from `out` to `0`,
        			// incrementing `n` each time, so we'll fix that now:
        			if (floor(i / out) > maxInt - n) {
        				error('overflow');
        			}

        			n += floor(i / out);
        			i %= out;

        			// Insert `n` at position `i` of the output
        			output.splice(i++, 0, n);

        		}

        		return ucs2encode(output);
        	}

        	/**
        	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
        	 * Punycode string of ASCII-only symbols.
        	 * @memberOf punycode
        	 * @param {String} input The string of Unicode symbols.
        	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
        	 */
        	function encode(input) {
        		var n,
        		    delta,
        		    handledCPCount,
        		    basicLength,
        		    bias,
        		    j,
        		    m,
        		    q,
        		    k,
        		    t,
        		    currentValue,
        		    output = [],
        		    /** `inputLength` will hold the number of code points in `input`. */
        		    inputLength,
        		    /** Cached calculation results */
        		    handledCPCountPlusOne,
        		    baseMinusT,
        		    qMinusT;

        		// Convert the input in UCS-2 to Unicode
        		input = ucs2decode(input);

        		// Cache the length
        		inputLength = input.length;

        		// Initialize the state
        		n = initialN;
        		delta = 0;
        		bias = initialBias;

        		// Handle the basic code points
        		for (j = 0; j < inputLength; ++j) {
        			currentValue = input[j];
        			if (currentValue < 0x80) {
        				output.push(stringFromCharCode(currentValue));
        			}
        		}

        		handledCPCount = basicLength = output.length;

        		// `handledCPCount` is the number of code points that have been handled;
        		// `basicLength` is the number of basic code points.

        		// Finish the basic string - if it is not empty - with a delimiter
        		if (basicLength) {
        			output.push(delimiter);
        		}

        		// Main encoding loop:
        		while (handledCPCount < inputLength) {

        			// All non-basic code points < n have been handled already. Find the next
        			// larger one:
        			for (m = maxInt, j = 0; j < inputLength; ++j) {
        				currentValue = input[j];
        				if (currentValue >= n && currentValue < m) {
        					m = currentValue;
        				}
        			}

        			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
        			// but guard against overflow
        			handledCPCountPlusOne = handledCPCount + 1;
        			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        				error('overflow');
        			}

        			delta += (m - n) * handledCPCountPlusOne;
        			n = m;

        			for (j = 0; j < inputLength; ++j) {
        				currentValue = input[j];

        				if (currentValue < n && ++delta > maxInt) {
        					error('overflow');
        				}

        				if (currentValue == n) {
        					// Represent delta as a generalized variable-length integer
        					for (q = delta, k = base; /* no condition */; k += base) {
        						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
        						if (q < t) {
        							break;
        						}
        						qMinusT = q - t;
        						baseMinusT = base - t;
        						output.push(
        							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
        						);
        						q = floor(qMinusT / baseMinusT);
        					}

        					output.push(stringFromCharCode(digitToBasic(q, 0)));
        					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        					delta = 0;
        					++handledCPCount;
        				}
        			}

        			++delta;
        			++n;

        		}
        		return output.join('');
        	}

        	/**
        	 * Converts a Punycode string representing a domain name or an email address
        	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
        	 * it doesn't matter if you call it on a string that has already been
        	 * converted to Unicode.
        	 * @memberOf punycode
        	 * @param {String} input The Punycoded domain name or email address to
        	 * convert to Unicode.
        	 * @returns {String} The Unicode representation of the given Punycode
        	 * string.
        	 */
        	function toUnicode(input) {
        		return mapDomain(input, function(string) {
        			return regexPunycode.test(string)
        				? decode(string.slice(4).toLowerCase())
        				: string;
        		});
        	}

        	/**
        	 * Converts a Unicode string representing a domain name or an email address to
        	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
        	 * i.e. it doesn't matter if you call it with a domain that's already in
        	 * ASCII.
        	 * @memberOf punycode
        	 * @param {String} input The domain name or email address to convert, as a
        	 * Unicode string.
        	 * @returns {String} The Punycode representation of the given domain name or
        	 * email address.
        	 */
        	function toASCII(input) {
        		return mapDomain(input, function(string) {
        			return regexNonASCII.test(string)
        				? 'xn--' + encode(string)
        				: string;
        		});
        	}

        	/*--------------------------------------------------------------------------*/

        	/** Define the public API */
        	punycode = {
        		/**
        		 * A string representing the current Punycode.js version number.
        		 * @memberOf punycode
        		 * @type String
        		 */
        		'version': '1.4.1',
        		/**
        		 * An object of methods to convert from JavaScript's internal character
        		 * representation (UCS-2) to Unicode code points, and back.
        		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
        		 * @memberOf punycode
        		 * @type Object
        		 */
        		'ucs2': {
        			'decode': ucs2decode,
        			'encode': ucs2encode
        		},
        		'decode': decode,
        		'encode': encode,
        		'toASCII': toASCII,
        		'toUnicode': toUnicode
        	};

        	/** Expose `punycode` */
        	// Some AMD build optimizers, like r.js, check for specific condition patterns
        	// like the following:
        	if (
        		typeof define == 'function' &&
        		typeof define.amd == 'object' &&
        		define.amd
        	) {
        		define('punycode', function() {
        			return punycode;
        		});
        	} else if (freeExports && freeModule) {
        		if (module.exports == freeExports) {
        			// in Node.js, io.js, or RingoJS v0.8.0+
        			freeModule.exports = punycode;
        		} else {
        			// in Narwhal or RingoJS v0.7.0-
        			for (key in punycode) {
        				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
        			}
        		}
        	} else {
        		// in Rhino or a web browser
        		root.punycode = punycode;
        	}

        }(__commonjs_global));
        });

        var require$$2$4 = (punycode && typeof punycode === 'object' && 'default' in punycode ? punycode['default'] : punycode);

        var url = __commonjs(function (module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        var punycode = require$$2$4;
        var util = require$$1$8;

        exports.parse = urlParse;
        exports.resolve = urlResolve;
        exports.resolveObject = urlResolveObject;
        exports.format = urlFormat;

        exports.Url = Url;

        function Url() {
          this.protocol = null;
          this.slashes = null;
          this.auth = null;
          this.host = null;
          this.port = null;
          this.hostname = null;
          this.hash = null;
          this.search = null;
          this.query = null;
          this.pathname = null;
          this.path = null;
          this.href = null;
        }

        // Reference: RFC 3986, RFC 1808, RFC 2396

        // define these here so at least they only have to be
        // compiled once on the first module load.
        var protocolPattern = /^([a-z0-9.+-]+:)/i,
            portPattern = /:[0-9]*$/,

            // Special case for a simple path URL
            simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

            // RFC 2396: characters reserved for delimiting URLs.
            // We actually just auto-escape these.
            delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

            // RFC 2396: characters not allowed for various reasons.
            unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

            // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
            autoEscape = ['\''].concat(unwise),
            // Characters that are never ever allowed in a hostname.
            // Note that any invalid chars are also handled, but these
            // are the ones that are *expected* to be seen, so we fast-path
            // them.
            nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
            hostEndingChars = ['/', '?', '#'],
            hostnameMaxLen = 255,
            hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
            hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
            // protocols that can allow "unsafe" and "unwise" chars.
            unsafeProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that never have a hostname.
            hostlessProtocol = {
              'javascript': true,
              'javascript:': true
            },
            // protocols that always contain a // bit.
            slashedProtocol = {
              'http': true,
              'https': true,
              'ftp': true,
              'gopher': true,
              'file': true,
              'http:': true,
              'https:': true,
              'ftp:': true,
              'gopher:': true,
              'file:': true
            },
            querystring = require$$0$10;

        function urlParse(url, parseQueryString, slashesDenoteHost) {
          if (url && util.isObject(url) && url instanceof Url) return url;

          var u = new Url;
          u.parse(url, parseQueryString, slashesDenoteHost);
          return u;
        }

        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
          if (!util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
          }

          // Copy chrome, IE, opera backslash-handling behavior.
          // Back slashes before the query string get converted to forward slashes
          // See: https://code.google.com/p/chromium/issues/detail?id=25916
          var queryIndex = url.indexOf('?'),
              splitter =
                  (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
              uSplit = url.split(splitter),
              slashRegex = /\\/g;
          uSplit[0] = uSplit[0].replace(slashRegex, '/');
          url = uSplit.join(splitter);

          var rest = url;

          // trim before proceeding.
          // This is to support parse stuff like "  http://foo.com  \n"
          rest = rest.trim();

          if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = simplePathPattern.exec(rest);
            if (simplePath) {
              this.path = rest;
              this.href = rest;
              this.pathname = simplePath[1];
              if (simplePath[2]) {
                this.search = simplePath[2];
                if (parseQueryString) {
                  this.query = querystring.parse(this.search.substr(1));
                } else {
                  this.query = this.search.substr(1);
                }
              } else if (parseQueryString) {
                this.search = '';
                this.query = {};
              }
              return this;
            }
          }

          var proto = protocolPattern.exec(rest);
          if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
          }

          // figure out if it's got a host
          // user@server is *always* interpreted as a hostname, and url
          // resolution will treat //foo/bar as host=foo,path=bar because that's
          // how the browser resolves relative URLs.
          if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && hostlessProtocol[proto])) {
              rest = rest.substr(2);
              this.slashes = true;
            }
          }

          if (!hostlessProtocol[proto] &&
              (slashes || (proto && !slashedProtocol[proto]))) {

            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c

            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.

            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < hostEndingChars.length; i++) {
              var hec = rest.indexOf(hostEndingChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }

            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
              // atSign can be anywhere.
              atSign = rest.lastIndexOf('@');
            } else {
              // atSign must be in auth portion.
              // http://a@b/c@d => host:b auth:a path:/c@d
              atSign = rest.lastIndexOf('@', hostEnd);
            }

            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
              auth = rest.slice(0, atSign);
              rest = rest.slice(atSign + 1);
              this.auth = decodeURIComponent(auth);
            }

            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < nonHostChars.length; i++) {
              var hec = rest.indexOf(nonHostChars[i]);
              if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                hostEnd = hec;
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1)
              hostEnd = rest.length;

            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);

            // pull out port.
            this.parseHost();

            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';

            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';

            // validate a little.
            if (!ipv6Hostname) {
              var hostparts = this.hostname.split(/\./);
              for (var i = 0, l = hostparts.length; i < l; i++) {
                var part = hostparts[i];
                if (!part) continue;
                if (!part.match(hostnamePartPattern)) {
                  var newpart = '';
                  for (var j = 0, k = part.length; j < k; j++) {
                    if (part.charCodeAt(j) > 127) {
                      // we replace non-ASCII char with a temporary placeholder
                      // we need this to make sure size of hostname is not
                      // broken by replacing non-ASCII by nothing
                      newpart += 'x';
                    } else {
                      newpart += part[j];
                    }
                  }
                  // we test again with ASCII char only
                  if (!newpart.match(hostnamePartPattern)) {
                    var validParts = hostparts.slice(0, i);
                    var notHost = hostparts.slice(i + 1);
                    var bit = part.match(hostnamePartStart);
                    if (bit) {
                      validParts.push(bit[1]);
                      notHost.unshift(bit[2]);
                    }
                    if (notHost.length) {
                      rest = '/' + notHost.join('.') + rest;
                    }
                    this.hostname = validParts.join('.');
                    break;
                  }
                }
              }
            }

            if (this.hostname.length > hostnameMaxLen) {
              this.hostname = '';
            } else {
              // hostnames are always lower case.
              this.hostname = this.hostname.toLowerCase();
            }

            if (!ipv6Hostname) {
              // IDNA Support: Returns a punycoded representation of "domain".
              // It only converts parts of the domain name that
              // have non-ASCII characters, i.e. it doesn't matter if
              // you call it with a domain that already is ASCII-only.
              this.hostname = punycode.toASCII(this.hostname);
            }

            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;

            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
              this.hostname = this.hostname.substr(1, this.hostname.length - 2);
              if (rest[0] !== '/') {
                rest = '/' + rest;
              }
            }
          }

          // now rest is set to the post-host stuff.
          // chop off any delim chars.
          if (!unsafeProtocol[lowerProto]) {

            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = autoEscape.length; i < l; i++) {
              var ae = autoEscape[i];
              if (rest.indexOf(ae) === -1)
                continue;
              var esc = encodeURIComponent(ae);
              if (esc === ae) {
                esc = escape(ae);
              }
              rest = rest.split(ae).join(esc);
            }
          }


          // chop off from the tail first.
          var hash = rest.indexOf('#');
          if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
          }
          var qm = rest.indexOf('?');
          if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
              this.query = querystring.parse(this.query);
            }
            rest = rest.slice(0, qm);
          } else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
          }
          if (rest) this.pathname = rest;
          if (slashedProtocol[lowerProto] &&
              this.hostname && !this.pathname) {
            this.pathname = '/';
          }

          //to support http.request
          if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
          }

          // finally, reconstruct the href based on what has been validated.
          this.href = this.format();
          return this;
        };

        // format a parsed object into a url string
        function urlFormat(obj) {
          // ensure it's an object, and not a string url.
          // If it's an obj, this is a no-op.
          // this way, you can call url_format() on strings
          // to clean up potentially wonky urls.
          if (util.isString(obj)) obj = urlParse(obj);
          if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
          return obj.format();
        }

        Url.prototype.format = function() {
          var auth = this.auth || '';
          if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
          }

          var protocol = this.protocol || '',
              pathname = this.pathname || '',
              hash = this.hash || '',
              host = false,
              query = '';

          if (this.host) {
            host = auth + this.host;
          } else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ?
                this.hostname :
                '[' + this.hostname + ']');
            if (this.port) {
              host += ':' + this.port;
            }
          }

          if (this.query &&
              util.isObject(this.query) &&
              Object.keys(this.query).length) {
            query = querystring.stringify(this.query);
          }

          var search = this.search || (query && ('?' + query)) || '';

          if (protocol && protocol.substr(-1) !== ':') protocol += ':';

          // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
          // unless they had them to begin with.
          if (this.slashes ||
              (!protocol || slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
          } else if (!host) {
            host = '';
          }

          if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
          if (search && search.charAt(0) !== '?') search = '?' + search;

          pathname = pathname.replace(/[?#]/g, function(match) {
            return encodeURIComponent(match);
          });
          search = search.replace('#', '%23');

          return protocol + host + pathname + search + hash;
        };

        function urlResolve(source, relative) {
          return urlParse(source, false, true).resolve(relative);
        }

        Url.prototype.resolve = function(relative) {
          return this.resolveObject(urlParse(relative, false, true)).format();
        };

        function urlResolveObject(source, relative) {
          if (!source) return relative;
          return urlParse(source, false, true).resolveObject(relative);
        }

        Url.prototype.resolveObject = function(relative) {
          if (util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
          }

          var result = new Url();
          var tkeys = Object.keys(this);
          for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
          }

          // hash is always overridden, no matter what.
          // even href="" will remove it.
          result.hash = relative.hash;

          // if the relative url is empty, then there's nothing left to do here.
          if (relative.href === '') {
            result.href = result.format();
            return result;
          }

          // hrefs like //foo/bar always cut to the protocol.
          if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
              var rkey = rkeys[rk];
              if (rkey !== 'protocol')
                result[rkey] = relative[rkey];
            }

            //urlParse appends trailing / to urls like http://www.example.com
            if (slashedProtocol[result.protocol] &&
                result.hostname && !result.pathname) {
              result.path = result.pathname = '/';
            }

            result.href = result.format();
            return result;
          }

          if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!slashedProtocol[relative.protocol]) {
              var keys = Object.keys(relative);
              for (var v = 0; v < keys.length; v++) {
                var k = keys[v];
                result[k] = relative[k];
              }
              result.href = result.format();
              return result;
            }

            result.protocol = relative.protocol;
            if (!relative.host && !hostlessProtocol[relative.protocol]) {
              var relPath = (relative.pathname || '').split('/');
              while (relPath.length && !(relative.host = relPath.shift()));
              if (!relative.host) relative.host = '';
              if (!relative.hostname) relative.hostname = '';
              if (relPath[0] !== '') relPath.unshift('');
              if (relPath.length < 2) relPath.unshift('');
              result.pathname = relPath.join('/');
            } else {
              result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
              var p = result.pathname || '';
              var s = result.search || '';
              result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          }

          var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
              isRelAbs = (
                  relative.host ||
                  relative.pathname && relative.pathname.charAt(0) === '/'
              ),
              mustEndAbs = (isRelAbs || isSourceAbs ||
                            (result.host && relative.pathname)),
              removeAllDots = mustEndAbs,
              srcPath = result.pathname && result.pathname.split('/') || [],
              relPath = relative.pathname && relative.pathname.split('/') || [],
              psychotic = result.protocol && !slashedProtocol[result.protocol];

          // if the url is a non-slashed url, then relative
          // links like ../.. should be able
          // to crawl up to the hostname, as well.  This is strange.
          // result.protocol has already been set by now.
          // Later on, put the first path part into the host field.
          if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
              if (srcPath[0] === '') srcPath[0] = result.host;
              else srcPath.unshift(result.host);
            }
            result.host = '';
            if (relative.protocol) {
              relative.hostname = null;
              relative.port = null;
              if (relative.host) {
                if (relPath[0] === '') relPath[0] = relative.host;
                else relPath.unshift(relative.host);
              }
              relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
          }

          if (isRelAbs) {
            // it's absolute.
            result.host = (relative.host || relative.host === '') ?
                          relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ?
                              relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
          } else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) srcPath = [];
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
          } else if (!util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
              result.hostname = result.host = srcPath.shift();
              //occationaly the auth can get stuck only in host
              //this especially happens in cases like
              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
              var authInHost = result.host && result.host.indexOf('@') > 0 ?
                               result.host.split('@') : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : '') +
                            (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
          }

          if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
              result.path = '/' + result.search;
            } else {
              result.path = null;
            }
            result.href = result.format();
            return result;
          }

          // if a url ENDs in . or .., then it must get a trailing slash.
          // however, if it ends in anything else non-slashy,
          // then it must NOT get a trailing slash.
          var last = srcPath.slice(-1)[0];
          var hasTrailingSlash = (
              (result.host || relative.host || srcPath.length > 1) &&
              (last === '.' || last === '..') || last === '');

          // strip single dots, resolve double dots to parent dir
          // if the path tries to go above the root, `up` ends up > 0
          var up = 0;
          for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === '.') {
              srcPath.splice(i, 1);
            } else if (last === '..') {
              srcPath.splice(i, 1);
              up++;
            } else if (up) {
              srcPath.splice(i, 1);
              up--;
            }
          }

          // if the path is allowed to go above the root, restore leading ..s
          if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
              srcPath.unshift('..');
            }
          }

          if (mustEndAbs && srcPath[0] !== '' &&
              (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
          }

          if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
          }

          var isAbsolute = srcPath[0] === '' ||
              (srcPath[0] && srcPath[0].charAt(0) === '/');

          // put the host back
          if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' :
                                            srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
                             result.host.split('@') : false;
            if (authInHost) {
              result.auth = authInHost.shift();
              result.host = result.hostname = authInHost.shift();
            }
          }

          mustEndAbs = mustEndAbs || (result.host && srcPath.length);

          if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
          }

          if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
          } else {
            result.pathname = srcPath.join('/');
          }

          //to support request.http
          if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') +
                          (result.search ? result.search : '');
          }
          result.auth = relative.auth || result.auth;
          result.slashes = result.slashes || relative.slashes;
          result.href = result.format();
          return result;
        };

        Url.prototype.parseHost = function() {
          var host = this.host;
          var port = portPattern.exec(host);
          if (port) {
            port = port[0];
            if (port !== ':') {
              this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
          }
          if (host) this.hostname = host;
        };
        });

        var require$$3$3 = (url && typeof url === 'object' && 'default' in url ? url['default'] : url);

        var resolve = __commonjs(function (module) {
        'use strict';

        var url = require$$3$3
          , equal = require$$1$7
          , util = require$$6
          , SchemaObject = require$$0$9;

        module.exports = resolve;

        resolve.normalizeId = normalizeId;
        resolve.fullPath = getFullPath;
        resolve.url = resolveUrl;
        resolve.ids = resolveIds;
        resolve.inlineRef = inlineRef;

        /**
         * [resolve and compile the references ($ref)]
         * @this   Ajv
         * @param  {Function} compile reference to schema compilation funciton (localCompile)
         * @param  {Object} root object with information about the root schema for the current schema
         * @param  {String} ref reference to resolve
         * @return {Object|Function} schema object (if the schema can be inlined) or validation function
         */
        function resolve(compile, root, ref) {
          /* jshint validthis: true */
          var refVal = this._refs[ref];
          if (typeof refVal == 'string') {
            if (this._refs[refVal]) refVal = this._refs[refVal];
            else return resolve.call(this, compile, root, refVal);
          }

          refVal = refVal || this._schemas[ref];
          if (refVal instanceof SchemaObject) {
            return inlineRef(refVal.schema, this._opts.inlineRefs)
                    ? refVal.schema
                    : refVal.validate || this._compile(refVal);
          }

          var res = _resolve.call(this, root, ref);
          var schema, v, baseId;
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }

          if (schema instanceof SchemaObject) {
            v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
          } else if (schema) {
            v = inlineRef(schema, this._opts.inlineRefs)
                ? schema
                : compile.call(this, schema, root, undefined, baseId);
          }

          return v;
        }


        /* @this Ajv */
        function _resolve(root, ref) {
          /* jshint validthis: true */
          var p = url.parse(ref, false, true)
            , refPath = _getFullPath(p)
            , baseId = getFullPath(root.schema.id);
          if (refPath !== baseId) {
            var id = normalizeId(refPath);
            var refVal = this._refs[id];
            if (typeof refVal == 'string') {
              return resolveRecursive.call(this, root, refVal, p);
            } else if (refVal instanceof SchemaObject) {
              if (!refVal.validate) this._compile(refVal);
              root = refVal;
            } else {
              refVal = this._schemas[id];
              if (refVal instanceof SchemaObject) {
                if (!refVal.validate) this._compile(refVal);
                if (id == normalizeId(ref))
                  return { schema: refVal, root: root, baseId: baseId };
                root = refVal;
              }
            }
            if (!root.schema) return;
            baseId = getFullPath(root.schema.id);
          }
          return getJsonPointer.call(this, p, baseId, root.schema, root);
        }


        /* @this Ajv */
        function resolveRecursive(root, ref, parsedRef) {
          /* jshint validthis: true */
          var res = _resolve.call(this, root, ref);
          if (res) {
            var schema = res.schema;
            var baseId = res.baseId;
            root = res.root;
            if (schema.id) baseId = resolveUrl(baseId, schema.id);
            return getJsonPointer.call(this, parsedRef, baseId, schema, root);
          }
        }


        var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
        /* @this Ajv */
        function getJsonPointer(parsedRef, baseId, schema, root) {
          /* jshint validthis: true */
          parsedRef.hash = parsedRef.hash || '';
          if (parsedRef.hash.slice(0,2) != '#/') return;
          var parts = parsedRef.hash.split('/');

          for (var i = 1; i < parts.length; i++) {
            var part = parts[i];
            if (part) {
              part = util.unescapeFragment(part);
              schema = schema[part];
              if (!schema) break;
              if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);
              if (schema.$ref) {
                var $ref = resolveUrl(baseId, schema.$ref);
                var res = _resolve.call(this, root, $ref);
                if (res) {
                  schema = res.schema;
                  root = res.root;
                  baseId = res.baseId;
                }
              }
            }
          }
          if (schema && schema != root.schema)
            return { schema: schema, root: root, baseId: baseId };
        }


        var SIMPLE_INLINED = util.toHash([
          'type', 'format', 'pattern',
          'maxLength', 'minLength',
          'maxProperties', 'minProperties',
          'maxItems', 'minItems',
          'maximum', 'minimum',
          'uniqueItems', 'multipleOf',
          'required', 'enum'
        ]);
        function inlineRef(schema, limit) {
          if (limit === false) return false;
          if (limit === undefined || limit === true) return checkNoRef(schema);
          else if (limit) return countKeys(schema) <= limit;
        }


        function checkNoRef(schema) {
          var item;
          if (Array.isArray(schema)) {
            for (var i=0; i<schema.length; i++) {
              item = schema[i];
              if (typeof item == 'object' && !checkNoRef(item)) return false;
            }
          } else {
            for (var key in schema) {
              if (key == '$ref') return false;
              item = schema[key];
              if (typeof item == 'object' && !checkNoRef(item)) return false;
            }
          }
          return true;
        }


        function countKeys(schema) {
          var count = 0, item;
          if (Array.isArray(schema)) {
            for (var i=0; i<schema.length; i++) {
              item = schema[i];
              if (typeof item == 'object') count += countKeys(item);
              if (count == Infinity) return Infinity;
            }
          } else {
            for (var key in schema) {
              if (key == '$ref') return Infinity;
              if (SIMPLE_INLINED[key]) {
                count++;
              } else {
                item = schema[key];
                if (typeof item == 'object') count += countKeys(item) + 1;
                if (count == Infinity) return Infinity;
              }
            }
          }
          return count;
        }


        function getFullPath(id, normalize) {
          if (normalize !== false) id = normalizeId(id);
          var p = url.parse(id, false, true);
          return _getFullPath(p);
        }


        function _getFullPath(p) {
          return (p.protocol||'') + (p.protocol?'//':'') + (p.host||'') + (p.path||'')  + '#';
        }


        var TRAILING_SLASH_HASH = /#\/?$/;
        function normalizeId(id) {
          return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
        }


        function resolveUrl(baseId, id) {
          id = normalizeId(id);
          return url.resolve(baseId, id);
        }


        /* @this Ajv */
        function resolveIds(schema) {
          /* eslint no-shadow: 0 */
          /* jshint validthis: true */
          var id = normalizeId(schema.id);
          var localRefs = {};
          _resolveIds.call(this, schema, getFullPath(id, false), id);
          return localRefs;

          function _resolveIds(schema, fullPath, baseId) {
            /* jshint validthis: true */
            if (Array.isArray(schema)) {
              for (var i=0; i<schema.length; i++)
                _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);
            } else if (schema && typeof schema == 'object') {
              if (typeof schema.id == 'string') {
                var id = baseId = baseId
                                  ? url.resolve(baseId, schema.id)
                                  : schema.id;
                id = normalizeId(id);

                var refVal = this._refs[id];
                if (typeof refVal == 'string') refVal = this._refs[refVal];
                if (refVal && refVal.schema) {
                  if (!equal(schema, refVal.schema))
                    throw new Error('id "' + id + '" resolves to more than one schema');
                } else if (id != normalizeId(fullPath)) {
                  if (id[0] == '#') {
                    if (localRefs[id] && !equal(schema, localRefs[id]))
                      throw new Error('id "' + id + '" resolves to more than one schema');
                    localRefs[id] = schema;
                  } else {
                    this._refs[id] = fullPath;
                  }
                }
              }
              for (var key in schema)
                _resolveIds.call(this, schema[key], fullPath+'/'+util.escapeFragment(key), baseId);
            }
          }
        }
        });

        var require$$7$2 = (resolve && typeof resolve === 'object' && 'default' in resolve ? resolve['default'] : resolve);

        var index$6 = __commonjs(function (module) {
        'use strict';

        var resolve = require$$7$2
          , util = require$$6
          , stableStringify = require$$5
          , async = require$$4;

        var beautify = (function() { try { return require('' + 'js-beautify').js_beautify; } catch(e) {/*empty*/} })();

        var validateGenerator = require$$3$1;

        module.exports = compile;


        /**
         * Compiles schema to validation function
         * @this   Ajv
         * @param  {Object} schema schema object
         * @param  {Object} root object with information about the root schema for this schema
         * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
         * @param  {String} baseId base ID for IDs in the schema
         * @return {Function} validation function
         */
        function compile(schema, root, localRefs, baseId) {
          /* jshint validthis: true, evil: true */
          /* eslint no-shadow: 0 */
          var self = this
            , opts = this._opts
            , refVal = [ undefined ]
            , refs = {}
            , patterns = []
            , patternsHash = {}
            , defaults = []
            , defaultsHash = {}
            , customRules = [];

          root = root || { schema: schema, refVal: refVal, refs: refs };

          var formats = this._formats;
          var RULES = this.RULES;

          return localCompile(schema, root, localRefs, baseId);


          function localCompile(_schema, _root, localRefs, baseId) {
            var isRoot = !_root || (_root && _root.schema == _schema);
            if (_root.schema != root.schema)
              return compile.call(self, _schema, _root, localRefs, baseId);

            var $async = _schema.$async === true;
            if ($async && !opts.transpile) async.setup(opts);

            var sourceCode = validateGenerator({
              isTop: true,
              schema: _schema,
              isRoot: isRoot,
              baseId: baseId,
              root: _root,
              schemaPath: '',
              errSchemaPath: '#',
              errorPath: '""',
              RULES: RULES,
              validate: validateGenerator,
              util: util,
              resolve: resolve,
              resolveRef: resolveRef,
              usePattern: usePattern,
              useDefault: useDefault,
              useCustomRule: useCustomRule,
              opts: opts,
              formats: formats,
              self: self
            });

            sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                           + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                           + sourceCode;

            if (opts.beautify) {
              /* istanbul ignore else */
              if (beautify) sourceCode = beautify(sourceCode, opts.beautify);
              else console.error('"npm install js-beautify" to use beautify option');
            }
            // console.log('\n\n\n *** \n', sourceCode);
            var validate, validateCode
              , transpile = opts._transpileFunc;
            try {
              validateCode = $async && transpile
                              ? transpile(sourceCode)
                              : sourceCode;
              eval(validateCode);
              refVal[0] = validate;
            } catch(e) {
              console.error('Error compiling schema, function code:', validateCode);
              throw e;
            }

            validate.schema = _schema;
            validate.errors = null;
            validate.refs = refs;
            validate.refVal = refVal;
            validate.root = isRoot ? validate : _root;
            if ($async) validate.async = true;
            validate.sourceCode = sourceCode;

            return validate;
          }

          function resolveRef(baseId, ref, isRoot) {
            ref = resolve.url(baseId, ref);
            var refIndex = refs[ref];
            var _refVal, refCode;
            if (refIndex !== undefined) {
              _refVal = refVal[refIndex];
              refCode = 'refVal[' + refIndex + ']';
              return resolvedRef(_refVal, refCode);
            }
            if (!isRoot) {
              var rootRefId = root.refs[ref];
              if (rootRefId !== undefined) {
                _refVal = root.refVal[rootRefId];
                refCode = addLocalRef(ref, _refVal);
                return resolvedRef(_refVal, refCode);
              }
            }

            refCode = addLocalRef(ref);
            var v = resolve.call(self, localCompile, root, ref);
            if (!v) {
              var localSchema = localRefs && localRefs[ref];
              if (localSchema) {
                v = resolve.inlineRef(localSchema, opts.inlineRefs)
                    ? localSchema
                    : compile.call(self, localSchema, root, localRefs, baseId);
              }
            }

            if (v) {
              replaceLocalRef(ref, v);
              return resolvedRef(v, refCode);
            }
          }

          function addLocalRef(ref, v) {
            var refId = refVal.length;
            refVal[refId] = v;
            refs[ref] = refId;
            return 'refVal' + refId;
          }

          function replaceLocalRef(ref, v) {
            var refId = refs[ref];
            refVal[refId] = v;
          }

          function resolvedRef(refVal, code) {
            return typeof refVal == 'object'
                    ? { code: code, schema: refVal, inline: true }
                    : { code: code, async: refVal && refVal.async };
          }

          function usePattern(regexStr) {
            var index = patternsHash[regexStr];
            if (index === undefined) {
              index = patternsHash[regexStr] = patterns.length;
              patterns[index] = regexStr;
            }
            return 'pattern' + index;
          }

          function useDefault(value) {
            switch (typeof value) {
              case 'boolean':
              case 'number':
                return '' + value;
              case 'string':
                return util.toQuotedString(value);
              case 'object':
                if (value === null) return 'null';
                var valueStr = stableStringify(value);
                var index = defaultsHash[valueStr];
                if (index === undefined) {
                  index = defaultsHash[valueStr] = defaults.length;
                  defaults[index] = value;
                }
                return 'default' + index;
            }
          }

          function useCustomRule(rule, schema, parentSchema, it) {
            var compile = rule.definition.compile
              , inline = rule.definition.inline
              , macro = rule.definition.macro;

            var validate;
            if (compile) {
              validate = compile.call(self, schema, parentSchema);
            } else if (macro) {
              validate = macro.call(self, schema, parentSchema);
              if (opts.validateSchema !== false) self.validateSchema(validate, true);
            } else if (inline) {
              validate = inline.call(self, it, rule.keyword, schema, parentSchema);
            } else {
              validate = rule.definition.validate;
            }

            var index = customRules.length;
            customRules[index] = validate;

            return {
              code: 'customRule' + index,
              validate: validate
            };
          }
        }


        function patternCode(i, patterns) {
          return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
        }


        function defaultCode(i) {
          return 'var default' + i + ' = defaults[' + i + '];';
        }


        function refValCode(i, refVal) {
          return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';
        }


        function customRuleCode(i) {
          return 'var customRule' + i + ' = customRules[' + i + '];';
        }


        function vars(arr, statement) {
          if (!arr.length) return '';
          var code = '';
          for (var i=0; i<arr.length; i++)
            code += statement(i, arr);
          return code;
        }


        /*eslint-disable no-unused-vars */

        /**
         * Functions below are used inside compiled validations function
         */

        var co = require$$2$1;

        var ucs2length = util.ucs2length;

        var equal = require$$1$7;

        // this error is thrown by async schemas to return validation errors via exception
        var ValidationError = require$$0$5;

        /*eslint-enable no-unused-vars */
        });

        var require$$13$1 = (index$6 && typeof index$6 === 'object' && 'default' in index$6 ? index$6['default'] : index$6);

        var ajv = __commonjs(function (module) {
        'use strict';

        var compileSchema = require$$13$1
          , resolve = require$$7$2
          , Cache = require$$11$1
          , SchemaObject = require$$0$9
          , stableStringify = require$$5
          , formats = require$$8$1
          , rules = require$$7
          , v5 = require$$6$1
          , util = require$$6
          , async = require$$4
          , co = require$$2$1;

        module.exports = Ajv;

        Ajv.prototype.compileAsync = async.compile;
        Ajv.prototype.addKeyword = require$$2;
        Ajv.ValidationError = require$$0$5;

        var META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';
        var SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i;
        function SCHEMA_URI_FORMAT_FUNC(str) {
          return SCHEMA_URI_FORMAT.test(str);
        }

        var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];

        /**
         * Creates validator instance.
         * Usage: `Ajv(opts)`
         * @param {Object} opts optional options
         * @return {Object} ajv instance
         */
        function Ajv(opts) {
          if (!(this instanceof Ajv)) return new Ajv(opts);
          var self = this;

          opts = this._opts = util.copy(opts) || {};
          this._schemas = {};
          this._refs = {};
          this._formats = formats(opts.format);
          this._cache = opts.cache || new Cache;
          this._loadingSchemas = {};
          this.RULES = rules();

          // this is done on purpose, so that methods are bound to the instance
          // (without using bind) so that they can be used without the instance
          this.validate = validate;
          this.compile = compile;
          this.addSchema = addSchema;
          this.addMetaSchema = addMetaSchema;
          this.validateSchema = validateSchema;
          this.getSchema = getSchema;
          this.removeSchema = removeSchema;
          this.addFormat = addFormat;
          this.errorsText = errorsText;

          this._addSchema = _addSchema;
          this._compile = _compile;

          opts.loopRequired = opts.loopRequired || Infinity;
          if (opts.async || opts.transpile) async.setup(opts);
          if (opts.beautify === true) opts.beautify = { indent_size: 2 };
          if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
          this._metaOpts = getMetaSchemaOptions();

          addInitialSchemas();
          if (opts.formats) addInitialFormats();
          if (opts.v5) v5.enable(this);
          if (typeof opts.meta == 'object') addMetaSchema(opts.meta);


          /**
           * Validate data using schema
           * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
           * @param  {String|Object} schemaKeyRef key, ref or schema object
           * @param  {Any} data to be validated
           * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
           */
          function validate(schemaKeyRef, data) {
            var v;
            if (typeof schemaKeyRef == 'string') {
              v = getSchema(schemaKeyRef);
              if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
            } else {
              var schemaObj = _addSchema(schemaKeyRef);
              v = schemaObj.validate || _compile(schemaObj);
            }

            var valid = v(data);
            if (v.async === true)
              return self._opts.async == '*' ? co(valid) : valid;
            self.errors = v.errors;
            return valid;
          }


          /**
           * Create validating function for passed schema.
           * @param  {Object} schema schema object
           * @return {Function} validating function
           */
          function compile(schema) {
            var schemaObj = _addSchema(schema);
            return schemaObj.validate || _compile(schemaObj);
          }


          /**
           * Adds schema to the instance.
           * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
           * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
           * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
           * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
           */
          function addSchema(schema, key, _skipValidation, _meta) {
            if (Array.isArray(schema)){
              for (var i=0; i<schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);
              return;
            }
            // can key/id have # inside?
            key = resolve.normalizeId(key || schema.id);
            checkUnique(key);
            var schemaObj = self._schemas[key] = _addSchema(schema, _skipValidation, true);
            schemaObj.meta = _meta;
          }


          /**
           * Add schema that will be used to validate other schemas
           * options in META_IGNORE_OPTIONS are alway set to false
           * @param {Object} schema schema object
           * @param {String} key optional schema key
           * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
           */
          function addMetaSchema(schema, key, skipValidation) {
            addSchema(schema, key, skipValidation, true);
          }


          /**
           * Validate schema
           * @param {Object} schema schema to validate
           * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
           * @return {Boolean} true if schema is valid
           */
          function validateSchema(schema, throwOrLogError) {
            var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();
            var currentUriFormat = self._formats.uri;
            self._formats.uri = typeof currentUriFormat == 'function'
                                ? SCHEMA_URI_FORMAT_FUNC
                                : SCHEMA_URI_FORMAT;
            var valid = validate($schema, schema);
            self._formats.uri = currentUriFormat;
            if (!valid && throwOrLogError) {
              var message = 'schema is invalid:' + errorsText();
              if (self._opts.validateSchema == 'log') console.error(message);
              else throw new Error(message);
            }
            return valid;
          }


          function defaultMeta() {
            var meta = self._opts.meta;
            self._opts.defaultMeta = typeof meta == 'object'
                                      ? meta.id || meta
                                      : self._opts.v5
                                        ? v5.META_SCHEMA_ID
                                        : META_SCHEMA_ID;
            return self._opts.defaultMeta;
          }


          /**
           * Get compiled schema from the instance by `key` or `ref`.
           * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
           * @return {Function} schema validating function (with property `schema`).
           */
          function getSchema(keyRef) {
            var schemaObj = _getSchemaObj(keyRef);
            switch (typeof schemaObj) {
              case 'object': return schemaObj.validate || _compile(schemaObj);
              case 'string': return getSchema(schemaObj);
            }
          }


          function _getSchemaObj(keyRef) {
            keyRef = resolve.normalizeId(keyRef);
            return self._schemas[keyRef] || self._refs[keyRef];
          }


          /**
           * Remove cached schema(s).
           * If no parameter is passed all schemas but meta-schemas are removed.
           * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
           * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
           * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
           */
          function removeSchema(schemaKeyRef) {
            switch (typeof schemaKeyRef) {
              case 'undefined':
                _removeAllSchemas(self._schemas);
                _removeAllSchemas(self._refs);
                self._cache.clear();
                return;
              case 'string':
                var schemaObj = _getSchemaObj(schemaKeyRef);
                if (schemaObj) self._cache.del(schemaObj.jsonStr);
                delete self._schemas[schemaKeyRef];
                delete self._refs[schemaKeyRef];
                return;
              case 'object':
                if (schemaKeyRef instanceof RegExp) {
                  _removeAllSchemas(self._schemas, schemaKeyRef);
                  _removeAllSchemas(self._refs, schemaKeyRef);
                  return;
                }
                var jsonStr = stableStringify(schemaKeyRef);
                self._cache.del(jsonStr);
                var id = schemaKeyRef.id;
                if (id) {
                  id = resolve.normalizeId(id);
                  delete self._schemas[id];
                  delete self._refs[id];
                }
            }

          }


          function _removeAllSchemas(schemas, regex) {
            for (var keyRef in schemas) {
              var schemaObj = schemas[keyRef];
              if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
                self._cache.del(schemaObj.jsonStr);
                delete schemas[keyRef];
              }
            }
          }


          function _addSchema(schema, skipValidation, shouldAddSchema) {
            if (typeof schema != 'object') throw new Error('schema should be object');
            var jsonStr = stableStringify(schema);
            var cached = self._cache.get(jsonStr);
            if (cached) return cached;

            shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;

            var id = resolve.normalizeId(schema.id);
            if (id && shouldAddSchema) checkUnique(id);

            if (self._opts.validateSchema !== false && !skipValidation)
              validateSchema(schema, true);

            var localRefs = resolve.ids.call(self, schema);

            var schemaObj = new SchemaObject({
              id: id,
              schema: schema,
              localRefs: localRefs,
              jsonStr: jsonStr
            });

            if (id[0] != '#' && shouldAddSchema) self._refs[id] = schemaObj;
            self._cache.put(jsonStr, schemaObj);

            return schemaObj;
          }


          function _compile(schemaObj, root) {
            if (schemaObj.compiling) {
              schemaObj.validate = callValidate;
              callValidate.schema = schemaObj.schema;
              callValidate.errors = null;
              callValidate.root = root ? root : callValidate;
              if (schemaObj.schema.$async === true)
                callValidate.async = true;
              return callValidate;
            }
            schemaObj.compiling = true;

            var currentOpts;
            if (schemaObj.meta) {
              currentOpts = self._opts;
              self._opts = self._metaOpts;
            }

            var v;
            try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }
            finally {
              schemaObj.compiling = false;
              if (schemaObj.meta) self._opts = currentOpts;
            }

            schemaObj.validate = v;
            schemaObj.refs = v.refs;
            schemaObj.refVal = v.refVal;
            schemaObj.root = v.root;
            return v;


            function callValidate() {
              var _validate = schemaObj.validate;
              var result = _validate.apply(null, arguments);
              callValidate.errors = _validate.errors;
              return result;
            }
          }


          /**
           * Convert array of error message objects to string
           * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
           * @param  {Object} options optional options with properties `separator` and `dataVar`.
           * @return {String} human readable string with all errors descriptions
           */
          function errorsText(errors, options) {
            errors = errors || self.errors;
            if (!errors) return 'No errors';
            options = options || {};
            var separator = options.separator === undefined ? ', ' : options.separator;
            var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

            var text = '';
            for (var i=0; i<errors.length; i++) {
              var e = errors[i];
              if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
            }
            return text.slice(0, -separator.length);
          }


          /**
           * Add custom format
           * @param {String} name format name
           * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
           */
          function addFormat(name, format) {
            if (typeof format == 'string') format = new RegExp(format);
            self._formats[name] = format;
          }


          function addInitialSchemas() {
            if (self._opts.meta !== false) {
              var metaSchema = require$$0$4;
              addMetaSchema(metaSchema, META_SCHEMA_ID, true);
              self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
            }

            var optsSchemas = self._opts.schemas;
            if (!optsSchemas) return;
            if (Array.isArray(optsSchemas)) addSchema(optsSchemas);
            else for (var key in optsSchemas) addSchema(optsSchemas[key], key);
          }


          function addInitialFormats() {
            for (var name in self._opts.formats) {
              var format = self._opts.formats[name];
              addFormat(name, format);
            }
          }


          function checkUnique(id) {
            if (self._schemas[id] || self._refs[id])
              throw new Error('schema with key or id "' + id + '" already exists');
          }


          function getMetaSchemaOptions() {
            var metaOpts = util.copy(self._opts);
            for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
              delete metaOpts[META_IGNORE_OPTIONS[i]];
            return metaOpts;
          }
        }
        });

        var require$$1$2 = (ajv && typeof ajv === 'object' && 'default' in ajv ? ajv['default'] : ajv);

        var types$1 = __commonjs(function (module) {
        /** @file Helper module for typechecking modelingjs functions against
         * json-schema type descriptions.
        /* jslint node:true */
        "use strict";


        /** Helper function for assembling a specification struct, encapsulating a
         * schema fragment and a textual description of the expected value.
         *
         * @param schema {Object}       - JSON-schema
         * @param description {String}  - description of expected value
         * @return {Object}             - specification
         */
        function specification(schema, description) {
            return {
                schema: schema,
                description: description
            }
        }

        var helpers = {
            Null: specification({ "type": "null" }, "null"),
            String: specification({"type": "string"}, "a string"),
            Number: specification({"type": "number"}, "a number"),
            PositiveInteger: specification({
                    "type":    "integer",
                    "minimum": 0,
                    "exclusiveMinimum": true
                }, "a positive integer"),

            /** Convenience method for constructing a specification based on an entity
             * sub-schema inside the parasolid worker geomtry entity schema.
             *
             * @param name {String}     - Name of the entity, e.g, 'point'
             * @return {Object}         - Specification
             */
            Entity: function(name) {
                return specification({ $ref: 'pbw#/entities/' + name}, name + " entity");
            },

            /** Convenience method for constructing a specification based on a type
             * subschema inside the parasolid worker geomtry types schema.
             *
             * @param name {String}     - Name of the type, e.g, 'position'
             * @return {Object}         - Specification
             */
            Type: function(name) {
                return specification({ $ref: 'pbw#/types/' + name}, name);
            },

            /** Construct a specification that will be satisfied if any of the argument
             * specifications are satisfied.
             * @param specifications {...Object}
             * @return {Object}
            */
            AnyOf:function() {
                var args = Array.prototype.slice.call(arguments);
                return specification({
                    "anyOf": args.map(function(s){
                        return s.schema;
                    })
                }, args.map(function(s){
                    return s.description;
                }).join(" or "));
            },

            /** Construct a specification that will be satisfied if the argument
             * specifications is satisfied, or if the value is null/undefined.
             *
             * Note that our validation logic coerces values to be checked from
             * to null.
             *
             * @param sub {Object}
             * @return {Object}
            */
            Maybe: function(sub) {
                return helpers.AnyOf(sub, helpers.Null);
            },

            /** Construct a specificaiton that will be satisified for an array of the
             * sub-schemas.
             * @param sub {Object}
             * @return {Object}
             */
            ArrayOf: function(sub) {
                return specification({
                    "type": "array",
                    "items": sub.schema,
                },
                "array of "+sub.description+"(s)");
            }
        }


        var Ajv = require$$1$2;
        var flux = require$$0$2;

        /** Parses a (subset of) jspaths into components.
         *  @param {string}     path
         *  @return {Array.<string>}  components
        */
        function parsePath(s) {
            if(s[0] !== "#") {
                throw "Expected paths similar to #/foo/bar/baz";
            }
            s = s.substr(2);
            return s.split("/");
        }

        /** From a path, retrieve the equivalent subschema from the pbw schema.
         *  @param {string}     path
         *  @return {object}    subschema
        */
        function getSubSchema(refPath) {
            var components = parsePath(refPath);
            var s = flux.schemas.pbw;
            for (var i = 0; i < components.length; i++) {
                var sub = s[components[i]];
                s = sub;
            }
            return s;
        }

        /** Given a path inside of the pbw schema, walks the schema to determine that
         * path's dimension, if it has one.
         *  @param {string}  subSchema - path to subschema inside pbw schema
         *  @return {string} dimension - dimension for path, or undefined if dimensionless
        */
        function recurseToDimension(subSchema) {
            if (subSchema === undefined) {
                return undefined;
            }
            if (subSchema.$ref !== undefined) {
                return recurseToDimension(getSubSchema(subSchema.$ref));
            }
            if (subSchema.oneOf !== undefined) {
                return recurseToDimension(subSchema.oneOf[0]);
            }
            switch(subSchema.type) {
                // As our units-of-measurement schema does not index into arrays,
                // assume that all items in each array have the same dimension.
                case "array":
                    return recurseToDimension(subSchema.items);
                case "number":
                    return subSchema.fluxDimension;
                // We swallow any sub-objects that might ahve further
                // case "object":
            }
            return undefined;
        }

        /** Looks up field to dimension mapping for entity types.
         * This is a very limited implementation that only supports units scoped a
         * single-field deep, and does not support indexing into composite entities
         * (eg, polycurve and polysurface). It does work for the existing set of
         * entities as described in psworker.json, but extensions to that may require
         * revisiting this implementation.
         *
         *  @param  {string}    typeid  - name of entity type, value for 'primitive' property
         *  @return {object}            - map from field to dimension
         */
        function lookupFieldDimensions(typeid) {
            var schema = flux.schemas.pbw;
            var subSchema = schema.entities[typeid];

            var results = {};
            for (var key in subSchema.properties) {
                var d = recurseToDimension(subSchema.properties[key]);
                if (d !== undefined) {
                    results[key] = d;
                }
            }
            return results;
        }


        // TODO(andrew): consider setting these at a per-project level, rather than
        // hardcoding them.
        var _defaultDimToUnits = {
            "length":"meters",
            "area":"meters*meters",
            "volume":"meters*meters*meters",
            "angle":"degrees"
        };


        /** Looks up default field units
         *
         *  @param  {string}    typeid  - name of entity type, value for 'primitive' property
         *  @return {object}            - map from field to unit, appropriate for setting
         *                                as the "units" field of an entity.
         */
        function defaultUnits(typeid) {
            var dimensions = lookupFieldDimensions(typeid);
            var results;
            for (var key in dimensions) {
                if (results === undefined) {
                    results = {};
                }
                results[key] = _defaultDimToUnits[dimensions[key]];
            }
            return results;
        }

        /** Determines whether or not an entity has units information attached
         *
         *  @param  {object}    entity  - name of entity type, value for 'primitive' property
         *  @return {object}            - map from field to unit, appropriate for setting
         *                                as the "units" field of an entity.
         */
        function detectUnits(entity) {
            // If units are defined, return true
            if (entity.units) {
                return true;
            }

            // Brep entities have implicit units.
            if (entity.primitive === "brep") {
                return true;
            }

            // For polycurve and polysurface entities, loop through subentities;
            if (entity.primitive === "polycurve") {
                for (var i = 0; i < entity.curves.length; i++) {
                    if (detectUnits(entity.curves[i])) {
                        return true;
                    }
                }
            }
            if (entity.primitive === "polysurface") {
                for (var j = 0; j < entity.surfaces.length; j++) {
                    if (detectUnits(entity.surfaces[j])) {
                        return true;
                    }
                }
            }

            return false;
        }

        module.exports = function() {
            var checkerCache = {};

            var ajv = Ajv({ allErrors: true, jsonPointers: true });

            for (var name in flux.schemas) {
                ajv.addSchema(flux.schemas[name], name);
            }

            // Takes a json-schema snippet and returns a function that will validate
            // that it's input matches the given schema, returning null for valid objects,
            // and a list of [dataPath, message] pairs when validation fails.
            var generateChecker = function(name, specification) {
                var key = name + ":" + JSON.stringify(specification);
                if (!(key in checkerCache)) {
                    var validateFn = ajv.compile(specification.schema);

                    checkerCache[key] = function (obj) {
                        // Coerce undefined values to null. This is a little bit
                        // unfortunate, but json-schema does not support undefined
                        // values. For these type checks to support maybe values without
                        // using '|| null' before calling validation functions, we
                        // make this coercion.
                        if(typeof obj === "undefined") {
                            obj = null;
                        }
                        if (!validateFn(obj)) {
                            // This returns only a message generated from the descriptions
                            // of individual object specifications. ajv provides a lot
                            // more detail. However, this detail is overwhelming when
                            // presented in the context of the flow composer. If we find
                            // use-cases for the full detail, we should expose
                            // a light-weight wrapper over ajv's validator that returns
                            // the full set of errors.
                            return "'"+name+"'" + " should be " + specification.description;
                        }
                    };
                }
                return checkerCache[key];
            }

            // Check all expects ["Name", spec, value] args.
            var checkAll = function() {
                var cases = Array.prototype.slice.call(arguments);
                // Each of these may throw.
                // TODO(andrew): consider accumulating errors.
                return cases.map(function(spec) {
                    return generateChecker(spec[0], spec[1]) (spec[2]);
                });
            }

            /**
             * checkAllAndThrow is a convenience wrapper around checkall, which wil
             * throw a SchemaError if any of the passed cases fail.
             *
             * @param {...Array.<Object>} Cases, as [Name, Specification, Value] tuples.
            **/
            var checkAllAndThrow = function() {
                var cases = Array.prototype.slice.call(arguments);
                // TODO(andrew): consider accumulating errors.
                checkAll.apply(undefined, cases).map(
                function(result) {
                    if(result) {
                        throw new Error(result);
                    }
                });
            }

            return {
                generateChecker: generateChecker,
                checkAll: checkAll,
                checkAllAndThrow:checkAllAndThrow,
                helpers: helpers,
                measure: {
                    detectUnits: detectUnits,
                    defaultUnits: defaultUnits,
                    lookupFieldDimensions: lookupFieldDimensions,
                    // TODO(andrew): don't export this symbol; it's messy, and we want
                    // to pass it in per-project, rather than having a single global.
                    _defaultDimToUnits: _defaultDimToUnits
                }
            }
        }
        });

        var require$$1$1 = (types$1 && typeof types$1 === 'object' && 'default' in types$1 ? types$1['default'] : types$1);

        var modeling$1 = __commonjs(function (module) {
        /** @file Helper functions and classes to generate valid JSON queries to Geometry Worker server.
         *  Use {@link scene} as a starting point
         *  @author Igor Baidiuk <ibaidiuk@amcbridge.com>
         */

        /* jslint node:true */

        /***************************************************************************************************
         *  Constructs new instance for current module
         */
        function constructModule(config) {
        "use strict";
        /***************************************************************************************************
         *  Configuration part
         */
        var flux = require$$0$2;
        config = config || {};
        if (typeof config !== 'object') {
            throw new FluxModelingError("config: expected object");
        }


        var flux = require$$0$2;
        var types, s;

        // Skip require for environments that don't support it (rollup)
        if (!config.skip) {
            // If a user of modelingjs is explicitly passing a falsey value for genId,
            // then default to a function that returns undefined, to avoid errors attempting
            // to call a null value downstream.
            var genId =  config['genId'] ||  function () { return undefined; };

            var convertUnits = (function () {
                var registry = 'registry' in config ? config['registry'] : new flux.measure.Registry();
                return registry
                    ? registry.ConvertUnits.bind(registry)
                    : function (obj, dimUnits) { return obj; };
            })();
            types = require$$1$1();
            // Schema helpers
            s = types.helpers;
        }

        var eps = 1e-8;
        var DEFAULT_LINEAR_TOLERANCE = 0.1;
        var DEFAULT_ANGULAR_SIZE     = 30.0;

        var util = require$$0$1;

        /* Converts any array-like object to actual array
           Used mostly with Arguments objects
         */
        function toArray(obj) {
            return Array.prototype.slice.call(obj);
        }

        function notImplemented() {
            throw new FluxModelingError('not implemented');
        }

        function normalize(arr) {
            var m = Math.sqrt(arr[0]*arr[0] + arr[1]*arr[1]  + arr[2]*arr[2]);
            return [arr[0]/m, arr[1]/m, arr[2]/m];
        }

        function xor(l, r) { return l ? !r : r; }
        // Common dump function, returns text representation
        // check for both null and undefined
        function isNone(value) { return value === null || value === undefined; }

        function isInst(value, type) {
            if (!(type instanceof Function))
                throw new FluxModelingError('type: constructor expected');
            if (isNone(value))
                return false;
            return (value instanceof type) || value.constructor == type;
        }

        function initObject(dest, source) {
            if (typeof source !== "object")
                throw new Error("source: expected object");
            if (typeof dest !== "object")
                throw new Error("dest: expected object");
            for (var key in source)
                dest[key] = source[key];
        }

        function mapObject(source, lambda) {
            if (typeof source !== "object")
                throw new Error("source: expected object");
            if (typeof lambda !== "function")
                throw new Error("lambda: expected object");

            var dest = {};
            for (var key in source)
                dest[key] = lambda(key, source[key]);
            return dest;
        }

        //******************************************************************************
        // Resolver becoming kind of scope stuff

        var queryResolver = function () { return undefined; };

        function resolve(item) {
            return queryResolver(item);
        }

        function withResolver(resolver, lambda) {
            var prev = queryResolver;
            queryResolver = resolver;
            try {
                return lambda();
            }
            finally {
                queryResolver = prev;
            }
        }

        //******************************************************************************
        // Type declarations
        //******************************************************************************
        /** Use factory function {@link query}
         *  @class
         *  @classdesc Represents block query as query, with geometrical entities and operations over there
         */
        function Query() {
            this.entities   = {};
            this.operations = [];

            var counter = 1;
            this.generateName = function (prefix) {
                var name = prefix + '@' + counter;
                counter += 1;
                return name;
            };
        }
        /** Creates new query object
         *
         *  @return {Query} new empty query object
         */
        var query = function () { return new Query(); };
        /** Converts Query object to JSON representation
         *  Adds custom-conversion support for {@link JSON.stringify}
         *
         *  @return {*} JSON-ready object
         */
        Query.prototype.toJSON  = function () {
            var ops = dumpOperations(this);
            return {
                Entities:   this.entities,
                Operations: ops
            };
        };
        /* Resolves Entity or Operation object into its name in query
           Entities without a name are assigned with autogenerated name
           Operations without a name return no name and thus expanded in-place

           @param  {Entity|Operation} object - to be resolved
           @param  {number}           index  - index of current operation block, used to block forward lookups
           @return {string}                    item name, if any
         */
        function resolveItem(self, e, opIndex) {
            var key;
            if (e instanceof Entity) {
                Object.keys(self.entities).forEach(function (k) {
                    if (!key && self.entities[k] === e) {
                        key = k;
                    }
                });
                if (!key) {
                    key = self.generateName(e.primitive);
                    self.entities[key] = e;
                }
                return key;
            }
            else if (e instanceof Operation) {
                var ops = self.operations;
                var i;

                // find latest binding
                for (i = opIndex - 1; i >= 0; i -= 1) {
                    var item = ops[i];
                    if (item.operation === e) {
                        key = item.name;
                        break;
                    }
                }
                // check if binding wasn't overridden later
                if (key)
                    for (var j = opIndex - 1; j > i; j -= 1)
                        if (ops[j].name === key)
                            return undefined;

                return key;
            }
        }


        function dumpOperations(self) {
            function resolver(index) {
                return function(e) { return resolveItem(self, e, index); };
            }

            return self.operations.map(
                function (item, index) {
                    return withResolver(
                        resolver(index),
                        function () {
                            return item.toJSON();
                        }
                    );
                }
            );
        }

        /*  @class
            @classdesc Named operation slot
         */
        function OpSlot(name, op) {
            this.name = name;
            this.operation = op;
        }
        OpSlot.prototype.toJSON = function () {
            return {
                name: this.name,
                op:   this.operation.toJSON()
            };
        };

        /** Adds entity/operation to query
         *
         *  @param  {string}             name - name of item being added
         *  @param  {Entity|Operation}   obj  - either entity or operation being added
         *  @return {this}                      this, for chaining
         */
        Query.prototype.add = function(name, obj) {
            if (typeof name !== 'string')
                throw new FluxModelingError('name: string expected');
            if (obj instanceof Entity) {
                if (this.entities[name] !== undefined)
                    throw new FluxModelingError('entity "' + name + '" already defined');
                this.entities[name] = obj;
            }
            else if (obj instanceof Operation) {
                this.operations.push(new OpSlot(name, obj));
            }
            else if (obj.primitive !== undefined) {
                this.add(name, entities.raw(obj));
            }
            else if (Array.isArray(obj)) { // Raw operation
                this.add(name, operations.raw(obj));
            }
            else
                throw new FluxModelingError('obj: either Entity or Operation is expected');
            return this;
        };

        //******************************************************************************
        /** Use factory function {@link dcmScene}
         *  @class
         *  @classdesc Represents block query as scene, with geometrical entities, constraints, variables, equations and operations over there
         */
        function DCMScene() {
            this.entities   = {};
            this.constraints = {};
            this.variables = {};
            this.equations = {};
            this.operations = [];
        }

        // Adds array of elements to scene
        DCMScene.prototype.addMultiple = function (elements) {
            for (var key in elements)
                this.add(elements[key], key);
        };

        /** Creates new scene object
         *  @param  {Object} value - optional, object with entities, constraints, etc.., to initialize scene
         *
         *  @return {DCMScene} new scene object
         */
        var dcmScene = function (value) {
            var scene = new DCMScene();
            if (value) {
                for (var key in value)
                    scene.addMultiple(value[key]);
            }

            return scene;
        };
        /** Converts DCMScene object to JSON representation
         *  Adds custom-conversion support for {@link JSON.stringify}
         *
         *  @return {*} JSON-ready object
         */
        DCMScene.prototype.toJSON  = function () {
            var ops  = dumpDCMOperations(this);
            return {
                Entities:       this.entities,
                Constraints:    this.constraints,
                Variables:      this.variables,
                Equations:      this.equations,
                Operations:     ops
            };
        };

        /* Resolves Entity, Constraint, Variable, Equation or Operation object into its name in query
           Entities, Constraints, Variables and Equations without a name are assigned with guid
           Operations without a name return no name and thus expanded in-place

           @param  {Entity|Constraint|Variable|Equation|Operation}  object to be resolved
           @param  {number}                                         index of current operation block, used to block forward lookups
           @return {string}                                         item name, if any
         */
        function resolveDCMItem(self, e, opIndex) {
            var key;
            if (e instanceof Entity) {
                Object.keys(self.entities).forEach(function (k) {
                    if (!key && self.entities[k] === e) {
                        key = k;
                    }
                });
                if (!key) {
                    key = e.id || genId();
                    self.entities[key] = e;
                }
            }
            else if (e instanceof Operation) {
                var ops = self.operations;
                var i;

                // find latest binding
                for (i = opIndex - 1; i >= 0; i -= 1) {
                    var item = ops[i];
                    if (item.operation === e) {
                        key = item.name;
                        break;
                    }
                }
                // check if binding wasn't overridden later
                if (key)
                    for (var j = opIndex - 1; j > i; j -= 1)
                        if (ops[j].name === key)
                            return undefined;
            }
            return key;
        }

        function dumpDCMOperations(self) {
            function resolver(index) {
                return function (e) { return resolveDCMItem(self, e, index); };
            }

            return self.operations.map(
                function (item, index) {
                    return withResolver(
                        resolver(index),
                        function () {
                            return item.toJSON();
                        }
                    );
                }
            );
        }

        DCMScene.prototype.hasEntity = function (name) {
            return name in this.entities;
        };

        DCMScene.prototype.hasConstraint = function (name) {
            return name in this.constraints;
        };

        DCMScene.prototype.hasVariable = function (name) {
            return name in this.variables;
        };

        DCMScene.prototype.hasEquation = function (name) {
            return name in this.equations;
        };

        // Helper function. Switches all ids in entity fields to new guids
        function updateEntityIds (elem) {
            if (elem) {
                var idFields = ['startId', 'endId', 'originId'];
                idFields.forEach(function(field){
                    if (elem.hasOwnProperty(field)) {
                        elem[field] = genId();
                    }
                });

                // 'id' field is obligatory
                elem.id = genId();
            }

            return elem;
        }

        DCMScene.prototype.updateEntity = function (old) {
            var name = old.id;
            if (!this.hasEntity(name))
                throw new FluxModelingError("Entity " + name + " is not present in scene");
            var e = this.entities[name];
            updateEntityIds(e);
            return e;
        };

        // Generates entities related to given one (e.g. end points
        // of the line), adds them and entity itself to scene
        DCMScene.prototype.addEntity = function(entity, name) {
            var self = this;
            var initId = function (name, value) {
                var nameId = name + 'Id';
                var valueId = entity[nameId];
                if (!self.hasEntity(valueId))
                    self.addEntity(
                        entities.point(value || entity[name], valueId),
                        valueId
                    );
            }

            switch (entity.primitive)
            {
                case 'point':
                case 'curve':
                    // Entity is self-sufficient, so need to add only entity itself
                    break;
                case 'line':
                    initId('start');
                    initId('end');
                    break;
                case 'circle':
                case 'ellipse':
                    initId('origin');
                    break;
                case 'arc':
                    initId('origin', getCircleCenterByThreePoints(entity.start, entity.middle, entity.end));
                    initId('start');
                    initId('end');
                    break;
                case 'polyline':
                case 'polycurve':
                    notImplemented(); // TODO Implement after polyline
                    break;
                default:
                    throw new FluxModelingError("Entity with primitive " + entity.primitive + " can not be added to scene");
            }

            this.entities[name] = entity;
        };
        /** Adds entity/constraint/variable/equation/operation to scene
         *
         *  @param          obj  - either entity, constraint, variable, equation or operation being added
         *  @param {string} name - name of item being added
         *  @return              - this object, for chain of calls
         */
        DCMScene.prototype.add = function(obj, name) {
            name = name || obj.id;
            if (!isInst(name, String))
                throw new FluxModelingError('name: string expected');
            if (isInst(obj, Entity)) {
                if (!this.hasEntity(name))
                    this.addEntity(obj, name);
            }
            else if (isInst(obj, Constraint)) {
                if (this.hasConstraint(name))
                    throw new FluxModelingError('constraint "' + name + '" already defined');
                this.constraints[name] = obj;
            }
            else if (isInst(obj, Variable)) {
                if (this.hasVariable(name))
                    throw new FluxModelingError('variable "' + name + '" already defined');
                this.variables[name] = obj;
            }
            else if (isInst(obj, Equation)) {
                if (this.hasEquation(name))
                    throw new FluxModelingError('equation "' + name + '" already defined');
                this.equations[name] = obj;
            }
            else if (obj.primitive !== undefined) {
                if (!this.hasEntity(name))
                    this.addEntity(entities.raw(obj), name);
            }
            else if (obj.type !== undefined) {
                if (this.hasConstraint(name))
                    throw new FluxModelingError('constraint "' + name + '" already defined');
                this.constraints[name] = constraints.raw(obj);
            }
            else if (obj.name !== undefined && obj.value !== undefined) {
                throw new FluxModelingError('Adding raw variable is not supported');
            }
            else if (obj.equation !== undefined) {
                throw new FluxModelingError('Adding raw equation is not supported');
            }
            else if (isInst(obj, Operation)) {
                this.operations.push(new OpSlot(name, obj));
            }
            else
                throw new FluxModelingError('obj: either Entity, Constraint, Variable, Equation or Operation is expected');
            return this;
        };

        //******************************************************************************
        /** Use functions from {@link entities} to construct
         *  @class
         *  @classdesc Represents entity in Flux protocol. These objects are added to the 'Entities' part of scene
         */
        function Entity(id) { this.primitive = id; }

        /** Add attribute to entity
         *  If first argument is a string, it's treated as attribute type,
         *  and second argument is treated as attribute value.
         *  Otherwise, first argument is treated as full attribute object.
         *  Its type key is retrieved via type() method,
         *  and the whole object is used as attribute value.
         *  See {@link attributes} for known attribute types
         *
         *  @param  {*|string} objkey  - either attribute key (string) or full attribute object (*)
         *  @param  {*}        [value] - raw attribute value
         *  @return {this}               this, for chaining
         */
        Entity.prototype.addAttribute = function(keyobj, value) {
            var key;
            if (typeof(keyobj) === "string")
                key = keyobj;
            else
            {
                key = keyobj.type();
                value = keyobj;
            }

            if (!this.attributes)
                this.attributes = {};
            if (key in this.attributes)
                throw new FluxModelingError("attribute of type '" + key + "' already defined");
            this.attributes[key] = value;
            return this;
        };

        /** Helper function

            @private
            @param  {string}   typeid  - name of entity type, value for 'primitive' property
            @param  {any}      params  - additional parameters of entity
            @param  {function} [OptCtor] - optional, constructor function; {@link Entity} if undefined
            @return {Entity}             Entity or any other type specified by OptCtor
        */
        function primitive(typeid, params, OptCtor) {
            OptCtor = OptCtor || Entity;
            var e = new OptCtor(typeid);
            initObject(e, params);
            e.primitive = typeid;
            e.units = types.measure.defaultUnits(typeid);
            return e;
        }
        /** Helper function to extract point coordinates

            @private
            @param  {any}   obj  - entity or array
            @return {Array}             Coordinate array
        */
        function makeAdjustCoords(primitive, field) {
            return function coords(obj) {
                if (Array.isArray(obj))
                    return obj;

                if (obj !== undefined) {
                    if (obj.units &&
                        obj.units[field] != types.measure._defaultDimToUnits.length) {
                        obj = convertUnits(obj, types.measure._defaultDimToUnits);
                    }

                    if (obj.primitive === primitive) {
                        return obj[field];
                    }
                }
                throw new FluxModelingError("expected array of numbers or " + primitive + " entity");
            };
        }

        var coords = makeAdjustCoords("point", "point");

        function mapCoords(vec) {
            var out = [];
            for (var i = 0, e = vec.length; i < e; ++i)
                out.push(coords(vec[i]));
            return out;
        }

        /** Helper function to extract vector components

            @private
            @param  {any}   obj  - entity or array
            @param  {string} [dimToUnits] - optional, desired units of resulting
                vector. Only used if the input object is an entity, and if this module
                has been init'd with a units of measure registry.
            @return {Array}             Component array
        */

        var vecCoords = makeAdjustCoords("vector", "coords");

        function mapVecCoords(vec) {
            var out = [];
            for (var i = 0, e = vec.length; i < e; ++i)
                out.push(vecCoords(vec[i]));
            return out;
        }

        // Multiply 2 matrices
        function multMatrix(a, b) {
            var len = a.length;

            var c = new Array(len);
            var i;

            var dim = Math.sqrt(len);

            for (i = 0; i < dim; ++i)
                for (var j = 0; j < dim; ++j) {
                    var s = 0;
                    for (var k = 0 ; k < dim; ++k)
                        s += a[i * dim + k] * b[k * dim + j];
                    c[i * dim + j] = s;
                }
            return c;
        }
        // Applies additional affine transform by pre-multiplying
        function applyMatrix(self, m) {
            self.mat = multMatrix(m, self.mat);
            return self;
        }

        /** Use {@link entities.affine} to construct
         *  @class
         *  @extends Entity
         *  @classdesc Entity which represents affine transformation matrix
         */
        function Affine() { Entity.apply(this, arguments); }
        // util.inherit Affine from Entity
        util.inherit(Affine, Entity,
        /** @lends Affine.prototype */
        {
            /** Adds 3D translation
             *  @param  {number[]|Vector} delta - translation vector
             *  @return {this}                    this, for chaining
             */
            translate: function (d) {
                d = vecCoords(d);
                return applyMatrix(this, [
                     1,  0,  0, d[0],
                     0,  1,  0, d[1],
                     0,  0,  1, d[2],
                     0,  0,  0,  1
                ]);
            },
            /** Adds 3D rotation around X axis
             *  @param  {number} phi - rotation angle, in degrees
             *  @return {this}         this, for chaining
             */
            rotateX: function (phi) {
                phi = phi * Math.PI / 180;
                var sin = Math.sin(phi), cos = Math.cos(phi);
                return applyMatrix(this, [
                     1,    0,    0, 0,
                     0,  cos,  sin, 0,
                     0, -sin,  cos, 0,
                     0,    0,    0, 1
                ]);
            },
            /** Adds 3D rotation around Y axis
             *  @param  {number} phi - rotation angle, in degrees
             *  @return {this}         this, for chaining
             */
            rotateY: function (phi) {
                phi = phi * Math.PI / 180;
                var sin = Math.sin(phi), cos = Math.cos(phi);
                return applyMatrix(this, [
                      cos, 0, -sin, 0,
                        0, 1,    0, 0,
                      sin, 0,  cos, 0,
                        0, 0,    0, 1
                ]);
            },
            /** Adds 3D rotation around Z axis
             *  @param  {number} phi - rotation angle, in degrees
             *  @return {this}         this, for chaining
             */
            rotateZ: function (phi) {
                phi = phi * Math.PI / 180;
                var sin = Math.sin(phi), cos = Math.cos(phi);
                return applyMatrix(this, [
                      cos,  sin, 0, 0,
                     -sin,  cos, 0, 0,
                        0,    0, 1, 0,
                        0,    0, 0, 1
                ]);
            },
            /** Adds 3D scaling
             *  @param  {number[]|Vector} scale - scaling vector
             *  @return {this}                    this, for chaining
             */
            scale: function(s) {
                s = vecCoords(s);
                return applyMatrix(this, [
                     s[0],  0,   0,  0,
                       0, s[1],  0,  0,
                       0,   0, s[2], 0,
                       0,   0,   0,  1
                ]);
            },
            /** Rotate around arbitrary vector
             *  @param  {number[]|Vector} axis - rotation axis
             *  @param  {number}          phi  - rotation angle, in degrees
             *  @return {this}                   this, for chaining
             */
            rotateAboutAxis: function (a, phi) {
                phi = phi * Math.PI / 180;
                var sin = Math.sin(phi), cos = Math.cos(phi);
                a = vecCoords(a);
                a = normalize(a);
                var x = a[0], y = a[1], z = a[2];
                return applyMatrix(this, [
                    cos+x*x*(1-cos),    x*y*(1-cos)-z*sin, y*sin+x*z*(1-cos),  0,
                    z*sin+x*y*(1-cos),  cos+y*y*(1-cos),   -x*sin+y*z*(1-cos), 0,
                    -y*sin+x*z*(1-cos), x*sin+y*z*(1-cos), cos+z*z*(1-cos),    0,
                    0,                  0,                 0,                  1
                ]);
            },
            /** Reflect against specified plane
             *  @param  {number[]|Point} normal - plane's normal vector
             *  @param  {number[]|Point} origin - in-plane point
             *  @return {this}        this, for chaining
             */
            reflect: function (n, p) {
                n = vecCoords(n);
                p = coords(p);
                var nx = n[0], ny = n[1], nz = n[2],
                    px = p[0], py = p[1], pz = p[2];

                var len = Math.sqrt(nx*nx + ny*ny + nz*nz);
                nx /= len; ny /= len; nz /= len;

                var d = -nx * px - ny * py - nz * pz;

                return applyMatrix(this, [
                    1.0 - 2 * nx * nx,  -2 * nx * ny,       -2 * nx * nz,       -2 * nx * d,
                    -2 * nx * ny,       1.0 - 2 * ny * ny,  -2 * ny * nz,       -2 * ny * d,
                    -2 * nx * nz,       -2 * ny * nz,       1.0 - 2 * nz * nz,  -2 * nz * d,
                    0,                  0,                  0,                  1
                ]);
            },

            /** Compose with another transformation
             *  @param {affine} t - transformation to compose with.
             */
             compose: function (t) {
                return applyMatrix(this, t.mat);
             }
        });

        function appendToField(field) {
            return function() {
                var self = this;
                toArray(arguments).forEach(function (i) {
                    self[field].push(i);
                });
                return this;
            };
        }
        // Transforms incoming data item to 'canonical' weighted vertex form
        // Canonical form is a 2-element array, with first element being 3-element array with point coordinates
        // and second being either weight noumber or 'undefined'
        //
        // Supported forms are:
        // 1. 3-number array  - unweighted
        // 2. 4-number array  - weighted
        // 3. Point           - unweighted
        // 4. [Point]         - unweighted
        // 5. [Point, number] - weighted
        // 6. Point.toJSON()  - unweighted
        function canonicVertex(item) {
            if (Array.isArray(item)) {       // one of array cases
                if (item.length == 1)
                    // repr #4 - unpack single array element and try to treat it as item
                    return canonicVertex(item[0]);
                if (item.length == 2)
                    // repr #5
                    return [coords(item[0]), item[1]];
                if (item.length == 3)
                    // repr #1
                    return [item, undefined];
                if (item.length == 4)
                    // repr #2
                    return [item.slice(0, 3), item[3]];
            }
            else if (item.primitive === "point") // Point case
                // repr #3, #6
                return [coords(item), undefined];
            // Didn't match anything, so just throw
            throw new FluxModelingError("Unsupported vertex representation");
        }

        function appendVertex(ctxt, item) {
            item = canonicVertex(item);
            var pt = item[0], w = item[1];

            if (ctxt.weights === undefined) {
                if (w !== undefined) {
                    if (ctxt.points.length === 0)
                        ctxt.weights = [ w ];
                    else
                        throw new FluxModelingError('Cannot add weighted vertex because previous vertices were weightless');
                }
                ctxt.points.push(pt);
            }
            else {
                if (w === undefined)
                    throw new FluxModelingError('Vertex must have weight specified');
                ctxt.weights.push(w);
                ctxt.points.push(pt);
            }
            // NB: case where points are empty, and weights are not, isn't an error - because weights are in a linear array, and points aren't always
        }

        //******************************************************************************
        /** Use functions from {@link constraints} to construct
         *  @class
         *  @classdesc Represents constraint in Flux protocol. These objects are added to the 'Constraints' part of scene
         */
        function Constraint(id) { this.type = id; }

        /** Helper function

            @private
            @param  {string}   typeid  - name of constraint type, value for 'type' property
            @param  {any}      params  - additional parameters of constraint
            @return {Constraint}         Constraint
        */
        function type(typeid, params) {
            var e = new Constraint(typeid);
            initObject(e, params);
            e.type = typeid;
            e.id = genId();
            return e;
        }

        //******************************************************************************
        /** Use functions from {@link variables} to construct
         *  @class
         *  @classdesc Represents variable in Flux protocol. These objects are added to the 'Variables' part of scene
         */
        function Variable() {}

        /** Helper function

            @private
            @param  {any}      params - parameters of variable
            @return {Variable}          Variable
        */
        function variable(params) {
            var v = new Variable();
            initObject(v, params);
            v.id = genId();
            return v;
        }

        //******************************************************************************
        /** Use functions from {@link equations} to construct
         *  @class
         *  @classdesc Represents equation in Flux protocol. These objects are added to the 'Equations' part of scene
         */
        function Equation() {}

        /** Helper function

            @private
            @param  {any}      params - parameters of equation
            @return {Equation}          Equation
        */
        function equation(params) {
            var e = new Equation();
            initObject(e, params);
            e.id = genId();
            return e;
        }

        //******************************************************************************
        /** Use functions from {@link operations} to construct
         *  @class
         *  @classdesc Encapsulates info about operation in DCM/Parasolid Worker protocol
         */
        function Operation(id) {
            this.opcode = id;
        }
        /** Converts operation body to JSON
            Adds support for {@link JSON.stringify}

            @return {*} JSON-ready object
         */
        Operation.prototype.toJSON = function () {
            var r = (this.args || []).map(function (item) {
                if (item instanceof Operation)
                    return resolve(item) || item.toJSON();
                if (item instanceof Entity) { // locate bound entity by name
                    var entity = resolve(item);
                    if (!entity)
                        throw Error("Failed to resolve entity");
                    return entity;
                }
                if (item.primitive !== undefined) {
                    var entity = resolve(entities.raw(item));
                    if (!entity)
                        throw Error("Failed to resolve entity-like object");
                    return entity;
                }

                return item;
            });
            r.unshift(this.opcode);
            return r;
        };
        // Helper, generates operation factory
        function op(id, nargs) {
            return function() {
                var r = new Operation(id);
                r.args = toArray(arguments).slice(0, nargs);
                return r;
            };
        }
        //******************************************************************************
        // Attributes
        //******************************************************************************

        /** Use {@link attributes.material} to construct
         *  @class
         *  @classdesc Material attribute
         */
        function Material() { }
        /** @lends Material.prototype */
        Material.prototype = {
            constructor: Material,
            /** Returns "material" for attribute type name
             *  @return {string} "material"
             */
            type: function() { return "material"; },
            /** Converts material to JSON object. Adds support for {@link JSON.stringify}
             *  @return {*} JSON-ready object
             */
            toJSON: function() {
                return {
                    ambient:  this.ambient,
                    diffuse:  this.diffuse,
                    specular: this.specular,
                    power:    this.power
                };
            },
            /** Sets ambient, diffuse and specular color values
             *
             *  @function
             *  @param  {number} - red
             *  @param  {number} - green
             *  @param  {number} - blue
             *  @return {this}     this, for chaining
             */
            setColor: function (r, g, b) {
                return this.setAmbient(r, g, b).setDiffuse(r, g, b).setSpecular(r, g, b).setPower(1);
            },
            /** Sets ambient color
             *
             *  @function
             *  @param  {number} - red
             *  @param  {number} - green
             *  @param  {number} - blue
             *  @return {this}     this, for chaining
             */
            setAmbient: function (r, g, b) {
                this.ambient = [r, g, b];
                return this;
            },
            /** Sets specular color
             *
             *  @function
             *  @param  {number} - red
             *  @param  {number} - green
             *  @param  {number} - blue
             *  @return {this}     this, for chaining
             */
            setSpecular: function (r, g, b) {
                this.specular = [r, g, b];
                return this;
            },
            /** Sets diffuse color
             *
             *  @function
             *  @param  {number} - red
             *  @param  {number} - green
             *  @param  {number} - blue
             *  @return {this}     this, for chaining
             */
            setDiffuse: function (r, g, b) {
                this.diffuse = [r, g, b];
                return this;
            },
            /** Sets specular power
             *
             *  @function
             *  @param  {number} power
             *  @return {this}   this, for chaining
             */
            setPower: function (s) {
                this.power = s;
                return this;
            }
        };

        var attributes =
        /** Attribute constructors.
         *  Attributes are added to entities via {@link Entity#attribute Entity.addAttribute}
         *  @namespace attributes
         */
        {
            /** Constructs material attribute
             *  @function
             *  @return {Material}
             */
            material: function () { return new Material(); }
        };

        /** Sets entity attribute on either a list of entities, raw object or instance of entity.
         *
         *  @function
         *  @param  {entity} entity - entity to modify
         *  @param  {string} property   - property
          *  @param  {*} value   - value
         *  @return {*}                 - entity with attribute set
         */
        var setEntityAttribute = function(entity, property, value) {
            if (Array.isArray(entity)) {
                return entity.map(function(elt) {
                    setEntityAttribute(elt, property, value);
                });
            }
            if (!(entity instanceof Entity))
                entity = entities.raw(entity);

            return entity.addAttribute(property, value);
        };

        /** Gets entity attribute on either raw object or instance of entity.
         *
         *  @function
         *  @param  {Entity} entity - entity to query
         *  @param  {string} property   - property
         *  @return {*}                 - attribute value
         */
        var getEntityAttribute = function(entity, property) {
            if (Array.isArray(entity)) {
                return entity.map(function(elt) {
                    getEntityAttribute(elt, property);
                });
            }
            return (entity.attributes || {})[property];
        };

        //******************************************************************************
        // Utilities
        //******************************************************************************
        var utilities = {
            coords:coords,
            vecCoords:vecCoords,
            setEntityAttribute: setEntityAttribute,
            getEntityAttribute: getEntityAttribute,
        };

        //******************************************************************************
        // Entities
        //*****************************∂chec*************************************************
        // var entities is used for self-call
        var entities =
        /** Entity constructors
         *  @namespace entities
         */
        {
            //******************************************************************************
            // Raw entity, specified directly as JSON
            //******************************************************************************
            /** Constructs entity object from raw data. No checks for primitive value, body being object etc.
             *
             *  @param  {*}      body - any JavaScript value
             *  @return {Entity}
             */
            raw: function(body) {
                var e = new Entity(body.primitive);
                initObject(e, body);
                return e;
            },

            //******************************************************************************
            // Vector entity
            //******************************************************************************

            /** Constructs Vector entity
             *
             *  @function
             *  @param  {number[]|Vector} coords - vector coordinates
             *  @return {Vector}
             */
            vector: function (vec) {
                types.checkAllAndThrow(
                    ["Components", s.AnyOf(s.Type("position"), s.Entity("vector")), vec])
                return primitive('vector', { coords: vecCoords(vec) });
            },

            //******************************************************************************
            // Point entity
            //******************************************************************************

            /** Constructs point entity
             *
             *  @function
             *  @param  {number[]|Point} point - array with point coordinates
             *  @param  {string}         [id]   - optional, entity id
             *  @return {Point}
             */
            point: function (point, id) {
                types.checkAllAndThrow(
                    ["Point", s.AnyOf(s.Type("position"), s.Entity("point")), point],
                    ["Id", s.Maybe(s.String), id]);
                return primitive('point', {
                    point: coords(point),
                    id: id || genId()
                });
            },

            //******************************************************************************
            // Wire entities
            //******************************************************************************

            /** Constructs line entity
             *
             *  @function
             *  @param  {number[]|Point} start - starting point
             *  @param  {number[]|Point} end   - end point
             *  @param  {string}         [id]  - optional, entity id
             *  @return {Wire}          line entity
             */
            line: function (start, end, id) {
                types.checkAllAndThrow(
                    ["Start", s.AnyOf(s.Type("position"), s.Entity("point")), start],
                    ["End", s.AnyOf(s.Type("position"), s.Entity("point")), end],
                    ["Id", s.Maybe(s.String), id ]);
                return primitive('line', {
                    start:   coords(start),
                    end:     coords(end),
                    startId: start.id || genId(),
                    endId:   end.id || genId(),
                    id:      id || genId()
                });
            },
            /** Constructs polyline entity
             *
             *  @function
             *  @param  {...number[]|Point} point - a set of points forming polyline
             *  @return {Wire}                      polyline entity
             */
             // TODO(andrew): add typechecking to polyline. Consider passing an array of
             // of points as a single arguement, rather than processing the array of
             // arguments.
            polyline: function() {
                return primitive('polyline', {
                    points: mapCoords(arguments)
                });
            },
            /** Constructs arc entity
             *
             *  @function
             *  @param  {number[]|Point}    start  - start point
             *  @param  {number[]|Point}    middle - middle point
             *  @param  {number[]|Point}    end    - end point
             *  @param  {string}            [id]   - optional, entity id
             *  @return {Wire}              arc entity
             */
            arc: function (start, middle, end, id) {
                types.checkAllAndThrow(
                    ["Start", s.AnyOf(s.Type("position"), s.Entity("point")), start],
                    ["Middle", s.AnyOf(s.Type("position"), s.Entity("point")), middle],
                    ["End", s.AnyOf(s.Type("position"), s.Entity("point")), end],
                    ["Id", s.Maybe(s.String), id]);
                return primitive('arc', {
                    start:    coords(start),
                    middle:   coords(middle),
                    end:      coords(end),
                    startId:  start.id || genId(),
                    endId:    end.id || genId(),
                    originId: genId(),
                    id:       id || genId()
                });
            },
            /** Constructs NURBS curve entity
             *
             *  @function
             *  @param  {number} degree - curve's NURBS degree
             *  @param  {string} [id]   - optional, entity id
             *  @return {Curve}           curve entity
             */
            curve: function(degree, controlPoints, knots, weights, id) {
                types.checkAllAndThrow(
                    ["Degree", s.PositiveInteger, degree],
                    ["ControlPoints", s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position"))), controlPoints],
                    ["Knots", s.ArrayOf(s.Number), knots],
                    ["Weights", s.Maybe(s.ArrayOf(s.Number)), weights],
                    ["Id", s.Maybe(s.String), id]);

                if (knots.length != controlPoints.length + degree + 1) {
                    throw Error("Expect number of input knots (" + knots.length +
                        ") to equal the number of control points (" + controlPoints.length +
                        ") the degree of the curve (" + degree +
                        ")+ 1, which is "+(controlPoints.length + degree + 1));
                }

                if (weights && weights.length != controlPoints.length) {
                    throw Error("Expect weights to have length (got "+ weights.length +
                                ") that is the same as controlPoints (got " + controlPoints.Length +
                                ").");
                }

                return primitive('curve', {
                    degree: degree,
                    knots: knots,
                    controlPoints: mapCoords(controlPoints),
                    weights: weights,
                    id: id || genId()
                });
            },
            /** Constructs circle entity
             *
             *  @function
             *  @param  {number[]|Point}    center - circle center
             *  @param  {number}            r      - radius
             *  @param  {string}            [id]   - optional, entity id
             *  @return {Wire}            circle entity
             */
            circle: function (center, r, id) {
                types.checkAllAndThrow(
                    ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
                    ["Radius", s.Type("distance"), r],
                    ["Id", s.Maybe(s.String), id]);
                return primitive('circle', {
                    origin:   coords(center),
                    originId: center.id || genId(),
                    radius:   r,
                    id:       id || genId()
                });
            },
            /** Constructs ellipse entity
             *
             *  @function
             *  @param  {number[]|Point}  center
             *  @param  {number}          majorRadius - major radius
             *  @param  {number}          minorRadius - minor radius
             *  @param  {number[]|Vector} dir    - major direction
             *  @param  {string}          [id]   - optional, entity id
             *  @return {Wire}
             */
            ellipse: function (center, majorRadius, minorRadius, direction, id) {
                types.checkAllAndThrow(
                    ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
                    ["MajorRadius", s.Type("distance"), majorRadius],
                    ["MinorRadius", s.Type("distance"), minorRadius],
                    ["Direction", s.AnyOf(s.Type("position"), s.Entity("vector")), direction],
                    ["Id", s.Maybe(s.String), id]);
                return primitive('ellipse', {
                    origin:      coords(center),
                    originId:    center.id || genId(),
                    majorRadius: majorRadius,
                    minorRadius: minorRadius,
                    direction:   (direction ? vecCoords(direction) : undefined),
                    id:          id || genId()
                });
            },
            /** Constructs rectangle entity
             *
             *  @function
             *  @param  {number[]|Point}  center
             *  @param  {number[]|Vector} span - length of the rectangle along its local x and y axes
             *  @return {Wire}
             */
            rectangle: function (center, span) {
                types.checkAllAndThrow(
                    ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
                    ["Span", s.AnyOf(s.ArrayOf(s.Number), s.Entity("vector")), span]);
                var c = vecCoords(span);
                if (c.length != 2) {
                    throw new FluxModelingError("Expected rectangle dimensions to be 2-dimensional.");
                }
                return primitive('rectangle', { origin: coords(center), dimensions: c });
            },
            /** Constructs polycurve entity
             *
             *  Polycurve may represent any wire body, including non-manifold and disjoint
             *
             *  @function
             *  @param  {Wire[]}  curves
             *  @return {Wire}
             */
            polycurve: function (curves) {
                types.checkAllAndThrow(
                    ["Curves", s.ArrayOf(s.Entity("curve")), curves]);
                return primitive('polycurve', { curves: curves });
            },

            //******************************************************************************
            // Sheet entities
            //******************************************************************************

            /** Constructs NURBS surface
             *
             *  @function
             *  @param  {number}  uDegree - NURBS degree along U parameter
             *  @param  {number}  vDegree - NURBS degree along V parameter
             *  @return {Surface}           NURBS surface entity
             */
            surface: function(uDegree, vDegree, controlPoints, uKnots, vKnots, weights) {
                types.checkAllAndThrow(
                    ["UDegree", s.PositiveInteger, uDegree],
                    ["VDegree", s.PositiveInteger, vDegree],
                    ["ControlPoints", s.ArrayOf(
                        s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position")))), controlPoints],
                    ["UKnots", s.ArrayOf(s.Number), uKnots],
                    ["VKnots", s.ArrayOf(s.Number), vKnots],
                    ["Weights", s.Maybe(s.ArrayOf(s.ArrayOf(s.Number))), weights]);
                var M = controlPoints.length;
                var N = controlPoints[0].length;

                if (uKnots.length != M + uDegree + 1) {
                    throw Error("In the u-direction, expect number of input knots (" + uKnots.length +
                        ") to equal the number of control points (" + M +
                        ") the degree of the curve (" + uDegree +
                        ") + 1, which is "+ (M + uDegree + 1));
                }
                if (vKnots.length != N + vDegree + 1) {
                    throw Error("In the v-direction, expect number of input knots (" + vKnots.length +
                        ") to equal the number of control points (" + N +
                        ") the degree of the curve (" + vDegree +
                        ") + 1, which is "+ (N + vDegree + 1));
                }

                // Check that all rows have the right length and unpack point entities
                // into their coordinate vectors.
                for (var i = 0; i < controlPoints.length; i++) {
                    var row = controlPoints[i];
                    if(row.length != N) {
                        throw Error("Not all rows of control points are of equal length. Got " + row.length +
                            " but expected " + N);
                    }
                    controlPoints[i] = mapCoords(row);
                }

                // TODO(andrew): assert that weights have the same shape as controlPoints.

                return primitive('surface', {
                    uDegree: uDegree,
                    vDegree: vDegree,
                    uKnots: uKnots,
                    vKnots: vKnots,
                    controlPoints: controlPoints,
                    weights: weights
                });
            },
            /** Constructs polysurface entity
             *
             *  Polysurface may represent any sheet or solid body, including non-manifold and disjoint
             *
             *  @function
             *  @param  {Sheet[]}  surfaces
             *  @return {Sheet}
             */
            polysurface: function (surfaces) {
                types.checkAllAndThrow(
                    ["Surfaces", s.ArrayOf(s.Entity("surface")), surfaces]);
                return primitive('polysurface', { surfaces: surfaces });
            },

            //******************************************************************************
            // Solid entities
            //******************************************************************************

            /** Constructs 3D mesh
             *
             *  @function
             *  @return {Mesh} mesh entity
             */
            mesh: function (vertices, faces) {
                types.checkAllAndThrow(
                    ["Vertices", s.ArrayOf(s.AnyOf(s.Entity("point"), s.Type("position"))), vertices],
                    ["Faces", s.ArrayOf(s.ArrayOf(s.Type("index"))), faces]);
                return primitive('mesh', { vertices: mapCoords(vertices), faces: faces });
            },
            /** Constructs 3D solid block
             *
             *  @function
             *  @param  {number[]|Point}  center
             *  @param  {number[]|Vector} dimensions - block dimensions along axes
             *  @return {Solid}
             */
            block: function (center, span) {
                types.checkAllAndThrow(
                    ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), center],
                    ["Dimensions", s.AnyOf(s.Type("position"), s.Entity("vector")), span]);
                return primitive('block', { origin: coords(center), dimensions: vecCoords(span) });
            },

            /** Constructs sphere
             *
             *  @function
             *  @param  {number[]|Point} center
             *  @param  {number}         radius
             *  @return {Solid}
             */
            sphere: function (c, r) {
                types.checkAllAndThrow(
                    ["Center", s.AnyOf(s.Type("position"), s.Entity("point")), c],
                    ["Radius", s.Type("distance"), r]);
                return primitive('sphere', { origin: coords(c), radius: r });
            },

            //******************************************************************************
            // Other entities
            //******************************************************************************
            /** Constructs affine transformation matrix
             *
             *  @function
             *  @param  {number[]} [matrix] - initial matrix, default is identity matrix
             *  @return {Affine}              affine transformation matrix entity
             */
            affine: function (optMatrix) {
                optMatrix = optMatrix || [
                     1, 0, 0, 0 ,
                     0, 1, 0, 0 ,
                     0, 0, 1, 0 ,
                     0, 0, 0, 1
                ];
                types.checkAllAndThrow(
                    ["Matrix", s.ArrayOf(s.Number), optMatrix])
                return primitive('affineTransform', { mat: optMatrix }, Affine);
            },
            /** Constructs infinite plane
             *
             *  @function
             *  @param  {number[]|Point}  origin - in-plane point
             *  @param  {number[]|Vector} normal - plane's normal vector
             *  @return {Plane}
             */
            plane: function (o, n) {
                types.checkAllAndThrow(
                    ["Origin", s.AnyOf(s.Type("position"), s.Entity("point")), o],
                    ["Normal", s.AnyOf(s.Type("position"), s.Entity("vector")), n]);
                return primitive('plane', {
                    origin: coords(o),
                    normal: vecCoords(n)
                })
            }
        };

        //******************************************************************************
        // Constraints
        //******************************************************************************
        // Helper functions to create json constraints
        function constr1(e) {
            return { entity1: e.id };
        }
        function valueConstr1(val, e) {
            return { value: val, entity1: e.id };
        }
        function constr2(e1, e2) {
            return { entity1: e1.id, entity2: e2.id };
        }
        function valueConstr2(val, e1, e2) {
            return { value: val, entity1: e1.id, entity2: e2.id };
        }
        function helpConstr2(e1, e2, h1, h2) {
            return { entity1: e1.id, entity2: e2.id, help1: h1, help2: h2 };
        }
        function helpParamsConstr2(e1, e2, p1, p2) {
            return { entity1: e1.id, entity2: e2.id, helpParam1: p1, helpParam2: p2 };
        }
        function valueHelpConstr2(val, e1, e2, h1, h2) {
            return { value: val, entity1: e1.id, entity2: e2.id, help1: h1, help2: h2 };
        }
        function constr3(e1, e2, e3) {
            return { entity1: e1.id, entity2: e2.id, entity3: e3.id };
        }
        function help(param) {
            if (arguments.length !== 1)
                throw new FluxModelingError("Invalid help parameter " + JSON.stringify(arguments));
            if (Array.isArray(param)) {
                if(param.length !== 0 && param.length !== 3) {
                    throw new FluxModelingError("Invalid help point " + JSON.stringify(param));
                }
                return param;
            }
            if (typeof param !== 'number')
                throw new FluxModelingError("Invalid help parameter " + JSON.stringify(param));
            return [param];
        }
        // var constraints is used for self-call
        var constraints =
            /** Constraint constructors
            *  @namespace constraints
            */
        {
            //******************************************************************************
            // Raw constraint, specified directly as JSON
            //******************************************************************************
            /** Constructs constraint object from raw data. No checks for type value, body being object etc.
             *
             *  @param  {*}      body - any JavaScript value
             *  @return {Constraint}
             */
            raw: function(body) {
                var c = new Constraint(body.type);
                initObject(c, body);
                return c;
            },
            /** Constructs parallel constraint
             *  Defined only for geometries with a direction
             *  It implies that the directions of the geometries are parallel
             *
             *  @function
             *  @param  {Entity} e1     - first entity
             *  @param  {Entity} e2     - second entity
             *  @return {Constraint}      parallel constraint
             */
            parallel: function(e1, e2) {
                return type('parallel', constr2(e1, e2));
            },
            /** Constructs radius constraint
             *  Defined only for circles
             *
             *  @function
             *  @param  {Entity} val    - circle radius value
             *  @param  {Entity} e      - circle entity
             *  @return {Constraint}      radius constraint
             */
            radius: function(val, e) {
                return type('radius', valueConstr1(val, e));
            }
        };
        // Operations
        //******************************************************************************
        var ops =
        /** Operation constructors
         *  This documentation isn't precise on argument and result types,
         *  because functions listed here effectively create operation objects.
         *  So functions here are documented in terms of types
         *  these operations require as arguments and produce as results.
         *  Due to operation nesting and use of direct string identifiers,
         *  each of these functions can receive {@link string}, {@link Operation}
         *  along with types listed in parameter description.
         *  And each of these functions produces {@link Operation} object.
         *  @namespace operations
         */
        {
            /** identity pseudo-operation
             *  Returns its single argument
             *  Used in cases where some entity should be directly mapped to output
             *
             *  @function
             *  @param  {Entity} entry - any entity
             *  @return {Entity}       - entry, unchanged
             */
            identity: function(entry) {
                var r = new Operation('identity');
                r.args = [entry];
                r.toJSON = function () {
                    return Operation.prototype.toJSON.call(this)[1];
                };
                return r;
            },
            /** 'list' operation
             *  Accepts arbitrary list of entity/operation arguments
             *  @function
             *  @param  {...Entity} arg - any entity or operation
             *  @return {Entity[]}        list of entities
             */
            list: function() {
                var r = new Operation('list');
                r.args = toArray(arguments);
                return r;
            },
            /** 'repr' operation
             *  Produces Brep object in desired format.
             *  "content" field, which contains actual data, may be zip-packed and base64 encoded
             *  You cannot enable compression and disable base64-coding
             *  Format identifiers supported:
             *  - "x_b":  Parasolid binary format
             *  - "x_t":  Parasolid textual format
             *  - "iges": IGES format
             *  - "step": STEP
             *  - "sat":  SAT
             *  @function
             *  @param  {string}                    format identifier
             *  @param  {Entity}                    entity which should be converted to BREP
             *  @param  {boolean} [is_compressed] - compress content data stream or not, default false
             *  @param  {boolean} [is_base64]     - encode content data stream as base-64 or not, default true
             *  @return {Entity}  BREP
             */
            repr: op('repr', 4),
            /** 'raw' operation
             *  Accepts operation name and variadic list of its arguments directly
             *  Use with caution, only when you know what you do
             *  @function
             *  @param  {string}    name - operation identifier
             *  @param  {...Entity} arg  - any entity or operation
             *  @return {Entity[]}         list of entities
             */
            raw: function() {
                var r = new Operation(arguments[0]);
                r.args = toArray(arguments).slice(1);
                return r;
            },
            /** 'union' operation
             *  Computes union of two geometries
             *  @function
             *  @param  {Sheet|Solid} left
             *  @param  {Sheet|Solid} right
             *  @return {Mesh}        union result
             */
            unite: op('union', 2),
            /** 'intersection' operation
             *  Computes intersection of two geometries
             *  @function
             *  @param  {Sheet|Solid} left
             *  @param  {Sheet|Solid} right
             *  @return {Mesh}        intersection result
             */
            intersect: op('intersection', 2),
            /** 'difference' operation
             *  Subtracts right geometry from the left one
             *  @function
             *  @param  {Sheet|Solid} left  - entity to subtract from
             *  @param  {Sheet|Solid} right - entity being subtracted from left
             *  @return {Mesh}                subtraction result
             */
            subtract: op('difference', 2),
            /** 'evalDist' operation
             *  Computes distance between two geometries
             *  @function
             *  @param  {Point|Wire|Sheet|Solid} left
             *  @param  {Point|Wire|Sheet|Solid} right
             *  @return {number}                 distance between entities
             */
            evalDist: op('evalDist', 2),
            /** 'transform' operation
             *  Transforms 3D entity using affine matrix
             *  @function
             *  @param  {Point|Wire|Sheet|Solid} entity          - entity to transform
             *  @param  {Affine}                 transformation  - 3D affine matrix
             *  @return {Point|Wire|Sheet|Solid}                   first argument, transformed
             */
            transform: op('transform', 2),
            /** 'evalMassProps' operation
             *  Computes mass properties of entity
             *
             *  @function
             *  @param  {Wire|Sheet|Solid} entity
             *  @return {MassProps}        mass properties; not defined in this module because cannot be used as query input
             */
            evalMassProps: op('evalMassProps', 1),
            /** 'trim' operation
             *  Trims surface with a curve
             *  @function
             *  @param  {Sheet} sheet - sheet to be trimmed
             *  @param  {Wire}  curve - closed curve which will trim surface (will be projected onto surface if not resides on it)
             *  @return {Sheet}         trimmed sheet
             */
            trim: op('trim', 2),
            /** 'crossSection' operation
             *  Sections solid or sheet body with surface
             *  The result is a piece of surface which forms section
             *  @function
             *  @param  {Solid|Sheet} body    - solid or sheet body to section
             *  @param  {Plane}       surface - plane or cylinder surface to section with
             *  @return {Sheet}                 resulting cross-section
             */
            crossSection: op('crossSection', 2),
            /** 'extractSheetBoundary' operation
             *  Extracts a sheet body's boundary as a wire body.
             *  @function
             *  @param  {Sheet}       body    - sheet body to extract boundary of
             *  @return {Sheet}                 resulting boundary
            */
             extractSheetBoundary: op('extractSheetBoundary', 1),
            /** 'intersectBodyWithLine' operation
             *  Computes a list of points where line intersects faces of specified body
             *  Points are ordered by their position on the line, along line's main direction
             *  @function
             *  @param  {Sheet|Solid} body - solid or sheet body to intersect
             *  @param  {Wire}        line - intersection line
             *  @return {Point[]}            list of intersection points
             */
            intersectBodyWithLine: op('intersectBodyWithLine', 2),
            /** 'extrude' operation
             *  Extrudes body along direction, until second body is reached
             *  @function
             *  @param  {Point|Wire|Sheet} profile   - extruded profile
             *  @param  {Sheet|Solid}      bound     - bounding body
             *  @param  {Vector}           direction - extrusion direction
             *  @return {Mesh}
             */
            extrude: op('extrude', 3),
            /** 'extrudeWithDistance' operation
             *  Extrudes body along direction for a specified distance
             *  @function
             *  @param  {Point|Wire|Sheet} body      - extruded profile
             *  @param  {number}           distance  - 'height' of extrusion
             *  @param  {Vector}           direction - extrusion direction
             *  @return {Mesh}
             */
            extrudeWithDistance: op('extrudeWithDistance', 3),
            /** 'sweep' operation
             *  Sweeps wire or sheet profile along guide wire
             *  @function
             *  @param  {Wire[]|Sheet[]} profiles - profiles being swept
             *  @param  {Wire[]}         guides   - guide wires to sweep along
             *  @return {Mesh}
             */
            sweep: op('sweep', 2),
            /** 'loft' operation
             *  Lofts a set of profiles along a set of guide wires
             *  @function
             *  @param  {Wire[]|Sheet[]} profiles      - lofted profiles
             *  @param  {Wire[]}         guides        - lofting guides
             *  @param  {Point[]}        startVertices - starting vertices for lofted profiles
             *  @return {Mesh}
             */
            loft: op('loft', 3),
            /** 'revolve' operation
             *  Spins specified profile around axis based at origin for a specified angle
             *  @function
             *  @param  {Point|Wire|Sheet} profile - spinned profile
             *  @param  {Point}            origin  - rotation center
             *  @param  {Vector}           axis    - rotation axis, which is normal vector to rotation plane
             *  @param  {number}           angle   - spinning angle
             *  @return {Mesh}
             */
            revolve: op('revolve', 4),
            /** 'evalCurveLength' operation
             *  Computes curve length
             *  @function
             *  @param  {Curve}  curve
             *  @return {number}
             */
            evalCurveLength: op('evalCurveLength', 1),
            /** 'tessellate' operation
             *  Converts BREP body to a polygonal mesh
             *  @function
             *  @param  {Solid}    body              - body being tessellated
             *  @param  {number}  [linearTolearance] - the minimum linear size of any detail to be visible
             *  @param  {number}  [angularSize]      - the angle, in degrees, which provided body occupies in field of view
             *  @return {Mesh}
             */
            tessellate: function() {
                var r = new Operation('tessellate');
                r.args = [ arguments[0], arguments[1] || DEFAULT_LINEAR_TOLERANCE, arguments[2] || DEFAULT_ANGULAR_SIZE ];
                return r;
            },
            /** 'tessellateStl' operation
             *  Constructs STL representation of specified BREP
             *  @function
             *  @param  {Body}    body      - body being tessellated
             *  @param  {number}  quality   - tesselation quality, ranges 0-4; the bigger, the better
             *  @return {Entity}  BREP
             */
            tessellateStl: op('tessellateStl', 2),
            /** 'tessellateJson' operation
             *  Constructs JSON representation of specified BREP
             *  @function
             *  @param  {Body}    body      - body being tessellated
             *  @param  {number}  quality   - tesselation quality, ranges 0-4; the bigger, the better
             *  @param  {number}  units     - desired units for result given in terms of relative size of 1 meter
             *  @return {Entity}  BREP
             */
            tessellateJson: op('tessellateJson', 3),
            /** 'createPolylineApprox' operation
             *  Converts NURBS curve to polyline
             *  @function
             *  @param  {Curve}     curve
             *  @return {Point[]}
             */
            createPolylineApprox: op('createPolylineApprox', 1),
            /** 'mirror' operation
             *  Produces entity that reflected about given origin and direction
             *  @function
             *  @param  {Point|Wire|Sheet|Solid} body
             *  @param  {Point}                  origin
             *  @param  {Vector}                 direction
             *  @return {Point|Wire|Sheet|Solid}
             */
            mirror: op('mirror', 3),
            /** 'createLinearPattern' operation
             *  Produces linear pattern of entity in the given direction
             *  that is separated by spacing parameter
             *  @function
             *  @param  {Point|Wire|Sheet|Solid}  pattern
             *  @param  {Vector}                  direction
             *  @param  {number}                  spacing   - distance between pattern copies
             *  @param  {number}                  nEntities - repetitions count
             *  @return {Point|Wire|Sheet|Solid}
             */
            createLinearPattern: op('createLinearPattern', 4),
            /** 'createCircularPattern' operation
             *  Produces circular pattern of entity in the given direction
             *  that is separated by angle between each instance
             *  @function
             *  @param  {Point|Wire|Sheet|Solid}  pattern
             *  @param  {Point}                   origin
             *  @param  {Vector}                  direction - direction vector in which to create patterns
             *  @param  {number}                  angle     - angle between instances
             *  @param  {number}                  nEntities - repetitions count
             *  @return {Point|Wire|Sheet|Solid}
             */
            createCircularPattern: op('createCircularPattern', 5),
            /** 'createPlanarSheet' operation
             *  Creates a sheet body from a closed curve
             *  @function
             *  @param  {Wire}  curve - closed curve
             *  @return {Sheet}
             */
            createPlanarSheet: op('createPlanarSheet', 1),
             /** 'sectionBody' operation
             *  Sections a body with a plane or a sheet
             *  @function
             *  @param  {Sheet|Solid} target
             *  @param  {Sheet|Plane} tool
             *  @return {Sheet|Solid} the piece of original body from 'back' tool side (opposite to where tool's normal points)
             */
            sectionBody: op('sectionBody', 2),
            /** 'joinCurves' operation
             *  Joins a closed set of wires to form a solitary wire
             *  @function
             *  @param  {...Wire} wire
             *  @return {Wire}
             */
            joinCurves: op('joinCurves', 1),
            /** 'evalCurve' operation
             *  Evaluates a point and derivatives at a given curve parameter
             *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
             *  For other wires parameter spaces are preset as follows:
             *   - Line      - [0, 1]
             *   - Polyline  - [0, 1]
             *   - Rectangle - [0, 1]
             *   - Arc       - [0, 1]
             *   - Circle    - [0, 2Pi]
             *   - Ellipse   - [0, 2Pi]
             *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
             *  @function
             *  @param  {Curve}   curve
             *  @param  {number}  t       - parameter on curve
             *  @param  {number}  nDerivs - number of derivatives
             *  @return {Point[]}           a point and N derivatives
             */
            evalCurve: op('evalCurve', 3),
            /** 'evalSurface' operation
             *  Evaluates a point and derivatives at a given surface parameter pair
             *  @function
             *  @param  {Sheet}   surface
             *  @param  {number}  u        - surface parameter
             *  @param  {number}  v        - surface parameter
             *  @param  {number}  nUDerivs - derivatives count along U parameter
             *  @param  {number}  nVDerivs - derivatives count along V parameter
             *  @return {Point[]}            result point and its nU*nV-1 derivatives
             */
            evalSurface: op('evalSurface', 5),
            /** 'makeSubCurve' operation
             *  Creates a curve based on an existing curve's parameter interval
             *  For b-curves, the parameter space is bound by the lowest and highest value in the knot vector.
             *  For other wires parameter spaces are preset as follows:
             *   - Line      - [0, 1]
             *   - Polyline  - [0, 1]
             *   - Rectangle - [0, 1]
             *   - Arc       - [0, 1]
             *   - Circle    - [0, 2Pi]
             *   - Ellipse   - [0, 2Pi]
             *  Circles and ellipses are always periodic, so it is possible to pass values beyond this interval.
             *  @function
             *  @param  {Curve}  curve
             *  @param  {number} t0    - subrange start
             *  @param  {number} t1    - subrange end
             *  @return {Curve}          sub-curve from t0 to t1
             */
            makeSubCurve: op('makeSubCurve', 3),
            /** 'makeSubSurface' operation
             *  Creates a sub-surface based on an existing surface's parameter box
             *  @function
             *  @param  {Sheet}  surface
             *  @param  {number} u0 - U subrange start
             *  @param  {number} u1 - U subrange end
             *  @param  {number} v0 - V subrange start
             *  @param  {number} v1 - V subrange end
             *  @return {Sheet}       sub-sheet in ([u0, u1], [v0, v1]) box
             */
            makeSubSurface: op('makeSubSurface', 5),
            /** 'intersectCurves' operation
             *  Finds all intersections between two curves
             *  @function
             *  @param  {Curve}   curve1
             *  @param  {Curve}   curve2
             *  @return {Point[]} intersections list
             */
            intersectCurves: op('intersectCurves', 2),
            /** 'offsetBody' operation
             *  'Bloats' sheet or solid body by offsetting all its faces by specified distance, using faces' normals as directions
             *  @function
             *  @param  {Sheet|Solid} body
             *  @param  {number}      distance
             *  @return {Sheet|Solid}
             */
            offsetBody: op('offsetBody', 2),
            /** 'offsetWire' operation
             *  'Bloats' planar wire body by offsetting its pieces by specified distance
             *  @function
             *  @param  {Wire}   wire     - wire, must lie in one plane
             *  @param  {number} distance - distance to offset
             *  @param  {Vector} normal   - normal to wire's plane
             *  @return {Wire}
             */
            offsetWire: op('offsetWire', 3),
            /** 'createProfiles' operation
             *  Creates a wire or sheet body from a set of wires
             *  @function
             *  @param  {Wire[]}     profiles
             *  @param  {number}     sheetFlag - 0 for wire result, otherwise sheet
             *  @return {Wire|Sheet}             cannot be exported, only usable as input for other operations
             */
            createProfiles: op('createProfiles', 2),
            /** 'compareCurves' operation
             *  Checks if two NURBS curves are equal
             *  Following wires are considered NURBS geometry: lines, polylines, arcs, curves, rectangles.
             *  Returns "1" if wires have equal knots, points and degrees, "0" otherwise.
             *  @function
             *  @param  {Curve}   curve1
             *  @param  {Curve}   curve2
             *  @return {Number}  "1" if equal, "0" otherwise
             */
            compareCurves: op('compareCurves', 2),
            /** 'createResilientProfiles' operation
             *  Creates profiles which inner loops are removed
             *  @function
             *  @param  {Wire[]}  profiles
             *  @return {Sheet}   profile
             */
            createResilientProfiles: op('createResilientProfiles', 1),
            /** 'eval' operation
             *  Evaluates entire scene inside DCM-Worker
             *  @function
             *  @return {DCM/Scene} scene
             */
            eval: function() {
                return new Operation('eval');
            },
            /** 'evalBoundingBox' operation
             *  Calculates axis-aligned bounding box of an array of entities
             *  @function
             *  @param  {Point|Wire|Sheet|Solid[]} entities
             *  @return {Point[]} minimum and maximum points of the bounding box
             */
            evalBoundingBox: op('evalBoundingBox', 1),
            /** 'getBodyInfo' operation
             *  Returns body type and other info of an entity
             *  @function
             *  @param  {Point|Wire|Sheet|Solid} body
             *  @return {BodyInfo} info
             */
            getBodyInfo: op('getBodyInfo', 1)
        };

        // Helper function
        function getCircleCenterByThreePoints(start, middle, end)
        {
            // All z-coords are taken to be 0
            // Not valid for real 3d arc

            var offset = Math.pow(middle[0], 2) + Math.pow(middle[1], 2);
            var bc = (Math.pow(start[0], 2) + Math.pow(start[1], 2) - offset) / 2.0;
            var cd = (offset - Math.pow(end[0], 2) - Math.pow(end[1], 2)) / 2.0;
            var det = (start[0] - middle[0]) * (middle[1] - end[1]) - (middle[0] - end[0]) * (start[1] - middle[1]);
            if (Math.abs(det) < eps) {
                throw new FluxModelingError("Cannot get circle center by three points [" +
                    start[0] + ", " + start[1] + "], [" + middle[0] + ", " +
                    middle[1] + "], [" + end[0] + ", " + end[1] + "]");
            }
            var idet = 1.0/det;

            var centerX =  (bc * (middle[1] - end[1]) - cd * (start[1] - middle[1])) * idet;
            var centerY =  (cd * (start[0] - middle[0]) - bc * (middle[0] - end[0])) * idet;

            return [centerX, centerY, 0.0];
        }

        function FluxModelingError(message) {
                    this.name = 'FluxModelingError';
                    this.message = message || 'Invalid or degenerate geometry specified.';
                    this.stack = (new Error()).stack;
                }
        FluxModelingError.prototype = Object.create(Error.prototype);
        FluxModelingError.prototype.constructor = FluxModelingError;

        return {
            query:      query,
            dcmScene:   dcmScene,
            attributes: attributes,
            utilities:  utilities,
            entities:   entities,
            constraints: constraints,
            operations: ops
        };

        }

        /**
            Module exports factory function, which itself constructs module instance
            Factory accepts optional configuration object. If config object is absent,
            it's treated as empty one. If config property is set, its value is used;
            otherwiase, default is used. Please note that "property in object" is used,
            instead of "object.property !== undefined", which allows to distinguish
            config options set to undefined explicitly.

            To disable a related piece of functionality, pass null or undefined in
            the configuration parameters.

            Config options available:
            - registry - UoM registry, used for units conversion; default 'new <index>.measure.Registry()'
            - genId - UUID generator function; default '<index>.uuid.v4'
         */
        module.exports = constructModule;
        });

        var modelingFunc = (modeling$1 && typeof modeling$1 === 'object' && 'default' in modeling$1 ? modeling$1['default'] : modeling$1);

        var modeling = modelingFunc({'skip':true});

        /**
        * Stand in for the finished status on an xhr
        */
        var READY_STATE_FINISHED = 4;

        // Array of environment textures for image-based lighting.
        // Singleton
        // Cubemap textures are pre-filtered to simulate different levels of light diffusion.
        // More about the technique:
        // http://developer.amd.com/tools-and-sdks/archive/legacy-cpu-gpu-tools/cubemapgen/
        var iblCubeArray = [
            new THREE.Texture(), // 512x512
            new THREE.Texture(), // 256x256
            new THREE.Texture(), // 128x128
            new THREE.Texture(), // 61x64
            new THREE.Texture(), // 32x32
            new THREE.Texture(), // 16x16
            new THREE.Texture(), // 8x8
            new THREE.Texture(), // 4x4
            new THREE.Texture()  // 2x2
        ];

        // Loads pre-filtered textures
        function loadImages(path) {
            return new Promise(function (resolve) {
                var loadedImageCount = 0;
                for (var i = 0; i <= 8; i++) {
                    var iblCubeUrls = [
                        path + '_m0' + i + '_c00.png',
                        path + '_m0' + i + '_c01.png',
                        path + '_m0' + i + '_c02.png',
                        path + '_m0' + i + '_c03.png',
                        path + '_m0' + i + '_c04.png',
                        path + '_m0' + i + '_c05.png'
                    ];
                    var loader = new THREE.CubeTextureLoader();
                    loader.setCrossOrigin(true);
                    iblCubeArray[i] = loader.load(iblCubeUrls, function() {
                        loadedImageCount++;
                        if (loadedImageCount === 9) {
                            resolve();
                        }
                    }, undefined, function() {
                        warn('Unable to load image based lighting.');
                        resolve();
                    });
                    iblCubeArray[i].format = THREE.RGBFormat;
                }
            });
        }

        // Singleton promise for async loading
        var imagesLoadingPromise = null;

        /**
        * Flux geometry class converts parameter objects to geometry
        * @param {String} tessUrl   The url for the brep tessellation service
        * @param {String} token     The current flux auth token
        * @constructor
        */
        function GeometryBuilder(tessUrl, token) {

            // String path to tessellation API endpoint
            this._parasolidUrl = tessUrl;
            this._fluxToken = token;

            // quality   - tesselation quality, ranges 0-4; the bigger, the better
            this.tessellateQuality = 2.0;
        }

        /**
        * Create a new model for the given entities.
        *
        * @param {Object} entities The parameters objects
        * @return {Promise} A promise object that sets the model when it completes
        */
        GeometryBuilder.prototype.convert = function(entities) {
            var _this = this;
            var hasRoughness$$ = hasRoughness(entities);
            if (hasRoughness$$ && !imagesLoadingPromise) {
                imagesLoadingPromise = loadImages(IMAGES_URL);
            }
            return Promise.resolve(imagesLoadingPromise).then(function () {
                return _this.convertHelper(entities);
            });
        };

        /**
         * Function that actually does conversion once assets have loaded
         * @param {Array} entities Array of entities or arrays
         * @return {Promise} Promise to resolve when geometry is ready
         */
        GeometryBuilder.prototype.convertHelper = function(entities) {
            var geometryResults = new GeometryResults();
            geometryResults.cubeArray = iblCubeArray;

            if (entities == null || typeof entities != 'object') {
                return Promise.resolve(geometryResults);
            }

            // sync - process geometric primitives
            this._parasolidCreateObject(entities, geometryResults);
            var _this = this;
            return this._handleAsyncTextures(geometryResults).then(function (results) {
                // async - tessellate breps on the server
                return Promise.resolve(_this._handleAsyncGeom(geometryResults).then(function (results) { // resolve
                    return results;
                }).catch(function (results) { // reject
                    if (results instanceof Error) {
                        warn(results.stack);
                    }
                    return geometryResults;
                })).then(function (results) { // resolve
                    return results;
                });
            });
        };

        /**
         * Create THREE.js objects from data in the Flux JSON format.
         * The data defines Parasolid Entities.
         * More info on Parasolid Entities can be found here:
         * https://bitbucket.org/vannevartech/parasolid-worker/src/master/doc/ENTITIES.md
         * Formal schema is here:
         * https://bitbucket.org/vannevartech/flux-modelingjs/src/master/schemas/psworker.json
         * @param    {Object}    data    The geometry data as objects
         * @param    {GeometryResults}    geometryResults    Geometry and errors object
         */
        GeometryBuilder.prototype._parasolidCreateObject = function(data, geometryResults) {
            try {
                createObject(data, geometryResults);
            }
            catch(err) {
                this._handleInvalidPrims(data, err, geometryResults);
            }
        };

        /**
         * Provide error handling to determine invalid prims user message
         * @param    {Object} data    The geometry that was attempted to parse
         * @param    {Error}    err     Exception object from try catch
         * @param    {GeometryResults} geometryResults    Contains and geometry and errors
         */
        GeometryBuilder.prototype._handleInvalidPrims = function(data, err, geometryResults) {
            var errorMessage = 'Unknown error';
            if (err.name !== 'FluxGeometryError') {
                // An unknown error occurred
                throw err;
            } else {
                errorMessage = err.message;
            }

            if (data && data.primitive) {
                geometryResults.primStatus.appendError(data.primitive, errorMessage);
            } else {
                geometryResults.primStatus.appendError('unknown', errorMessage);
            }
        };

        /**
         * Make sure the appropriate environment was passed in to enable tessellation
         * @param  {GeometryResults} geometryResults    Container for errors
         * @return {Boolean}                            True when vars are set.
         */
        GeometryBuilder.prototype._canTessellate = function(geometryResults) {
            if (!this._parasolidUrl) {
                geometryResults.primStatus.appendError('brep', 'Tessellation url was not set');
                return false;
            }
            if (!this._fluxToken) {
                geometryResults.primStatus.appendError('brep', 'Flux token was not set');
                return false;
            }
            return true;
        };

        /**
         * Load textures so that they are ready by the time the geometry is returned
         * @param  {GeometryResults} geometryResults The results and errors
         * @return {Promise}                 Promise to return geometryResults
         */
        GeometryBuilder.prototype._handleAsyncTextures = function(geometryResults) {
            var textures = geometryResults.pendingTextures;
            var doneCount = 0;
            return new Promise(function (resolve, reject) {
                if (textures.length > 0) {
                    for (var i=0;i<textures.length;i++) {
                        var textureLoader = new THREE.TextureLoader();
                        var texture = textureLoader.load( textures[i], function () {
                            doneCount++;
                            if (doneCount === textures.length) {
                                resolve(geometryResults);
                            }
                        });
                        geometryResults.texturedMaterials[i].map = texture;
                    }
                } else {
                    resolve(geometryResults);
                }
            });

        };
        /**
         * Send a request to tessellate breps, and add them to the scene.
         *
         * This server currently aborts when there is an error in the tessellation operation, but in the
         * future it could respond with status 200, but contain a mix of successful and failed
         * tesselations. In those mixed cases resolve is called, but the error status is still
         * available on the returned geometryResults object.
         *
         * @param {Object} geometryResults The container for meshes, errors, and entities
         * @return {Promise}     A promise that resolves when the geometry is loaded
         */
        GeometryBuilder.prototype._handleAsyncGeom = function(geometryResults) {
            var _this = this;
            // Create a promise for the operation to tessellate all entities
            return new Promise(function(resolve, reject) {
                if (geometryResults.asyncPrims.length > 0) {
                    if (!_this._canTessellate(geometryResults)) {
                        resolve(geometryResults);
                    }
                    _this._tessellateValues(geometryResults).then(function (tessResponse) { // resolve
                        var resultObj = JSON.parse(tessResponse.result);
                        var errors = resultObj.Errors;
                        _handleBrepErrors(errors, geometryResults, tessResponse);
                        _handleBrepResults(resultObj, geometryResults, tessResponse);
                        resolve(geometryResults);
                    }).catch(function (response) { // reject
                        if (response instanceof Error) {
                            warn(response.stack);
                            geometryResults.primStatus.appendError('brep', response.message);
                            reject(geometryResults);
                        } else {
                            if (response.readyState >= READY_STATE_FINISHED) {
                                geometryResults.primStatus.appendError('brep', _interpretServerErrorCode(response.status, response.responseText));
                            } else {
                                geometryResults.primStatus.appendError('brep', 'Duplicate request was aborted.');
                            }
                        }
                        reject(geometryResults);
                    });
                } else {
                    resolve(geometryResults);
                }
            }).catch(function(err) {
                if (err.constructor===Error) {
                    warn(err);
                }
                return err;
            });
        };

        /**
         * Parse errors and update status map
         * @param  {Object} errors          Parasolid errors map
         * @param  {GeometryResults} geometryResults   Results container
         * @param  {Object} tessResponse    Server response
         */
        function _handleBrepErrors(errors, geometryResults, tessResponse) {
            // There were invalid breps or other server errors
            if (errors && Object.keys(errors).length > 0) {
                var fullErrorMessage = errors[Object.keys(errors)[0]].Message;
                // Set the server error as the invalid prim message
                geometryResults.primStatus.appendError(
                    tessResponse.primitives[_findErroredPrim(fullErrorMessage)],
                    _interpretServerError(fullErrorMessage));
            }
        }

        /**
         * Take meshes as data objects from Parasolid and convert them to renderable geometry
         * @param  {Object} resultObj       Container for meshes data
         * @param  {GeometryResults} geometryResults   Results container
         * @param  {Object} tessResponse    Server response
         */
        function _handleBrepResults(resultObj, geometryResults, tessResponse) {
            // There were valid breps that tessellated
            if (resultObj.Output.Results) {
                var data = resultObj.Output.Results.value;
                var dataArray = [];
                for (var key in data) {
                    var primitive = tessResponse.primitives[key];
                    geometryResults.primStatus.appendValid(primitive);
                    var jsonData = data[key];
                    // This function adds the results as children of geometryResults.object
                    dataArray.push(jsonData);
                }
                createObject(dataArray, geometryResults);
            }
        }

        /**
         * Asynchronously request a tessellated model from the back end service.
         * @precondition Each value is a brep entity with a primitive property
         * @param    {GeometryResults} geometryResults Results container with async primitives unhandled from previous call
         * @return {Promise}     A promise that resolves when the geometry is loaded
         */
        GeometryBuilder.prototype._tessellateValues = function (geometryResults) {
            // Flat array of Flux entity objects
            var values = geometryResults.asyncPrims;
            if (!values || values.constructor !== Array) {
                return Promise.resolve(geometryResults);
            }
            // Keep track of the primitive names in the values array
            var primitives = {};
            var sceneJSON = this._constructScene(geometryResults, values, primitives);

            var fetchOptions = {
                fluxToken: this._fluxToken,
                method: 'POST',
                body: sceneJSON
            };

            var xhrPromise = fluxFetch(this._parasolidUrl, fetchOptions);

            // unwrap the extra promise generated by fetch
            return new Promise(function (resolve, reject) {
                var resultObj = {'result': '', 'primitives': primitives};
                xhrPromise.then(function (tessHeaderResponse) {
                    if (tessHeaderResponse.status === 200) {
                        tessHeaderResponse.body.then(function(tessResult) {
                            resultObj.result = tessResult;
                            resolve(resultObj);
                        });
                    } else {
                        reject(new Error('Server error '+tessHeaderResponse.status+' '+tessHeaderResponse.body ));
                    }
                });
            });
        };

        /**
         * Construct a scene object to format the request for brep tessellation
         * @param  {GeometryResults} geometryResults Results container
         * @param  {Array}  values List of primitives to tessellate
         * @param  {Object} primitives Keep track of the primitive names in the values array.
         *                             This is a map so that in the case of a server error the primitives
         *                             can be looked up based on server message which contains their
         *                             resultId string, which is a unique identifier
         * @return {Object}     JSON object with parameters describing the operations to be sent to parasolid
         */
        GeometryBuilder.prototype._constructScene = function (geometryResults, values, primitives) {
            var scene = modeling.query();
            for (var i=0; i<values.length; i++) {
                var value = values[i];
                if (!value || !value.primitive) continue;
                var resultId = 'result'+i;
                scene.add(resultId, value);
                var tessOp = modeling.operations.tessellateJson(resultId, this.tessellateQuality, 1.0);
                // The first argument must be a unique id. It is an integer
                // so it can be used to look up the primitive later.
                scene.add(resultId, tessOp);
                primitives[resultId] = value.primitive;
            }
            return {'Scene':scene.toJSON()};
        };

        /**
         * Parse server error message and interpret to be human readable.
         * Eventually the sever might have better messages:
         * https://vannevar.atlassian.net/browse/GI-1933
         * @param    {String} text The full error text
         * @return {String}            The improved error message
         */
        function _interpretServerError (text) {
            var errorMessage = text.slice(0, text.indexOf('\n'));
            // Add a more clear explanation for this specific error
            if (errorMessage === 'PK_ERROR_wrong_transf') {
                errorMessage = 'Flux is currently unable to model objects '+
                        'that are outside of a bounding box that is 1000 units '+
                        'wide centered at the origin. Please scale down your '+
                        'models or change units.';
            } else if (errorMessage === 'Translator loader error') {
                errorMessage = 'The brep translator could not be initialized. '+
                        'Perhaps the license has expired. Please contact Flux to get '+
                        'this resolved.';
            }
            return 'Server error: '+errorMessage;
        }

        /**
         * Workaround for finding the prim associated with the error.
         * The backend does not have a good API for this yet.
         * https://vannevar.atlassian.net/browse/PLT-4228
         * @param    {String} text The full error text
         * @return {String}            The primitive name
         */
        function _findErroredPrim(text) {
            var match = text.match(/\/result.*\n/);
            return match ? match[0].slice(1, match[0].length-1) : '';
        }

        /**
         * Create a user error message based on status codes
         * @param    {String} status The error html status code
         * @param    {String} text The full error text
         * @return {String}            The error message
         */
        function _interpretServerErrorCode(status, text) {
            if (status === 504) {
                return "Server error: Your request exceeded the maximum time limit for execution.";
            }
            warn("Server error in tessellation. Status:",status,":",text);
            return "Server error: The brep tessellation service is unavailable.";
        }

        /**
         * Set the url of the tessellation service.
         * This is required for rendering of breps.
         * @param {String} newUrl The url of the tessellation server
         */
        GeometryBuilder.prototype.setTessUrl = function(newUrl) {
            this._parasolidUrl = newUrl;
        };

        /**
         * Replace the color of an object and it's children with the given color
         * @param {String|THREE.Color} color  The new render color
         * @param {THREE.Object3D} object The object to color
         */
        //setlayercolor
        function setObjectColor(object, color) {
            if (!color) return;

            var colorObj = _convertColor(color);

            object.traverse(function (child) {
                if (child.geometry && child.material) {
                    // Clear the old color
                    var colors = child.geometry.attributes.color.array;
                    for (var i=0;i<color.length;i++) {
                        colors[i] = 1;
                    }
                    // Apply color to material (multiplies with per vertex color)
                    child.material.color.set(colorObj);
                }
            });
        }

        /**
         * Data model for each call to convertScene.
         * Data is stored in its own class definition because it is unique
         * per chain of promises.
         * @param {SceneBuilderData} sceneBuilderData The full source data
         */
        function SceneResults(sceneBuilderData) {
            // Container for all geometry results
            this._object = sceneBuilderData.object;

            // Map from primitive name to error string or empty string when no error
            this._status = sceneBuilderData.primStatus;

            this._sceneObjectMap = sceneBuilderData.getObjectMap();
        }

        /**
         * Determine if there is any geometry in the mesh object
         * @return {Boolean} True when empty
         */
        SceneResults.prototype._objectIsEmpty = function () {
            return this._object == null || this._object.children.length === 0;
        };

        /**
         * Get a layer object that allows manipulating its properties
         * @param  {String} id The unique identifier for the scene element
         * @return {THREE.Object3D}    The layer to render
         */
        SceneResults.prototype._getObjectById = function (id) {
            var layer = this._sceneObjectMap[id];
            if (layer) {
                return layer;
            }
            return null;
        };

        /**
         * Set whether this scene element renders or not
         * @param  {String} id The unique identifier for the scene element
         * @param  {Boolean} visible Whether to render
         */
        SceneResults.prototype.setElementVisible = function (id, visible) {
            var object = this._getObjectById(id);
            if (object) {
                object.visible = visible;
            }
        };

        /**
         * Set the scene element override color
         * Note: This is a destructive operation, it will blow away the point colors on the meshes
         * If we want to fix this the color can be cached in another attribute and then restored
         * @param  {String} id The unique identifier for the scene element
         * @param  {String|THREE.Color} color The color to apply
         */
        SceneResults.prototype.setElementColor = function (id, color) {
            var object = this._getObjectById(id);
            if (object) {
                setObjectColor(object, color);
            }
        };

        /**
         * Get the mesh or null if it's empty.
         * @return {Object3D} The mesh container or null
         */
        SceneResults.prototype.getObject = function () {
            if (this._objectIsEmpty()) {
                return null;
            } else {
                return this._object;
            }
        };

        /**
         * Whether there is any renderable geometry in the scene
         * @return {Boolean} True when it will render empty
         */
        SceneResults.prototype.isEmpty = function () {
            return this.getObject() == null;
        };

        /**
         * Get a summary string of all the geometry errors
         * @return {String} Error message
         */
        SceneResults.prototype.getErrorSummary = function () {
            return this._status.invalidKeySummary();
        };

        //---- Class Definition

        /**
         * Data model for each call to convertScene.
         * Data is stored in its own class definition because it is unique
         * per chain of promises.
         */
        function SceneBuilderData() {
            // Container for all geometry results
            this.object = new THREE.Object3D();

            // Map from primitive name to error string or empty string when no error
            this.primStatus = new StatusMap();

            // List of layers
            this._layerPrims = [];

            // Map from id to scene element JSON object
            this._sceneDataMap = {};

            // Map from id to Promise for geometry reuse
            this._scenePromiseMap = {};

            // Map from id to THREE.Object3D
            this._sceneObjectMap = {};
        }

        /**
         * Get a map from id to three.js object data
         * Allows lookup of geometry that has already been built for rendering.
         * @return {Object} JavaScript Object used as a key value map
         */
        SceneBuilderData.prototype.getObjectMap = function() {
            return this._sceneObjectMap;
        };

        /**
         * Add the JSON data for a layer
         * This is a cache used to remember all the layer primitives in a scene
         * @param {Object} element JSON data for layer
         */
        SceneBuilderData.prototype.addLayer = function(element) {
            this._layerPrims.push(element);
        };

        /**
         * Return the list of layers for processing
         * @return {Array} Array of layer JSON objects
         */
        SceneBuilderData.prototype.getLayers = function() {
            return this._layerPrims;
        };

        /**
         * Store a pointer to an entity JSON in the id map
         * @param {Object} element Element JSON data
         */
        SceneBuilderData.prototype.setEntityData = function(element) {
            if (element.id) {
                this._sceneDataMap[element.id] = element;
            }
        };

        /**
         * Find an entity by its id
         * @param  {String} id The key to look by
         * @return {Object}    Flux JSON Entity
         */
        SceneBuilderData.prototype.getEntityData = function(id) {
            if (typeof id === 'string') {
                var entity = this._sceneDataMap[id];
                if (entity != null) {
                    return entity;
                }
                throw new FluxGeometryError('Reference to non existing id in scene:',id);
            } else {
                if (id == null) {
                    throw new FluxGeometryError('No entity or referenced id specified');
                }
                return id; // entire entities can be used in lieu of id
            }
        };

        /**
         * Store a three.js object in an id map for reuse
         * @param  {String} entityId    The unique identifier
         * @param  {THREE.Object3D} entity   The object to store
         */
        SceneBuilderData.prototype.cacheObject = function(entityId, entity) {
            this._sceneObjectMap[entityId] = entity;
        };

        /**
         * Store a promise for geometry reuse.
         * This allows geometry instances to share results before those results
         * are asynchronously computed.
         * @param  {String} entityId      The unique identifier
         * @param  {Promise} entityPromise Promise for GeometryResults
         */
        SceneBuilderData.prototype.cachePromise = function(entityId, entityPromise) {
            this._scenePromiseMap[entityId] = entityPromise;
        };

        /**
         * Lookup an existing promise if its element has already started being converted
         * @param  {String} entityId The unique identifier
         * @return {Promise}          Promise for GeometryResults
         */
        SceneBuilderData.prototype.getCachedPromise = function(entityId) {
            return this._scenePromiseMap[entityId];
        };

        /**
         * Merge in the layers from another scene
         * @param  {SceneBuilderData} other Other data containing a finished scene
         */
        SceneBuilderData.prototype.mergeScenes = function(other) {
            if (!other) return;

            var children = other.object.children;
            if (children.length>0) {
                while(children.length>0) {
                    this.object.add(children[children.length-1]);
                }
            }
            this._finishMerge(other);
        };

        /**
         * Merge these layers with those from another query
         * @param  {SceneBuilderData} other The other one containing a layer
         */
        SceneBuilderData.prototype.mergeLayers = function(other) {
            if (!other) return;
            this.object.add(other.object);
            this._finishMerge(other);
        };

        /**
         * Merge these results with those form another query
         * @param  {SceneBuilderData} other The other one containing an instance
         */
        SceneBuilderData.prototype.mergeInstances = function(other) {
            if (!other) return;
            var _this = this;
            for (var i=0;i<other.object.children.length; i++) {
                var child = other.object.children[i];
                if (child.type === "Mesh" || child.type ==="Line") {
                    // Build a completely new object containing new meshes, since three.js
                    // does not allow multiple parents for the same object
                    var func = THREE[child.type];
                    var obj = new func(child.geometry, child.material);
                    obj.applyMatrix(child.matrixWorld);
                    _this.object.add(obj);
                } else {
                    // You can not instance other wacky things like text objects
                    _this.object.add(child);
                }
            }
            this._finishMerge(other);
        };

        /**
         * Common merge functionality that needs to be done after merging different object types
         * @param  {SceneBuilderData} other The other builder instance
         */
        SceneBuilderData.prototype._finishMerge = function(other) {
            // Update the matrix on this object and its new children
            this.object.updateMatrixWorld(true);

            this.primStatus.merge(other.primStatus);
            this._mergeCache(other);
        };

        /**
         * Return an object containing just the user facing results of the geometry construction
         * @return {SceneResults} The user info
         */
        SceneBuilderData.prototype.getResults = function() {
            return new SceneResults(this);
        };

        /**
         * Combine this data object with the constructed geometry of another.
         * Merges other into this.
         * @param  {SceneBuilderData} other The other scene data container
         */
        SceneBuilderData.prototype._mergeCache = function(other) {
            for (var key in other._sceneObjectMap) {
                this._sceneObjectMap[key] = other._sceneObjectMap[key];
            }
        };

        var SceneValidatorResults = __commonjs(function (module) {
        'use strict';

        /**
         * Class to hold results of a validation query
         * @param {Boolean} result  True if the scene is valid
         * @param {String} message  Description of error when invalid
         */
        function SceneValidatorResults(result, message) {
            this._result = result;
            if (message) {
                this._message = message;
            } else {
                this._message = '';
            }
        }

        /**
         * Expose result
         * @return {Boolean} True for valid scenes
         */
        SceneValidatorResults.prototype.getResult = function() {
            return this._result;
        }

        /**
         * Expose message
         * @return {String} Description of errors for bad scenes.
         */
        SceneValidatorResults.prototype.getMessage = function() {
            return this._message;
        }

        module.exports = SceneValidatorResults;
        });

        var require$$0$11 = (SceneValidatorResults && typeof SceneValidatorResults === 'object' && 'default' in SceneValidatorResults ? SceneValidatorResults['default'] : SceneValidatorResults);

        var SceneValidator = __commonjs(function (module) {
        'use strict';
        // additional rules for validator
        var SceneValidatorResults = require$$0$11;

        /**
         * Class to manage calls to check if JSON matches the scene spec
         */
        function SceneValidator() {
            // instances that are already used in assemblies
            this.usedInstanceIDs = [];
        }

        /**
         * Find an object in a collection by one of it's properties.
         * TODO(Kyle): this is inefficient, and could be replaced by a two pass algorithm with a map
         * @param  {String} field Property name
         * @param  {String} value Expected value of property
         * @param  {Object} json  The collection object to search
         * @return {Object}       The object if it was foudn
         */
        function _findObjectByField(field, value, json) {
            for(var key in json.elements) {
                if (json.elements[key][field] === value) {
                    return json.elements[key];
                }
            }
        }

        /**
         * checks node.id is not equal to parent.id
         * checks node.primitive is not in the list of banned primitives
         * @param  {Object} node                        Scene element JSON object
         * @param  {String} parentID                    ID of node's parent in scene
         * @param  {Array.<String>} bannedPrimitives    List of primitives that node should not match
         * @return {String}                             Error message or null
         */
        function _validateNode(node, parentID, bannedPrimitives){
            if (node.id === parentID) {
                return 'Node ' + node.id +' has ID equal to parent ID';
            }
            var searchRes = bannedPrimitives.indexOf(node.primitive);
            if (searchRes !== -1) {
                return 'Node ' + node.id +
                ' has a primitive type ('+bannedPrimitives[searchRes]+') that is not allowed with its current parent.'
            }
            return null;
        }

        /**
         * Determine if the instance is used properly in the scene
         * @param  {Object} instance        Flux element JSON
         * @param  {Object} json            Full scene JSON
         * @return {SceneValidatorResults}  The results
         */
        function _validateInstance(instance, json){
            var node = _findObjectByField('id', instance.entity, json);
            if (!node) return _invalidId(instance.node);
            if (!node.primitive) return _primitiveError();

            var result = _validateNode(node, instance.id, ['instance', 'assembly', 'layer']);
            if (result) {
                return _error(result);
            }

            return _ok();
        }

        /**
         * Determine if the assembly is used properly in the scene
         * @param  {Object} assembly        Flux element JSON
         * @param  {Object} json            Full scene JSON
         * @return {SceneValidatorResults}  The Results
         */
        SceneValidator.prototype._validateAssembly = function(assembly, json){
            if (!assembly.children || assembly.children.constructor !== Array) {
                return _error('Assembly must have array of children');
            }

            for(var i = 0; i < assembly.children.length; i++){
                var nodeID = assembly.children[i];
                var node = _findObjectByField('id', nodeID, json);
                if (!node) return _invalidId(nodeID);
                if (!node.primitive) return _primitiveError();

                var result = _validateNode(node, assembly.id, ['layer']);
                if (result) {
                    return _error(result);
                }

                // check instances are referenced by only a single assembly
                if (node.primitive === 'instance') {
                    if (this.usedInstanceIDs.indexOf(node.id) != -1) {
                        return _error('Instance with id = ' + node.id + ' is referenced more than once');
                    } else {
                        this.usedInstanceIDs.push(node.id);
                    }
                }
                else if (node.primitive != 'assembly') {
                    var message = 'Assembly can only contain instances or assemblies: '
                        + node.id + ' has primitive ' +node.primitive;
                    return _error(message);
                }
            }

            return _ok();
        };

        /**
         * Create a message for an invalid id
         * @param  {String} id The id that was invalid
         * @return {SceneValidatorResults}    The results
         */
        function _invalidId(id) {
            return _error('No element found with ID=' + id);
        }

        /**
         * Create an error message object
         * @param  {String} message         Description of the message
         * @return {SceneValidatorResults}  The results object
         */
        function _error(message) {
            return new SceneValidatorResults(false, message);
        }

        /**
         * Create a results object that represents successful validation
         * @return {SceneValidatorResults}  The results object
         */
        function _ok() {
            return new SceneValidatorResults(true);
        }

        /**
         * Error message for objects missing the primitive attribute
         * @return {SceneValidatorResults}  The results object
         */
        function _primitiveError() {
            return _error('Element referenced by ID has no primitive attribute');
        }

        /**
         * Determine if the layer is used properly in the scene
         * @param  {Object} layer           Flux element JSON
         * @param  {Object} json            Full scene JSON
         * @return {SceneValidatorResults}  The results
         */
        function _validateLayer(layer, json){
            for(var i = 0; i < layer.elements.length; i++){
                var nodeKey = layer.elements[i];
                var node = _findObjectByField('id', nodeKey, json);
                if (!node) return _invalidId(nodeKey);
                if (!node.primitive) return _primitiveError();
                // Layers can contain any entity except scenes and layers
                var result = _validateNode(node, layer.id, ['scene', 'layer']);
                if (result) {
                    return _error(result);
                }
            }
            return _ok();
        }

        /**
         * Check if an object is scene data
         * @param  {Object}  json The scene JSON
         * @return {Boolean}      True if it is a scene
         */
        SceneValidator.isScene = function (json) {
            return json && json.primitive && json.primitive === 'scene' &&
                    json.elements && json.elements.constructor === Array;
        }

        /**
         * Enumeration to store assembly states
         * @type {Object}
         */
        var STATES = {
            PROCESSING: 1,
            VALID: 2
        };

        /**
         * Determine whether the graph structure of assemblies has any cycles.
         * Cyclical links in assemblies can not be rendered and are invalid.
         * @param  {Object}  assemblies Map from id to assembly data
         * @return {Boolean}            True if there are no cycles and the assemblies are valid
         */
        function _isAcyclic(assemblies) {
            var stack = [];
            var parent = {};
            var states = {};
            for (var a in assemblies) {
                stack.push(assemblies[a].id);
            }
            // Depth first search
            while (stack.length > 0) {
                var id = stack.pop();
                var assembly = assemblies[id];
                // Skip repeatedly processing nodes in chains that do not have cycles
                if (states[id]===STATES.VALID) {
                    continue;
                } else if (states[id] === STATES.PROCESSING) {
                    return false;
                } else {
                    states[id] = STATES.PROCESSING;
                }
                var numChildren = 0;
                for(var i = 0; i < assembly.children.length; i++){
                    var childId = assembly.children[i];
                    // Only check children that are assemblies
                    if (assemblies[childId] && states[childId] !== STATES.VALID) {
                        stack.push(childId);
                        parent[childId] = id;
                        numChildren++;
                    }
                }
                // Leaf node has no cycles
                if (numChildren === 0) {
                    var validId = id;
                    // Mark parents as valid as long as they are satisfied
                    while (validId && states[validId]===STATES.PROCESSING) {
                        // A node is satisfied when all of it's children have been processed
                        var satisfied = true;
                        var children = assemblies[validId].children;
                        // Check if any of the children that are assemblies are not yet valid
                        for(var i = 0; i < children.length; i++){
                            if (assemblies[children[i]] && states[children[i]]!==STATES.VALID) {
                                satisfied = false;
                            }
                        }
                        if (satisfied) {
                            states[validId] = STATES.VALID;
                            validId = parent[validId];
                        } else {
                            validId = null;
                        }

                    }
                }
            }
            return true;
        }

        /**
         * Determine if some arbitrary json is a valid scene
         * @param  {Object} json JSON data of a potential scene
         * @return {SceneValidatorResults}      The result
         */
        SceneValidator.prototype.validateJSON = function (json)
        {
            var allIDs = [];

            if (!SceneValidator.isScene(json)) {
                return _error('The element is not a scene');
            }
            var assemblies = {};
            var layerCount = 0;
            for (var i=0;i<json.elements.length;i++){
                var obj = json.elements[i];

                // check for unique id
                if (allIDs.indexOf(obj.id) != -1) {
                    return _error('The id ' + obj.id + ' is not unique');
                } else {
                    allIDs.push(obj.id);
                }

                // check instance reference only valid entity
                if (obj.primitive === 'instance'){
                    var res = _validateInstance(obj, json);
                    if (!res.getResult()) {
                        return res;
                    }
                }

                // check assemblies reference only instances or other assemblies
                else if (obj.primitive === 'assembly'){
                    var res = this._validateAssembly(obj, json);
                    if (!res.getResult()) {
                        return res;
                    }
                    assemblies[obj.id] = obj;
                }

                // check layer reference only assemblies and instances
                else if (obj.primitive === 'layer'){
                    var res = _validateLayer(obj, json);
                    if (!res.getResult()) {
                        return res;
                    }
                    layerCount++;
                }
            }
            if (layerCount < 1) {
                return _error('Scene has no layers');
            }
            if (!_isAcyclic(assemblies)) {
                return _error('Cycle found in assemblies');
            }
            return _ok();
        }

        module.exports = SceneValidator;
        });

        var SceneValidator$1 = (SceneValidator && typeof SceneValidator === 'object' && 'default' in SceneValidator ? SceneValidator['default'] : SceneValidator);

        /**
         * Modify an object and then return a copy of it with no null properties
         * @param  {Object} obj JSON data
         * @return {Object}     Updated JSON data
         */
        function _removeNulls(obj) {
            if (!obj) return obj;
            var changed = _unsetNulls(obj);
            if (changed) {
                return JSON.parse(JSON.stringify(obj));
            } else {
                return obj;
            }
        }

        /**
         * Replace all properties on an object or it's children that are null with undefined
         * @param  {Object} obj JSON object data
         * @return  {Boolean} obj Whether any values were changed by setting to null
         */
        function _unsetNulls(obj) {
            var changed = false;
            for (var key in obj) {
                if (obj[key] === null) {
                    obj[key] = undefined;
                    changed = true;
                } else if (obj[key] && typeof obj[key] === 'object') {
                    if (_unsetNulls(obj[key])) {
                        changed = true;
                    }
                }
            }
            return changed;
        }

        /**
         * Clone an element and remove null properties
         * @param  {Object} entity JSON element data
         * @return {Object}        New JSON object representation
         */
        function cleanElement(entity) {
            // Create a clone so that we can modify the properties in place
            // TODO(Kyle) This is slow for very large objects. The only reason we need a clone is for
            // the functions removeNulls and unitConverter, if we change those functions to return a new
            // data structure without modifying the result then this clone will not be necessary.
            var entityClone = JSON.parse(JSON.stringify(entity));

            // Get rid of invalid properties commonly sent by plugins on elements
            // If they remain these properties will fail schema validation.
            entityClone = _removeNulls(entityClone);

            return entityClone;
        }

        /**
         * Class to convert a Flux JSON scene to a three.js object hierarchy
         * @param {String} tessUrl  The url for the brep tessellation service
         * @param {String} token    The current flux auth token
         */
        function SceneBuilder(tessUrl, token) {
            this._geometryBuilder = new GeometryBuilder(tessUrl, token);
        }

        /**
         * Convert JSON data to a tree of three.js geometry
         * Conversion is asynchronous, so results are returned in promises.
         * @param  {Object} data JSON data containing scene
         * @return {Promise}      Promise to return a SceneResults object
         */
        SceneBuilder.prototype.convert = function(data) {
            var sceneBuilderData = new SceneBuilderData();
            // Make sure data is JSON for an element of some sort
            if (!data || !(data.constructor === Array || data.primitive)) {
                return Promise.resolve(sceneBuilderData.getResults());
            }
            var dataClean = cleanElement(data);
            var scenes = _findTheScenes(dataClean, sceneBuilderData);
            var builderPromises=[];
            if (scenes) {
                for (var i=0;i<scenes.length;i++) {
                    var scene = scenes[i];
                    var sceneValidator = new SceneValidator$1();
                    var sceneValid = sceneValidator.validateJSON(scene);
                    if (sceneValid.getResult()) {
                        builderPromises.push(this._convertScene(scene.elements, sceneBuilderData));
                    } else {
                        sceneBuilderData.primStatus.appendError(scene.primitive, sceneValid.getMessage());
                    }
                }
                if (builderPromises.length === 0) {
                    return Promise.resolve(sceneBuilderData.getResults());
                }
            } else {
                builderPromises = [this._createEntity(dataClean)];
            }

            return Promise.all(builderPromises).then(function(newBuilderData) {
                for (var i=0;i<newBuilderData.length;i++) {
                    sceneBuilderData.mergeScenes(newBuilderData[i]);
                }
                return sceneBuilderData.getResults();
            });
        };

        /**
         * Find the scenes in the data and return a flat list.
         * @param  {Object} data         Flux json
         * @return {Object}              Scene json object or array of objects or null
         */
        function _findTheScenes(data) {
            var scenes = [];
            var array = _flattenArray([data], []);
            for (var i=0;i<array.length;i++) {
                var element = array[i];
                if (SceneValidator$1.isScene(element)) {
                    scenes.push(element);
                }
            }
            if (scenes.length > 0) {
                return scenes;
            } else {
                return null;
            }
        }

        /**
         * Flatten a nested array into a simple list
         * This function is recursive.
         * @param  {Array} arr    Source data
         * @param  {Array} result Empty array to store elements
         * @return {Array}        Return the result again for convenience
         */
        function _flattenArray(arr, result) {
            if (arr == null) return result;

            if (arr.constructor === Array) {
                for (var i=0;i<arr.length;i++) {
                    _flattenArray(arr[i], result);
                }
            } else {
                result.push(arr);
            }
            return result;
        }

        /**
         * Convert the scene data into a THREE.Object3D
         * @param  {Array} entities                        JSON Object with scene parameters
         * @param  {SceneBuilderData} sceneBuilderData  Container for result and per query storage
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._convertScene = function(entities, sceneBuilderData) {
            var array = _flattenArray([entities], []);
            for (var i=0;i<array.length;i++) {
                var element = array[i];
                sceneBuilderData.setEntityData(element);
                if (element.primitive && element.primitive === SCENE_PRIMITIVES.layer) {
                    sceneBuilderData.addLayer(element);
                }
                // Currently JSON data that is unreferenced by layers will be ignored
            }

            return this._createLayers(entities, sceneBuilderData);
        };

        /**
         * Create a all the layers in the scene as unique instances of THREE.Object3D
         * @param  {Object} data                        JSON Object with layer parameters
         * @param  {SceneBuilderData} sceneBuilderData  Container for result and per query storage
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createLayers = function(data, sceneBuilderData) {
            var promises = [];
            var layers = sceneBuilderData.getLayers();
            for (var l=0;l<layers.length;l++) {
                var layer = layers[l];
                if (checkSchema(layer, sceneBuilderData.primStatus)) {
                    promises.push(this._createLayer(layer, sceneBuilderData));
                }
            }
            return Promise.all(promises).then(function (results) {
                if (results.length===0) return sceneBuilderData;
                var combo = new SceneBuilderData();
                for (var r=0;r<results.length;r++) {
                    combo.mergeLayers(results[r]);
                }
                return combo;
            });
        };

        /**
         * Create a layer in three.js from the given data
         * @param  {Object} data                        JSON Object with layer parameters
         * @param  {SceneBuilderData} sceneBuilderData  Container for result and per query storage
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createLayer = function(data, sceneBuilderData) {
            var promises = [];
            for (var c=0;c<data.elements.length;c++) {
                var child = data.elements[c];
                promises.push(this._createSceneElement(child, sceneBuilderData));
            }
            var layerPromise = Promise.all(promises).then(function (results) { // merge elements
                if (results.length===0) return sceneBuilderData;
                var combo = new SceneBuilderData();
                for (var r=0;r<results.length;r++) {
                    combo.mergeInstances(results[r]);
                }
                return combo;
            }).then(function(result) { // apply layer overrides
                setObjectColor(result.object, data.color);
                return result;
            });
            return layerPromise.then(function(result) {
                // cache the layer
                var id = data.id;
                if (id) {
                    sceneBuilderData.cacheObject(id, result.object);
                }
                return result;
            });
        };

        /**
         * Create any scene element
         * @param  {Object} elementId                   JSON Object with element parameters
         * @param  {SceneBuilderData} sceneBuilderData  Container for result and per query storage
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createSceneElement = function(elementId, sceneBuilderData) {
            var element = sceneBuilderData.getEntityData(elementId);
            if (!checkSchema(element, sceneBuilderData.primStatus)) {
                return Promise.resolve(sceneBuilderData);
            }
            if (element.primitive === SCENE_PRIMITIVES.instance) {
                return this._createInstance(element, sceneBuilderData);
            } else if (element.primitive === SCENE_PRIMITIVES.assembly) {
                return this._createAssembly(element, sceneBuilderData);
            } else if (element.primitive === SCENE_PRIMITIVES.geometry) {
                return this._createGeometryContainer(element);
            } else { // entity
                return this._createEntityFromData(element, sceneBuilderData);
            }
        };

        /**
         * Create any scene geometry.
         * This is used to store arrays of entities with an associated id.
         * @param  {Object} element                   JSON Object with geometry parameters
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createGeometryContainer = function(element) {
            return this._createEntity(element.entity);
        };

        /**
         * Apply a transform matrix to a 3D Object
         * @param  {Array.<Number>} matrix Array of 16 values representing a 4x4 transform
         * @param  {THREE.Object3D} object The object to update
         */
        function _applyTransform(matrix, object) {
            if (matrix) {
                var mat = new THREE.Matrix4();
                for (var i = 0; i < matrix.length; i++) {
                    mat.elements[i] = matrix[i];
                }
                object.applyMatrix(mat);
                object.updateMatrixWorld(true);
            }
        }

        /**
         * Instances are special and reuse their entities
         * @param  {Object} element                     JSON data for assembly
         * @param  {SceneBuilderData} sceneBuilderData  Container for results and errors
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createInstance = function(element, sceneBuilderData) {
            return this._createSceneElement(element.entity, sceneBuilderData).then(function (results) {
                var instanceResults = new SceneBuilderData();
                _applyTransform(element.matrix, instanceResults.object);
                instanceResults.mergeInstances(results);
                return instanceResults;
            }).catch(function (err) {
                log(err);
            });
        };
        /**
         * Create an assembly collection of elements with a transform
         * @param  {Object} element                     JSON data for assembly
         * @param  {SceneBuilderData} sceneBuilderData  Container for results and errors
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createAssembly = function(element, sceneBuilderData) {
            var promises = [];
            for (var c=0;c<element.children.length;c++) {
                var child = element.children[c];
                promises.push(this._createSceneElement(child, sceneBuilderData));
            }
            var assemblyPromise = Promise.all(promises).then(function (results) { // merge elements
                if (results.length===0) return sceneBuilderData;
                var combo = new SceneBuilderData();
                _applyTransform(element.matrix, combo.object);
                for (var r=0;r<results.length;r++) {
                    combo.mergeInstances(results[r]);
                }
                return combo;
            });
            return assemblyPromise.then(function(result) {
                // cache the layer
                var id = element.id;
                if (id) {
                    sceneBuilderData.cacheObject(id, result.object);
                }
                return result;
            });
        };

        /**
         * Leaf node of scene that calls into geometry builder to create entities.
         * @param  {Object} entityData                  JSON data for entity description
         * @param  {SceneBuilderData} sceneBuilderData  Container for results and errors.
         * @return {Promise}                            Promise for SceneBuilderData
         */
        SceneBuilder.prototype._createEntityFromData = function(entityData, sceneBuilderData) {
            var entityId = entityData.id;
            if (entityId) {
                var cachedResults = sceneBuilderData.getCachedPromise(entityId);
                if (cachedResults) {
                    return Promise.resolve(cachedResults);
                } else {
                    var convertPromise = this._createEntity(entityData);
                    sceneBuilderData.cachePromise(entityId, convertPromise);
                    return convertPromise;
                }
            }
            return this._createEntity(entityData);
        };

        /**
         * Create the geometry and convert the results to scene results
         * @param  {Object} entityData  The geometry to convert
         * @return {Promise}            Promise to return SceneBuilderData
         */
        SceneBuilder.prototype._createEntity = function(entityData) {
            return this._geometryBuilder.convert(entityData).then(function(geometryResults) {
                var sceneBuilderData = new SceneBuilderData();
                sceneBuilderData.object = geometryResults.object;
                sceneBuilderData.primStatus = geometryResults.primStatus;
                return sceneBuilderData;
            });
        };

        /**
         * Set the url of the tessellation service.
         * This is required for rendering of breps.
         * @param {String} newUrl The url of the tessellation server
         */
        SceneBuilder.prototype.setTessUrl = function(newUrl) {
            this._geometryBuilder.setTessUrl(newUrl);
        };

        /**
         * UI widget to render 3D geometry.
         * This class provides all the interface you need to add the flux web
         * viewer to your SDK app. This allows you to interpret Flux json data
         * and render that geometry. You may also create any number of viewports
         * and they will share the finite number of WebGL contexts available
         * from the browser.<br>
         * Note: If you are using Flux materials that have the parameter roughness
         * set then you will need to configure your server to have a content security
         * policy that allows content from https://object-library.storage.googleapis.com
         * so that our standard texture images can be loaded.
         * For more information: https://content-security-policy.com
         * @class FluxViewport
         * @param {Element}   domParent     The div container for the canvas
         * @param {Object}    optionalParams Object containing all other parameters
         * @param {Number}    optionalParams.width         The width of the canvas
         * @param {Number}    optionalParams.height        The height of the canvas
         * @param {String}    optionalParams.tessUrl       The url for making brep tessellation requests (overrides projectId) (deprecated)
         * @param {String}    optionalParams.projectId     Id has for a flux project used to make tessellation requests
         * @param {String}    optionalParams.token         The current flux auth token
         */
        function FluxViewport (domParent, optionalParams) {
            var width;
            var height;
            var tessUrl;
            var token;
            if (optionalParams) {
                width = optionalParams.width;
                height = optionalParams.height;
                if (optionalParams.tessUrl) {
                    tessUrl = optionalParams.tessUrl;
                } else if (optionalParams.projectId) {
                    tessUrl = _getTessUrl(optionalParams.projectId);
                }
                token = optionalParams.token;
            }

            var renderWidth = 100;//px
            if (width == null) {
                renderWidth = domParent.clientWidth;
            } else {
                renderWidth = Math.max(renderWidth, width);
            }

            var renderHeight = 100;//px
            if (height == null) {
                renderHeight = domParent.clientHeight;
            } else {
                renderHeight = Math.max(renderHeight, height);
            }

            if (!domParent) {
                throw new Error('domParent must be specified to FluxViewport');
            }

            this._sceneBuilder = new SceneBuilder(tessUrl, token);

            this._renderer = new FluxRenderer(domParent, renderWidth, renderHeight);
            this._initCallback();

            // Make sure to render on mouse over in case the renderer has swapped contexts
            var _this = this;
            domParent.addEventListener('mouseenter', function(){
                _this.render();
            });

            // Cache of the Flux entity objects for downloading
            this._entities = null;

            this._latestSceneResults = null;

            // Track the last blob that was downloaded for memory cleanup
            this._downloadUrl = null;

            // Whether the viewport is locked on the current geometry and will automatically focus on new geometry when updating the entities
            this._autoFocus = true;

            // Track whether geometry is being converted, so we don't try two at once
            this.running = false;
        }

        FluxViewport.prototype = Object.create( THREE.EventDispatcher.prototype );
        FluxViewport.prototype.constructor = FluxViewport;

        /**
         * Build the url to use for tessellation requests to flux.
         * @private
         * @param  {String} projectId Hashed project id to use in url
         * @return {String}           Url to use for tessellation requests
         */
        function _getTessUrl(projectId) {
            return 'https://flux.io/p/'+projectId+
                   '/api/blockexec?block=flux-internal/parasolid/Parasolid';
        }

        /**
         * @summary Enumeration of edges rendering modes.
         * This determines whether edges will be shown when rendering the front face, back face or both.
         * Front edge rendering can be used to achieve hidden line rendering.<br>
         * Options are NONE, FRONT, BACK, BOTH
         * @return {Object} enumeration
         */
        FluxViewport.getEdgesModes = function () {
            return EdgesHelper.EDGES_MODES;
        };

        /**
         * Name of the event fired when the camera changes
         *
         * This can be used to observe those changes and register a callback.<br>
         * For example:
         * fluxViewport.addEventListener(FluxViewport.getChangeEvent(), function() {});
         * @return {String} Event name
         */
        FluxViewport.getChangeEvent = function () {
            return FluxRenderer.CHANGE_EVENT;
        };

        /**
         * Determines whether the entity or list of entities contains geometry
         * @param  {Array.<Object>|Object}  entities Geometry data
         * @return {Boolean}          True for objects/lists containing geometry
         */
        FluxViewport.isKnownGeom = function (entities) {
            return isKnownGeom(entities);
        };

        //---- Class member functions

        /**
         * Set up the callback to render when the camera changes
         * @private
         */
        FluxViewport.prototype._initCallback = function() {
            var _this = this;
            this._renderer.addEventListener(FluxRenderer.CHANGE_EVENT, function(event) {
                _this.dispatchEvent( event );
                _this.render();
            });
        };

        /**
         * Actually render the geometry!<br>
         * This is called automatically when the camera changes.
         * You may call it on demand as needed when changing properties.
         * @memberOf FluxViewport
         */
        FluxViewport.prototype.render = function() {
            this._renderer.doRender();
        };

        /**
         * Focus the camera on the current geometry
         */
        FluxViewport.prototype.focus = function() {
            this._renderer.focus();
        };

        /**
         * Restore the camera to a default location
         */
        FluxViewport.prototype.homeCamera = function() {
            this._renderer.homeCamera();
        };

        /**
         * Set the viewport geomtery from a JSON string
         * @param {String} dataString The geometry to render formatted as JSON containing Flux entities
         * @return {Object} Promise to resolve after geometry is created
         */
        FluxViewport.prototype.setGeometryJson = function(dataString) {
            var dataObj = JSON.parse(dataString);
            return this.setGeometryEntity(dataObj);
        };

        /**
         * Set the viewport geometry from a data object containing Flux entities
         * @param {Object} data The geometry entities to render
         * @return {Object} Promise to resolve after geometry is created
         */
        FluxViewport.prototype.setGeometryEntity = function(data) {
            var _this = this;
            // The flow sends the same value twice, so we assume that requests
            // sent while there is already one pending are redundant
            // TODO(Kyle): This is a hack that we can remove once there are not always duplicate requests
            return new Promise(function (resolve, reject) {
                if (!_this.running) {
                    _this.running = true;
                    return _this._sceneBuilder.convert(data).then(function (results) {
                        var object = results.getObject();
                        _this._entities = object ? data : null;
                        _this._updateModel(object);
                        _this._latestSceneResults = results;
                        _this.running = false;
                        resolve(results);
                    }).catch(function (err) {
                        console.warn(err); // eslint-disable-line no-console
                        _this.running = false;
                    });
                } else {
                    reject(new Error('Already running. You can only convert one entity at a time.'));
                }
            }).catch(function (err) {
                if (err.message.indexOf('running') === -1) {
                    console.log(err); // eslint-disable-line no-console
                }
                throw err;
            });
        };

        /**
         * Change the geometry being rendered
         * @private
         * @param  {THREE.Object3D} newModel The new model to render
         * @param  {THREE.Object3D} oldModel The old model to remove
         */
        FluxViewport.prototype._updateModel = function(newModel) {
            this._renderer.setModel(newModel);
            if (this._autoFocus) {
                this.focus(); // changing the controls will trigger a render
                this._autoFocus = false;
            } else {
                this.render();
            }
        };

        /**
         * Make serializable by pruning all references and building an object property tree
         * @return {Object} Data to stringify
         */
        FluxViewport.prototype.toJSON = function() {
            var serializableState = {
                entities: this._entities,
                renderer: this._renderer.toJSON(),
                autoFocus: this._autoFocus
            };
            return serializableState;
        };

        /**
         * Take a data object and use it to update the viewport's internal state<br>
         * Warning this is async when it sets entities
         * @param  {Object} state The properties to set
         * @return {Promise} Completion promise
         */
        FluxViewport.prototype.fromJSON = function(state) {
            if (!state) return Promise.resolve();
            var _this = this;
            if (state.entities) {
                return this.setGeometryEntity(state.entities).then(function () {
                    _this._fromJSONHelper(state);
                });
            } else {
                this._fromJSONHelper(state);
                return Promise.resolve();
            }
        };

        /**
         * Rehydrate everything but the entities.
         * @private
         * @param  {Object} state Parameter data
         */
        FluxViewport.prototype._fromJSONHelper = function(state) {
            if (state.renderer != null) {
                this._renderer.fromJSON(state.renderer);
            }
            if (state.autoFocus != null) {
                this._autoFocus = state.autoFocus;
            }
        };

        /**
         * Download all the geometry settings and raster image that are the state of this viewport.
         * Used for QA testing.
         * @param  {String} prefix File name prefix for download path
         */
        FluxViewport.prototype.downloadState = function(prefix) {
            this._downloadJson(this.toJSON(), prefix);
            this._download(this._renderer.getGlCanvas().toDataURL('image/png'), prefix+'.png');
        };

        /**
         * Helper function to download some data from a url
         * @private
         * @param  {DOMString} dataUrl  The url containing the data to download
         * @param  {String} filename The name of the file when it downloads
         */
        FluxViewport.prototype._download = function(dataUrl, filename) {
            var a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            a.click();
        };

        /**
         * Create a link and a temporary blob url to use to download from.
         * @private
         * @param  {Object} data   The serializable data to write as JSON
         * @param  {String} prefix The file name prefix
         */
        FluxViewport.prototype._downloadJson = function(data, prefix) {
            if (this._downloadUrl) {
                window.URL.revokeObjectURL(this._downloadUrl);
            }
            var jsonString = JSON.stringify(data, null, 2);
            this._downloadUrl = window.URL.createObjectURL(new Blob([jsonString]), {type: 'text/json'});
            this._download(this._downloadUrl, prefix+'.json');
        };

        /**
         * Create a default 3 light rig on the renderer's scene.
         */
        FluxViewport.prototype.setupDefaultLighting = function() {
            var lighting = new THREE.Object3D();
            lighting.name = 'Lights';

            //TODO(Kyle) non static lighting
            this._keyLight = new THREE.DirectionalLight();
            this._keyLight.position.set(60, 80, 50);
            this._keyLight.intensity = 0.95;
            lighting.add(this._keyLight);

            var backLight = new THREE.DirectionalLight();
            backLight.position.set(-250, 50, -200);
            backLight.intensity = 0.4;
            lighting.add(backLight);

            var fillLight = new THREE.DirectionalLight();
            fillLight.position.set(-500, -500, 0);
            fillLight.intensity = 0.7;
            lighting.add(fillLight);

            this._renderer.setLights(lighting);
        };

        //---- Pass through functions

        /**
         * Set the size of the render canvas
         * @param {Number} width  Pixels
         * @param {Number} height Pixels
         */
        FluxViewport.prototype.setSize = function(width, height) {
            this._renderer.setSize(width, height);
        };

        /**
         * Set the background color of the render canvas
         * @param {THREE.color} color Background color
         */
        FluxViewport.prototype.setClearColor = function(color) {
            this._renderer.setClearColor(color);
        };

        /**
         * Set which camera view to use (ex perspective, top etc.)
         * @param {String} view Name of the camera view to use
         */
        FluxViewport.prototype.setView = function(view) {
            this._renderer.setView(view);
            this.focus();
        };

        /**
         * Return the views enumeration.
         * Allows you to change the view to perspective, top, etc.
         * @return {Object} Enumeration of view options for cameras
         */
        FluxViewport.getViews = function() {
            return FluxCameras.VIEWS;
        };

        /**
         * Set the density of the exponential fog. Generally on the order of 0.0001
         * @param {Number} density How much fog
         */
        FluxViewport.prototype.setFogDensity = function(density) {
            this._renderer._fog.density = density;
        };

        /**
         * Set the url of the tessellation service.
         * This can be used to replace the value if you did not set it on the constructor.
         * @param {String} newUrl The url of the tessellation server
         */
        FluxViewport.prototype.setTessUrl = function(newUrl) {
            this._sceneBuilder.setTessUrl(newUrl);
        };

        /**
         * Set whether the viewport should focus the geometry when it is changed
         * @param {Boolean} focus Whether to auto focus
         */
        FluxViewport.prototype.setAutoFocus = function(focus) {
            this._autoFocus = focus;
        };

        /**
         * Get whether the viewport will focus the geometry when it is changed
         * @return {Boolean} Whether to auto focus
         */
        FluxViewport.prototype.getAutoFocus = function() {
            return this._autoFocus;
        };

        /**
         * Set the edges rendering mode for hidden line rendering
         * @param  {FluxViewport.EDGES_MODES} mode Whether to render front, back, both or none
         */
        FluxViewport.prototype.setEdgesMode = function(mode) {
            this._renderer.setEdgesMode(mode);
        };

        /**
         * Get the canvas for use in QA scripts
         * @return {Canvas} WebGL canvas dom element
         */
        FluxViewport.prototype.getGlCanvas = function() {
            return this._renderer.getGlCanvas();
        };

        /**
         * Turn on shadow rendering.
         * Warning: This is an experimental feature that may not work.
         */
        FluxViewport.prototype.activateShadows = function() {
            if (!this._keyLight) return;

            this._renderer.setShadowLight(this._keyLight);
            this._renderer.addShadows();
        };

        return FluxViewport;

}(THREE));